
Java中的锁-【悲观锁、乐观锁】，【公平锁、非公平锁】，【互斥锁、读写锁】

悲观锁、乐观锁：
	悲观锁、乐观锁使用场景是针对数据库操作来说的,是一种锁机制。

	悲观锁(Pessimistic Lock)：顾名思义,就是很悲观,每次去读取数据的时候都认为别人会修改,所以每次读取数据的时候都会上锁,这样别人想修改这个数据就会阻塞，直到它拿到锁。传统的关系型数据库里边就用到了很多这种锁机制,比如行锁,表锁等,读锁,写锁等,都是在做操作之前先上锁。Java中synchronized和ReentrantLock等独占锁就是悲观锁思想。
	操作eg:select语句最后加上for update；


	乐观锁(Optimistic Lock)：顾名思义,就是很乐观,每次去读取数据的时候都认为别人不会修改,所以不会上锁,但是在更新的时候会判断一下在此期间别人有没有去更新这个数据,可以使用版本号和CAS算法机制实现,即对数据做版本控制。乐观锁适用于多读的应用类型,这样可以提高吞吐量,像数据库如果提供类似于write_condition机制的其实都是提供的乐观锁。Java中的原子变量类就是使用了乐观锁的一种实现方式CAS实现的。

	操作：
	使用版本号机制：加上一个version字段，表示数据被修改的次数；数据被修改时，version会自动加1；读取数据也读取version值，当该值等于数据库中的version时，才更新；否则，重试更新操作；【建议使用这个】

	或者CAS算法：compare and swap（比较和交换）一种无锁算法；缺点是ABA问题；

	结论：乐观锁使用于写少读多的情况，悲观锁使用于写多读少的情况；




公平锁、非公平锁：
	公平锁(Fair):加锁前检查是否有排队等待的线程,优先排队等待的线程,先来先得。

	非公平锁(Nonfair):加锁时不考虑排队等待问题,直接尝试获取锁,获取不到自动到队尾等待。

	ReentrantLock锁内部提供了公平锁与非公平锁内部类之分,默认是非公平锁,如:

	public ReentrantLock() { sync = new NonfairSync(); } public ReentrantLock(boolean fair) { sync = fair ? new FairSync() : new NonfairSync(); }




互斥锁、读写锁：
	··互斥锁:指的是一次最多只能有一个线程持有的锁。在jdk1.5之前, 我们通常使用synchronized机制控制多个线程对共享资源的访问。 而现在, Lock提供了比synchronized机制更广泛的锁定操作, 

		Lock和synchronized机制的主要区别: 
			·接口，关键字；
			·灵活，愣头青；
			·手动释放，自动释放；


	··读写锁:ReadWriteLock接口及其实现类ReentrantReadWriteLock,默认情况下也是非公平锁。

	ReentrantReadWriteLock中定义了2个内部类,ReentrantReadWriteLock.ReadLock和ReentrantReadWriteLock.WriteLock,分别用来代表读取锁和写入锁,ReentrantReadWriteLock对象提供了readLock()和writeLock()方法，用于获取读取锁和写入锁。

	java.util.concurrent.locks.ReadWriteLock接口允许一次读取多个线程,但一次只能写入一个线程:

	读锁 - 如果没有线程锁定ReadWriteLock进行写入,则多线程可以访问读锁。
	写锁 - 如果没有线程正在读或写,那么一个线程可以访问写锁。

	其中:
			读取锁允许多个reader线程同时持有,而写入锁最多只能有一个writer线程持有。
			读写锁的使用场合是:读取数据的频率远大于修改共享数据的频率。在上述场合下使用读写锁控制共享资源的访问,可以提高并发性能。
			如果一个线程已经持有了写入锁,则可以再持有读取锁。相反,如果一个线程已经持有了读取锁,则在释放该读取锁之前,不能再持有写入锁。


	从锁的粒度来看，我们可以将数据库的锁分成2大类：表锁和行锁；
	表锁又分为表读锁和表写锁，行锁又分为共享锁和排它锁，而·共享锁和排它锁又有别名：
	共享锁·读锁·S锁
	排它锁·写锁·X锁




锁的分类：
	1、自旋锁 ,自旋，jvm默认是10次吧，有jvm自己控制。for去争取锁
	2、阻塞锁 被阻塞的线程，不会争夺锁。
	3、可重入锁 多次进入改锁的域

	4、读写锁
	5、互斥锁 锁本身就是互斥的

	6、悲观锁 不相信，这里会是安全的，必须全部上锁
	7、乐观锁 相信，这里是安全的，无需上锁。

	8、公平锁 有优先级的锁
	9、非公平锁 无优先级的锁

	10、偏向锁 无竞争不锁，有竞争挂起，转为轻量锁
	11、对象锁 锁住对象
	12、线程锁
	13、锁粗化 多锁变成一个，自己处理
	14、轻量级锁 CAS 实现
	15、锁消除 偏向锁就是锁消除的一种
	16、锁膨胀 jvm实现，锁粗化
	17、信号量 使用阻塞锁 实现的一种策略
	18、排它锁：X锁，若事务T对数据对象A加上X锁，则只允许T读取和修改A，其他任何事务都不能再对A加任何类型的锁，直到T释放A上的锁。这就保证了其他事务在T释放A上的锁之前不能再读取和修改A。




CopyOnWriteArrayList适合使用在读操作远远大于写操作的场景里，比如缓存。

ReadWriteLock当写操作时，其他线程无法读取或写入数据，而当读操作时，其它线程无法写入数据，但却可以读取数据 。适用于读取远远大于写入的操作。



锁的分类：随着锁的竞争，锁可以从偏向锁升级到轻量级锁，再升级的重量级锁，但是锁的升级是单向的，也就是说只能从低到高升级，不会出现锁的降级。
	无锁状态：
	偏向锁：
	轻量级锁：
	重量级锁：


Java对象头