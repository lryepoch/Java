
编码：https://www.cnblogs.com/linjiqin/tag/java%20%E5%A4%9A%E7%BA%BF%E7%A8%8B/default.html?page=1


java多线程有几种实现方法，都是什么？同步有几种实现方法，都是什么?         

	1、java实现多线程有 2 种方法：

		1.继承Thread类；如果需要访问当前线程，则无需使用 Thread.currentThread() 方法，直接使用 this 即可获得当前线程。

		2.实现Runnable接口；线程类只是实现了 Runnable 接口或 Callable 接口，还可以继承其他类。

		这两种方法的共同点：不论用哪种方法，都必须用Thread（如果是Thead子类就用它本身）产生线程，然后再调用start()方法。

		两种方法的不同点：

			1、继承Thread类有一个缺点就是单继承，而实现Runnable接口则弥补了它的缺点，可以实现多继承

			2、继承Thread类，如果产生Runnable实例对象，就必须产生多个Runnable实例对象，然后再用Thread产生多个线程；
				而实现Runnable接口，只需要建立一个实现这个类的实例，然后用这一个实例对象产生多个线程。即实现了资源的共享性。

				继承Thread类：run()在Thread里。线程对象和线程任务耦合在一起。一旦创建Thread类的子类对象，既是线程对象，又有线程任务。

				实现Runnable接口：run()在Runnable里。将线程任务单独分离出来封装成对象（Runnable接口类型），用Runnable来标明线程任务，用Thread来明确线程对象。Runnable接口对线程对象和线程任务进行解耦。


	2、线程同步的实现方式：/通信方式

		1.synchronized：java的每个对象都有一个内置锁；
			同步方法默认用this或者当前类class对象作为锁；
			同步代码块可以选择以什么来加锁，比同步方法要更细颗粒度，我们可以选择只同步会发生同步问题的部分代码而不是整个方法；

		2.wait() 与 notify()：会释放锁

		3.特殊域变量volatile：为域变量的访问提供了一种免锁机制；

		4.重入锁ReentrantLock类：lock()、unlock()[finally从句执行]；

		5.使用局部变量ThreadLocal：解决多线程中相同变量的访问冲突问题；

		6.使用阻塞队列LinkedBlockingQueue<E>：前5种是底层实现的线程同步

		7.使用原子变量AtomicInteger等：使基本数据类型以原子的方式实现自增自减等操作。

		另解决线程同步与互斥的主要方式是cas、synchronized、和Lock。





Java中线程的可用状态有几种？

	1. 新建( new )：新创建了一个线程对象。

	2. 就绪( runnable )：线程准备运行，不一定立马就能开始执行。线程对象创建后,其他线程(比如 main 线程)调用了该对象的start()方法。该状态的线程位于可运行线程池中,等待被线程调度选中,获 取 cpu 的使用权 。

	3. 运行( running )：进程正在执行线程的代码。可运行状态( runnable )的线程获得了 cpu 时间片( timeslice ) ,执行程序代码。

	4. 阻塞( block )：阻塞状态是指线程因为某种原因放弃了 cpu 使用权,也即让出了 cpu timeslice ,暂时停止运行。直到线程进入可运行( runnable )状态,才有机会再次获得 cpu timeslice 转到运行( running )状态。

	5. 死亡( dead )：线程完成了执行。线程 run ()、 main () 方法执行结束,或者因异常退出了 run ()方法,则该线程结束生命周期。死亡的线程不可再次复生。





Java线程的阻塞方式有？
　　1.join()：在线程B中调用了线程A的Join()方法，直到线程A执行完毕后，才会继续执行线程B；
　　2.sleep()：Thread类的方法；不释放锁；任意位置使用；需要捕获异常；
	3.wait()：Object类的方法；释放锁；只能在同步方法或者同步代码块中使用；不需要捕获异常；
　　3.yield()：暂停当前正在执行的线程对象，并执行其他线程。目的是让相同优先级的线程之间能适当的轮转执行。yield()将导致线程从运行状态转到就绪状态，但有可能没有效果。
　　4.改变线程的优先级
　　5.将线程设置成守护线程（jvm中的垃圾回收线程）






·解析wait、notify、notifyAll(同步对象才有)？

	>简介：
	在 Java 中，可以通过配合调用 Object 对象的 wait() 方法和 notify()方法或 notifyAll() 方法来实现线程间的通信。
	在线程中调用 wait() 方法，将阻塞等待其他线程的通知（其他线程调用 notify() 方法或 notifyAll() 方法），在线程中调用 notify() 方法或 notifyAll() 方法，将通知其他线程从 wait() 方法处返回。

	Object 是所有类的超类，它有5个方法组成了等待/通知机制的核心：
	notify()、notifyAll()、wait()、wait(long)和wait(long，int)。
	在Java中，所有的类都从Object继承而来，因此，所有的类都拥有这些共有方法可供使用。而且，由于他们都被声明为 final，因此在子类中不能覆写任何一个方法。


	>意思：
	wait()的意思是，让占用了这个同步对象的线程，临时释放当前的占用，并且等待。 所以调用wait() 是有前提条件的，一定是在synchronized块里，否则就会出错。
	notify()的意思是，通知一个在这个同步对象上等待的线程，你可以苏醒过来了，有机会重新占用当前对象了。jvm指定。
	notifyAll()的意思是，通知所有在这个同步对象上等待的线程，你们可以苏醒过来了，有机会重新占用当前对象了。互相抢占。


	>深入理解：
	如果线程调用了对象的 wait()方法，那么线程便会处于该对象的等待池中，等待池中的线程不会去竞争该对象的锁。
	当有线程调用了对象的 notifyAll()方法（唤醒所有 wait 线程）或 notify()方法（只随机唤醒一个 wait 线程），被唤醒的的线程便会进入该对象的锁池中，锁池中的线程会去竞争该对象锁。

	优先级高的线程竞争到对象锁的概率大，假若某线程没有竞争到该对象锁，它还会留在锁池中，唯有线程再次调用wait()方法，它才会重新回到等待池中。而竞争到对象锁的线程则继续往下执行，直到执行完了 synchronized 代码块，它会释放掉该对象锁，这时锁池中的线程会继续竞争该对象锁。


	>补充：
	wait()与notify/notifyAll() 的执行过程：
	由于 wait() 与  notify/notifyAll() 是放在同步代码块中的，因此线程在执行它们时，肯定是进入了临界区中的，即该线程肯定是获得了锁的。

	当线程执行wait()时，会把当前的锁释放，然后让出CPU，进入等待状态。

	当执行notify/notifyAll方法时，会唤醒一个处于等待该 对象锁 的线程，然后继续往下执行，直到执行完退出对象锁锁住的区域（synchronized修饰的代码块）后再释放锁。

	从这里可以看出，notify/notifyAll()执行后，并不立即释放锁，而是要等到执行完临界区中代码后，再释放。故在实际编程中，我们应该尽量在线程调用notify/notifyAll()后，立即退出临界区。即不要在notify/notifyAll()后面再写一些耗时的代码。wait()与notify/notifyAll()都是放在同步代码块中才能够执行的。如果在执行wait() 与  notify/notifyAll()之前没有获得相应的对象锁，就会抛出：java.lang.IllegalMonitorStateException异常。





ThreadLocal 与 Synchronized区别？

	1.相同：ThreadLocal和线程同步机制都是为了解决多线程中相同变量的访问冲突问题。
		不同：Synchronized同步机制采用了“以时间换空间”的方式，仅提供一份变量，让不同的线程排队访问；
					而ThreadLocal采用了“以空间换时间”的方式，每一个线程都提供了一份变量副本，因此可以同时访问而互不影响。

	2.ThreadLocal与共享没有关系。
		ThreadLocal 是多线程下的无锁解决方案之一。就是每个线程对于ThreadLocal都有一个备份，主要用于保存线程的特征，比如你给线程重命名啦之类的。
		核心是每个线程中都有一个ThreadLocal的副本，而普通的则是共享的。

	小结：ThreadLocal是解决线程安全问题一个很好的思路，它通过为每个线程提供一个独立的变量副本解决了变量并发访问的冲突问题。
			在很多情况下，ThreadLocal比直接使用synchronized同步机制解决线程安全问题更简单，更方便，且结果程序拥有更高的并发性。

			Synchronized用于线程间的数据共享，而ThreadLocal则用于线程间的数据隔离。




Lock与 Synchronized区别？

	1.本质：Lock是一个接口，是代码层面的实现。而synchronized是Java中的关键字，是内置的语言实现。

	2.获取锁：Lock可以选择性的获取锁，如果一段时间获取不到，可以放弃。synchronized不行，会一根筋一直获取下去。 借助Lock的这个特性，就能够规避死锁，synchronized必须通过谨慎和良好的设计，才能减少死锁的发生。

	3.释放锁：synchronized在发生异常和同步块结束的时候，会自动释放锁。而Lock必须手动释放，所以如果忘记了释放锁，一样会造成死锁。

	4.线程交互：使用synchronized方式进行线程交互，用到的是同步对象的wait,notify和notifyAll方法；Lock也提供了类似的解决办法，首先通用过lock对象得到一个Condition对象，然后分别调这个Condition对象的：await, signal,signalAll 方法。





关于 Synchronized和 volatile之间的比较？

	1.volatile是轻量级的实现，所以性能比synchronized要好，随着jdk新版本的发布，synchronized在执行效率上得到很大的提升。
		volatile只能修饰变量，synchronized可以修饰方法以及代码块。

	2.线程访问volatile不会阻塞，synchronized则会。

	3.volatile保证数据可见性，不能保证原子性；
		synchronized可保证原子性，也保证可见性，因为他会将私有内存和主内存中的数据做同步。

	4.volatile解决的是变量在多个线程之间的可见性；而synchronized关键字解决的是多个线程之间访问资源的同步性。





线程安全性的三个体现：
	原子性：提供互斥访问，同一时刻只能有一个线程对数据进行操作（Atomic、CAS算法、synchronized、Lock）

	可见性：一个主内存的线程如果进行了修改，可以及时被其他线程观察到（synchronized、volatile）

	有序性：即禁止指令重排序。如果两个线程不能从happens-before原则观察出来，那么就不能观察他们的有序性，虚拟机可以随意的对他们进行重排序，导致其观察结果杂乱无序（happens-before原则）




前台线程与后台线程：

	1.后台线程：指为其他线程提供服务的线程，也称为守护线程。JVM的垃圾回收线程就是一个后台线程。 

	2.前台线程：是指接受后台线程服务的线程，其实前台后台线程是联系在一起，就像傀儡和幕后操纵者一样的关系。傀儡是前台线程、幕后操纵者是后台线程。由前台线程创建的线程默认也是前台线程。可以通过isDaemon()和setDaemon()方法来判断和设置一个线程是否为后台线程。

	3.使用Thread建立的线程默认情况下是前台线程，在进程中，只要有一个前台线程未退出，进程就不会终止。主线程就是一个前台线程。而后台线程不管线程是否结束，只要所有的前台线程都退出（包括正常退出和异常退出）后，进程就会自动终止。




如何提高一个系统的并发性？
	1.物理层增加网络宽带，域名解析分发多台服务器
	2.操作系统层，多线程多核编程，epoll，事件驱动框架，异步消息机制
	3.业务层，优化数据库查询，redis缓存等




Java内存模型——JMM：
	Java的并发采用的是共享内存模型。



其他
----------------
协程是一种用户态的轻量级线程，协程的调度完全由用户控制。协程拥有自己的寄存器上下文和栈。协程调度切换时，将寄存器上下文和栈保存到其他地方，在切回来的时候，恢复先前保存的寄存器上下文和栈，直接操作栈则基本没有内核切换的开销，可以不加锁的访问全局变量，所以上下文的切换非常快。

线程调度分为协同式调度和抢占式调度，Java使用的是抢占式调度，也就是每个线程将由操作系统来分配执行时间，线程的切换不由线程本身来决定（协同式调度）。这就是平台独立的原因。

