
分库分表

·为什么？提升数据库响应速度，缩短查询时间

·分类：垂直（纵向）切分和水平（横向）切分

	··垂直切分又细分为垂直分库和垂直分表；
		···垂直分库基于业务，有独立的数据库；
		···垂直分表基于数据表的列为依据，大表拆小表；
			eg：把长度较大且访问不频繁的字段，拆分出来创建一个单独的扩展表work_extend进行存储；【数据库是以行为单位将数据加载到内存中】

	··水平切分：水平切分将一张大数据量的表，切分成多个表结构相同，而每个表只占原表一部分数据，然后按不同的条件分散到多个数据库中
		背景：垂直切分还是会存在单表数据量过大的问题；
		水平切分又分有库内分表和分库分表；
		···库内分表：库内分表虽然将表拆分，但子表都还是在同一个数据库实例中
		···分库分表：将切分出来的子表，分散到不同的数据库中，从而使得单个表的数据量变小，达到分布式的效果

			该往哪个库的表里存：
			····根据取值范围：按照时间区间或ID区间来切分，举个栗子：假如我们切分的是用户表，可以定义每个库的User表里只存10000条数据，第一个库userId从1 ~ 9999，第二个库10000 ~ 20000，第三个库20001~ 30000......以此类推；
			····hash取模：对数据库从0到N-1进行编号，对User表中userId字段进行取模，得到余数i，i=0存第一个库，i=1存第二个库，i=2存第三个库....以此类推；
			
			会有哪些坑：
			····事务一致性问题：不苛求系统的实时一致性，只要在允许的时间段内达到最终一致性
			····分页、排序的坑：
			····全局唯一主键问题：



·如何去写一手好SQL?
··MySQL性能
	最大数据量：抛开数据量和并发数，谈性能都是耍流氓。MySQL 没有限制单表最大记录数，它取决于操作系统对文件大小的限制。

	《阿里巴巴Java开发手册》提出单表行数超过500万行或者单表容量超过2GB，才推荐分库分表。性能由综合因素决定，抛开业务复杂度，影响程度依次是硬件配置、MySQL配置、数据表设计、索引优化。500万这个值仅供参考，并非铁律。

	最大并发数：并发数是指同一时刻数据库能处理多少个请求，由 max_connections 和 max_user_connections 决定。max_connections 是指 MySQL 实例的最大连接数，上限值是 16384，max_user_connections 是指每个数据库用户的最大连接数。
MySQL会为每个连接提供缓冲区，意味着消耗更多的内存。如果连接数设置太高硬件吃不消，太低又不能充分利用硬件。一般要求两者比值超过10%。

	查询耗时0.5秒：建议将单次查询耗时控制在0.5秒以内，0.5秒是个经验值，源于用户体验的3秒原则。如果用户的操作3秒内没有响应，将会厌烦甚至退出。响应时间=客户端UI渲染耗时+网络请求耗时+应用程序处理耗时+查询数据库耗时，0.5秒就是留给数据库1/6的处理时间。

	实施原则：数据库少干活，应用程序多干活。
	充分利用但不滥用索引，须知索引也消耗磁盘和CPU。
	不推荐使用数据库函数格式化数据，交给应用程序处理。
	不推荐使用外键约束，用应用程序保证数据准确性。
	写多读少的场景，不推荐使用唯一索引，用应用程序保证唯一性。
	适当冗余字段，尝试创建中间表，用应用程序计算中间结果，用空间换时间。
	不允许执行极度耗时的事务，配合应用程序拆分成更小的事务。
	预估重要数据表（比如订单表）的负载和数据增长态势，提前优化。

··数据表设计
	数据类型：选择原则是更简单或者占用空间更小。
	如果长度能够满足，整型尽量使用tinyint、smallint、medium_int而非int。
	如果字符串长度确定，采用char类型。
	如果varchar能够满足，不采用text类型。
	精度要求较高的使用decimal类型，也可以使用BIGINT，比如精确两位小数就乘以100后保存。
	尽量采用timestamp而非datetime。
	datetime 8字节 '1000-01-01 00:00:00.000000' to '9999-12-31 23:59:59.999999'
	timestamp 4字节 '1970-01-01 00:00:01.000000' to '2038-01-19 03:14:07.999999'
	相比datetime，timestamp占用更少的空间，以UTC的格式储存自动转换时区。

	避免空值：MySQL中字段为NULL时依然占用空间，会使索引、索引统计更加复杂。从NULL值更新到非NULL无法做到原地更新，容易发生索引分裂影响性能。尽可能将NULL值用有意义的值代替，也能避免SQL语句里面包含is not null的判断。

	text类型：由于text字段储存大量数据，表容量会很早涨上去，影响其他字段的查询性能。建议抽取出来放在子表里，用业务主键关联。

··索引优化
	索引分类：
	普通索引：最基本的索引。
	组合索引：多个字段上建立的索引，能够加速复合查询条件的检索。
	唯一索引：与普通索引类似，但索引列的值必须唯一，允许有空值。
	组合唯一索引：列值的组合必须唯一。
	主键索引：特殊的唯一索引，用于唯一标识数据表中的某一条记录，不允许有空值，一般用primary key约束。
	全文索引：用于海量文本的查询，MySQL5.6之后的InnoDB和MyISAM均支持全文索引。由于查询精度以及扩展性不佳，更多的企业选择Elasticsearch。

	优化原则：
	分页查询很重要，如果查询数据量超过30%，MYSQL不会使用索引。
	单表索引数不超过5个、单个索引字段数不超过5个。
	字符串可使用前缀索引，前缀长度控制在5-8个字符。
	字段唯一性太低，增加索引没有意义，如：是否删除、性别。

··SQL优化
	分批处理：不带分页参数的查询或者影响大量数据的update和delete操作，都是树枝，我们要把它打散分批处理。

	不做列运算：
	通常在查询条件列运算会导致索引失效，如下所示：
	查询当日订单
	select id from order where date_format(create_time，'%Y-%m-%d') = '2019-07-01';
	date_format函数会导致这个查询无法使用索引，改写后：
	select id from order where create_time between '2019-07-01 00:00:00' and '2019-07-01 23:59:59';

	避免Select *：如果不查询表中所有的列，避免使用SELECT *，它会进行全表扫描，不能有效利用索引。

	操作符<>优化：
	通常<>操作符无法使用索引，举例如下，查询金额不为100元的订单：
	select id from orders where amount != 100;
	如果金额为100的订单极少，这种数据分布严重不均的情况下，有可能使用索引。鉴于这种不确定性，采用union聚合搜索结果，改写方法如下：
	(select id from orders where amount > 100)
	 union all
	(select id from orders where amount < 100 and amount > 0)

	OR优化：
	在Innodb引擎下or无法使用组合索引，比如：
	select id，product_name from orders where mobile_no = '13421800407' or user_id = 100;
	OR无法命中mobile_no + user_id的组合索引，可采用union，如下所示：
	(select id，product_name from orders where mobile_no = '13421800407')
	 union
	(select id，product_name from orders where user_id = 100);

	IN优化：
	IN适合主表大子表小，EXIST适合主表小子表大。由于查询优化器的不断升级，很多场景这两者性能差不多一样了。
	尝试改为join查询，举例如下：
	select id from orders where user_id in (select id from user where level = 'VIP');
	采用JOIN如下所示：
	select o.id from orders o left join user u on o.user_id = u.id where u.level = 'VIP';

	LIKE优化：
	like用于模糊查询，举个例子（field已建立索引）：
	SELECT column FROM table WHERE field like '%keyword%';
	这个查询未命中索引，换成下面的写法：
	SELECT column FROM table WHERE field like 'keyword%';
	去除了前面的%查询将会命中索引，但是产品经理一定要前后模糊匹配呢？全文索引fulltext可以尝试一下，但Elasticsearch才是终极武器。

	JOIN优化:
	join的实现是采用Nested Loop Join算法，就是通过驱动表的结果集作为基础数据，通过该结数据作为过滤条件到下一个表中循环查询数据，然后合并结果。如果有多个join，则将前面的结果集作为循环数据，再次到后一个表中查询数据。
	驱动表和被驱动表尽可能增加查询条件，满足ON的条件而少用Where，用小结果集驱动大结果集。
	被驱动表的join字段上加上索引，无法建立索引的时候，设置足够的Join Buffer Size。
	禁止join连接三个以上的表，尝试增加冗余字段。

	LIMIT优化:limit用于分页查询时越往后翻性能越差，解决的原则：缩小扫描范围；


··其他数据库：作为一名后端开发人员，务必精通作为存储核心的MySQL或SQL Server，也要积极关注NoSQL数据库，他们已经足够成熟并被广泛采用，能解决特定场景下的性能瓶颈。
	Memcache/Redis/MongoDb/Neo4J