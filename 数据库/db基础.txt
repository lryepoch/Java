MySQL基础：

·SQL语言分类：
		
	··DQL（数据查询语言）：基本结构是由SELECT子句，FROM子句，WHERE 子句组成的查询块： SELECT <字段名表> FROM <表或视图名> WHERE <查询条件>
	··DML（data manipulation language）：是UPDATE、INSERT、DELETE，就象它的名字一样，这3条命令是用来对 数据库 里的数据进行操作的语言 
	··DDL（data definition language）：
	       DDL比DML要多，主要的命令有CREATE、ALTER、DROP等，DDL主要是用在定义或改变表（TABLE）的结构，数据类型，表之间的链接和约束等初始化工作上，他们大多在建立表时使用 ；
	··DCL（Data Control Language）： 
	       是数据库控制功能。是用来设置或更改数据库用户或角色权限的语句，包括（grant,deny,revoke等）语句。在默认状态下，只有sysadmin,dbcreator,db_owner或db_securityadmin等人员才有权力执行DCL；


·数据库基本概念：
	··主码：唯一标识一张表。主码一定是候选码的子集，但候选码不一定是主码。
	··候选码：候选码（超级码）就是可以被选为主码的属性或属性组，某一属性或者属性组的值能唯一地标识一个元组。
				例如：在学生实体中，“学号”是能唯一的区分学生实体的，同时又假设“姓名”、“班级”的属性组合足以区分学生实体，那么{学号}和{姓名，班级}都是（超级码）候选码。

	··主属性：候选码中出现过的属性称为主属性；如果主码是一个属性组，那么属性组中的属性都是主属性。
	··非主属性：不包含在任何候选码中的属性。

	··超码：类似于一个实体集中的幂集，不过其中必须是带有候选码的幂集，所以候选码是最小的超码。超码包括候选码，候选码包括主码。
	··全码：最极端的情况是全表字段都用来做主码，这时的主码也叫全码。
	··码：主码或者候选码的叫法。

	··计算机模式结构有三种，分别为：外模式、模式和内模式 ，其中外模式一般也被称为用户子模式。
	··在关系代数运算中，五种基本运算为并、差、选择、投影、乘积(笛卡尔积)。
	··关系运算包括选择、投影、连接以及除法。
	··集合运算是二目运算，包括并、差、交、广义笛卡尔积四种运算。

	··数据元素可由若干个数据项组成，数据项是数据的不可分割的最小单位。数据元素也就是记录。描述事物性质的最小数据单位是数据项，由数据项组成各个记录，再由各个记录组成文件。

	··从集合论角度看：等值连接是内连接的子集。等值连接不将重复属性去掉，而自然连接去掉重复属性，也可以说，自然连接是去掉重复列的等值连接。
	··自然连接则是在等值连接(以公共属性值相等为条件)的基础上再行投影操作，去掉S中的公共属性列，当两个关系没有公共属性时，自然连接就转化成笛卡尔积。首先，两个不同的表结构无法做并集和交集操作。 

	··在关系代数中，连接运算是由一个笛卡尔积运算和一个选取运算构成的。首先用笛卡尔积完成对两个数据集合的乘运算，然后对生成的结果集合进行选取运算。确保只把分别来自两个数据集合并且具有重叠部分的行合并在一起。。连接的全部意义在于在水平方向上合并两个数据集合（通常是表），并产生一个新的结果集合。其方法是将一个数据源中的行于另一个数据源中和它匹配的行组合成一个新元组。

	··数据库是长期存储在计算机内、有组织的、可共享的大量数据的结合。数据库中的数据按一定的数据模型组织。描述和存储，具有较小的冗余度。较高的数据独立性和易扩展性，并为各种用户共享。

	··一句话简单来说，外键的主要目的是“限制”，而不是“查询”。所以，连接查询时可以没有外键约束。

·设计数据库有如下6个主要步骤：
	1、需求分析：了解用户的数据需求、处理需求、安全性及完整性要求；
	2、概念设计：通过数据抽象，设计系统概念模型（实体、联系等），一般为E-R模型；
	3、逻辑结构设计：设计系统的模式和外模式，对于关系模型主要是基本表和视图；
	4、物理结构设计：设计数据的存储结构和存取方法，如索引的设计；
	5、系统实施：组织数据入库、编制应用程序、试运行；
	6、运行维护：系统投入运行，长期的维护工作。

	三元联系就是三个实体之间的关系；
	规范化解决了数据冗余，更新异常，插入异常，删除异常四个问题；

	··三大范式：
		【公式：提取实体、联系---->画er图（ER图中实体图的外键不用标出来，它藏在了1与n中。联系图联合主键也不用标出来）---->规范化（实体转换成一个关系，联系也转换成一个关系，主码相同的关系可以合并。）---->转化成关系，表】

		第一范式：每列保持原子性。
		第二范式：每列都和主键相关，不能只和主键的一部分相关（针对联合主键而言）。非主属性完全依赖于主属性；
		第三范式：确保每列都和主键列直接相关，而不是间接相关。非主属性不存在传递依赖于主属性；
		BCNF：消除主属性对码的部分和传递函数依赖；

	··数据表之间的关联关系分为三种：一对一、一对多/多对一、多对多。

		···一对一是将数据表“垂直切分”，其实是不常见，或不常用的。也就是A表的一条记录对应B表的一条记录。还有根据具体的业务来决定，如果当一张表的字段过于太多，而很多字段可能只有在某些情况下，才会使用到，这时也可以考虑使用一对一设计。
			一对一有2种情况：一种是外键关联，一种是主键关联。外键放在任何一张表均可，不用在两张表都设置外键；主键关联就是共享主键的意思。

		···一对多，是最常见的一种设计。就是A表的一条记录，对应B表的多条记录，且A的主键作为B表的外键。这主要看以哪张表为中心，以上示例以A表为中心，就是一对多，如果以B表为中心，则是多对一。
			（如果外键设计在一的表上怎么设计？要么把记录不断重复，要么一个字段不断增长最终爆炸，显然都是不行的。）
			（如果一对多的关系表中也有一些属性，则这一些属性将添加到多的实体转换而成的关系表中！！）

		···多对多，在数据库中也比较常见，可以理解为是一对多和多对一的组合。要实现多对多，一般都需要有一张中间表（也叫关联表），将两张表进行关联，形成多对多的形式。


·事务：

	··事务：在 MySQL 中只有使用了 InnoDB 数据库引擎的数据库或表才支持事务。事务处理可以用来维护数据库的完整性，保证成批的SQL要么全部执行，要么全部不执行。
			在 MySQL 命令行的默认设置下，事务都是自动提交的，即执行 SQL 语句后就会马上执行 COMMIT 操作。

	··事务的四个特性：原子性（回滚）、一致性（完整性约束）、隔离性（锁）、永久性（改变永久）。

	··事务的并发问题：
		0.更新丢失：事务A和事务B读取同一数据并修改，如果A先提交，那么B提交的结果覆盖A提交的结果；
	　　1.脏读：事务A读取了事务B更新的数据，然后B回滚，那么A读取到的数据是脏数据；
	　　2.不可重复读：事务A多次读取同一数据，事务 B 在事务A多次读取的过程中，对数据作了更新并提交，导致事务A多次读取同一数据时，结果 不一致。
	　　3.幻读：事务A多次读取同一数据，事务 B 在事务A多次读取的过程中，对数据作了增加或者删除并提交，导致事务A多次读取同一数据时，结果 不一致。
	　　小结：不可重复读的和幻读很容易混淆，不可重复读侧重于修改，幻读侧重于新增或删除。解决不可重复读的问题只需锁住满足条件的行，解决幻读需要锁表；

	··事务隔离级别【隔离性中】：

			【事务隔离级别】        【并发问题：脏读	      不可重复读	      幻读】
			读未提交（read-uncommitted）	     是	              是	           是
			读已提交（read-committed）	     	否	              是	            是
			可重复读（repeatable-read）	         否	              否	            是
			串行化（serializable）	            否				  否				否

		1.事务隔离级别为读已提交时，写数据只会锁住相应的行；
	　　2.事务默认隔离级别为可重复读时，如果检索条件有索引（包括主键索引）的时候，默认加锁方式是next-key锁；如果检索条件没有索引，更新数据时会锁住整张表。一个间隙被事务加了锁，其他事务是不能在这个间隙插入记录的，这样可以防止幻读。
	　　3.事务隔离级别为串行化时，读写数据都会锁住整张表。所有事务都一个接一个地串行执行；
	　　4.隔离级别越高，越能保证数据的完整性和一致性，但是并发程度越低。
		5.Mysql 默认采用的 可重复读 隔离级别 ，Oracle 默认采用的 读已提交 隔离级别。





·索引：对数据库中所有记录的引用指针，一个表可以创建使用16个索引列；
			对数据库表中一列或多列的值进行排序的一种结构，使用索引可快速访问数据库表中的特定信息；

	··为什么要使用索引？/索引优点？
			1.加快数据的检索速度；
			2.将随机i/o变成顺序i/o；
			3.帮助服务器避免排序和临时表；
			4.创建唯一性索引，保证表中每一行数据的唯一性；
			5.加快表和表之间的连接；

	··为什么不可以每一列都创建索引？/索引缺点？
			1.当进行增删改查的时候，需要动态维护索引，这就降低了维护的速度；
			2.索引也占用物理空间，如果每一列都建，占用的空间只会更大；
			3.创建和维护索引需要耗费时间，时间随着数据量的增加而增加；

	··索引是如何提高检索速度的？
			将无序的数据变成相对有序的数据；

	··索引方法（数据结构）：
https://www.cnblogs.com/luyucheng/p/6289048.html

		1.BTree索引：
		默认索引类型是BTree，使用的是B树中的B+Tree；
		适合用来查找某一范围内的数据，而且可以直接支持数据排序（ORDER BY）；
		B-Tree对于myisam和innodb2种引擎的实现方式是不一样的；
		B-Tree索引的优于HASH索引的是，可以使用部分查询和通配查询，也可以使用<、>等操作符方便数据挖掘。HASH索引进行“相等比较”非常快，但是对“范围比较”的速度就慢多了，因此HASH索引值适合使用在=和<>的操作符中，不适合在<或>操作符中，也同样不适合用在order by子句中。

2.Hash索引：
		底层数据结构就是hash表，需求为单条记录查询的话可以使用这个，查询性能快；
		仅支持"=","IN"和"<>"精确查询（“相等比较”），不能使用范围查询，不支持排序；
		Hash索引一般用于内存数据库，比如Memory存储引擎（在MySQL中只有Memory存储引擎显式支持Hash索引，虽然它也支持B-Tree索引），数据放到内存里，为了加快速度，创建hash索引。

	··索引的性质分类：
		聚簇索引：表中记录的物理顺序和索引的排列顺序一致；
		非聚簇索引：……不一致；
		区别：聚簇索引能提高多行检索的速度，而非聚簇索引对于单行的检索很快。

	··MYSQL索引类型：
		普通索引（最基本的MySQL数据库索引，它没有任何限制），
		唯一索引（unique，数据库索引列的值必须唯一，但允许有空值），
		主键索引（一种特殊的唯一索引，一个表只能有一个主键，不允许有空值），
		组合索引（对比于单列索引，MySQL组合索引遵循“最左前缀”集合，简单的理解就是只从最左边的开始组合。在查询条件中使用了创建索引时的第一个字段，索引才会被使用。效率大于索引合并），
		全文索引（fulltext，用来查找文本中的关键字，而不是直接与索引中的值相比较；像是一个搜索引擎，而不是简单的where语句的参数匹配。fulltext索引配合match 									against操作使用，而不是一般的where语句加like；目前只有char、varchar，text列上可以创建全文索引。值得一提的是，在数据量较大时候，现将数据放入一个没有全局索引的表中，然后再用CREATE index创建fulltext索引，要比先为一张表建立fulltext然后再将数据写入的速度快很多。）；


	··问题：索引字段值不唯一，应该选择的索引类型为（普通索引）。

		[知识点] 表的索引：主索引，候选索引，普通索引，唯一索引
		[评析] 索引类型分类：
		①主索引：主索引是一种只能在数据库表中建立不能在自由表中建立的索引。在指定的字段或表达式中，主索引的关键字绝对不允许有重复值。
		②候选索引：和主索引类似，它的值也不允许在指定的字段或表达式中重复。一个表中可以有多个候选索引。
		③唯一索引：唯一索引允许关键字取重复的值。当有重复值出现时，索引文件只保存重复值的第1次出现。提供唯一索引主要是为了兼容早期的版本。
		④普通索引：普通索引允许关键字段有相同值。在一对多关系的多方，可以使用普通索引。



	··一般在什么时候应该创建索引？

		在不同值多的列上建；
		经常搜索的列上；
		非经常更新的行建立索引；

		经常使用where字句、排序和分组的列上；
		经常用在连接的列上，主要是一些外键；

		适合中到大型表的列上，不适合特大型表；
		当唯一性是一种特征时，指定唯一索引；

			非越多越好；
	        数据量小不要用；



	··索引使用注意事项：

		···短索引（给索引设置长度）如果可以的话，应该指定一个前缀长度。如果有一个char(255)的列，如果在前10个或20个字符内，多数值是惟一的，那么就不要对整个列进行索引。短索引不仅能够提高查询速度，而且能节省I/O操作。
		···使用逻辑主键作为主键，不要使用业务主键为主键；

		···删除长期未使用的索引，不要造成不必要的性能损耗；


··索引什么情况下会失效？

		索引会忽略null值，所以我们在设计数据库的时候设置为NOT_NULL，只要列中包含有null值都将不会被包含在索引中；

		不适用于否定操作（not in , <>, !=）；

		where语句中索引列上对字段表达式的操作，包括运算、使用函数、；

		对于多列索引，不是使用的第一部分，则不会使用索引；

		like查询以通配符%和_开头作查询时，MySQL不会使用索引。
		条件中有or，即使其中有条件带索引也不会使用(这也是为什么尽量少用or的原因)；

		如果列类型是字符串，那一定要在条件中将数据使用引号引用起来,否则不使用索引；
		如果mysql估计使用全表扫描要比使用索引快,则不使用索引；



·存储引擎：
http://www.cnblogs.com/luyucheng/p/6306512.html

	··分类：InnoDB，MyISAM，Memory，Merge，Archive，Federated，CSV，Blackhole等；

	··INNODB：存储限制可达64TB；
			InnoDB 是事务型数据库的首选引擎，支持事务处理（ACID）；支持外键约束；支持表锁和行锁，默认为行级锁；
			基于聚簇索引建立，聚簇索引对主键查询有很高的性能。
			
			适合在以下几种情况下使用：
					1.更新和查询都相当的频繁，多重并发;
					2.要求事务，或者可靠性要求比较高;
					3.外键约束，MySQL支持外键的存储引擎只有InnoDB;
					一般来说，如果需要事务支持，并且有较高的并发读取频率，InnoDB是不错的选择。


	··MyISAM：存储限制可达256TB；
			MyISAM提供高速存储以及全文索引（FULLTEXT），但不支持事务；不支持外键；表级锁，不能在表损坏后恢复数据；
			可达到的需求：稳定性，扩展性和高可用性；
			MyISAM 引擎的表在大量高并发的读写下会经常出现表损坏的情况；
			MyISAM 支持空间索引，可以用于地理数据存储；

			适合在以下几种情况下使用：
				1.对于count( )查询来说MyISAM更有优势；
				2.MyISAM 引擎的表的查询、更新、插入的效率要比InnoDB高。

	··NDBCluster
			1.特性
			　　分布式：分布式存储引擎，可以由多个NDBCluster存储引擎组成集群分别存放整体数据的一部分
			　　支持事务：和Innodb一样，支持事务
			　　可与mysqld不在一台主机：可以和mysqld分开存在于独立的主机上，然后通过网络和mysqld通信交互
			　　内存需求量巨大：新版本索引以及被索引的数据必须存放在内存中，老版本所有数据和索引必须存在与内存中

			2.适用场景
			　　具有非常高的并发需求
			　　对单个请求的响应并不是非常的critical
			　　查询简单，过滤条件较为固定，每次请求数据量较少，又不希望自己进行水平Sharding

			3.最佳实践
			　　尽可能让查询简单，避免数据的跨节点传输
			　　尽可能满足SQL节点的计算性能，大一点的集群SQL节点会明显多余Data节点
			　　在各节点之间尽可能使用万兆网络环境互联，以减少数据在网络层传输过程中的延时

			4.它的限制
			    4.1 不支持临时表。
			    4.2 不支持基于TEXT and BLOB 字段的索引。
			    4.3 不支持FULLTEXT indexes。


··InnoDB和MyISAM的区别？

	··MEMORY：
			有存储限制；支持索引；支持表锁；
			数据保存在内存中，拥有极高的插入、更新和查询效率。但是不稳定，重启以后数据都会丢失。
			不支持事务。支持表级锁，因此并发写入的性能较低。
			支持HASH索引和B-Tree索引，默认使用HASH索引。

	··修改存储引擎方法：
		1.修改配置文件；

		2.通过SQL命令；
		CREATE TABLE 名称（
			……
		）ENGINE = INNODB；
		OR
		ALTER TABLE tp1 ENGINE = INNODB;


·存储过程：
	··概念：是一个预编译的代码块，执行效率高。就像一个方法实现了一个功能（比如增删改查功能），然后给这个方法定义一个名字，需要调用这个功能时就可以调用它了。
	··优点：
			SQL语句预编译过了，所以运运算速度比较快；
			他在服务器端运行，减少客户端压力；
			允许模块化，创建一次，可调用多次；
			减少网络流量，客户端调用存储过程只需要传送名称和参数即可，与传输SQL语句相比数据量更少；
			增强使用的安全性，可以对存储过程进行权限控制；

	··缺点：
			调试麻烦：没有像开发程序那样简单；
			可移植性差：存储过程依赖于具体数据库；

	··实现细节：
			CREATE PROCEDURE 名称（参数）……
			参数：
			IN：值在调用时指定；
			OUT：值可以被改变并返回；
			INOUT：调用时指定，并可以改变和返回；
			调用：CALL



·约束：主键约束（primary key）、外键约束（foreign key ……references……）、非空约束(not null）、唯一性约束（UNIQUE）、默认约束（default 默认值）、自增（AUTO_INCREMENT）。


·MySQL性能优化：
		··优化查询：
					使用索引；
					优化SQL语句；
					优化数据库结构；
					硬件优化；
					应用优化；
		··数据库突然有个大访问量，怎么优化？
					上面的优化查询；
					主从复制，读写分离，负载均衡；
	


·锁：	
	··如何解决并发问题？/如何并发访问数据库？		加锁。乐观锁和悲观锁；
	··锁有2种机制：乐观锁和悲观锁；
	··数据库中的锁有哪几种？答：独占锁、排他锁以及更新锁。

	··2种基本的锁类型：
			···共享锁【S锁】
			同一时间段内，多个用户可以读取同一个资源。
			又称读锁，若事务T对数据A加上S锁，则事务T可以读A但不能修改A，其他事务只能再对A加S锁，而不能加X锁，直到T释放A上的S锁。这保证了其他事务可以读A，但在T释放A上的S锁之前不能对A做任何修改。

			···排他锁【X锁】
			任何时候只能有一个用户写入资源。
			又称写锁。若事务T对数据A加上X锁，事务T可以读A也可以修改A，其他事务不能再对A加任何锁，直到T释放A上的锁。这保证了其他事务在T释放A上的锁之前不能再读取和修改A。	

	··MySQL锁的3种粒度（级别）：
		表级锁：开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高，并发度最低；
		行级锁：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高；    
		页面锁：开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般。
		适用：从锁的角度来说，表级锁更适合于以查询为主，只有少量按索引条件更新数据的应用，如Web应用；而行级锁则更适合于有大量按索引条件并发更新少量不同数据，同时又有并发查询的应用，如一些在线事务处理（OLTP）系统。



·死锁：
	【MySQL中，在InnoDB中，除单个SQL组成的事务外，锁是逐步获得的，当两个事务都需要获得对方持有的排他锁才能继续完成事务，这种循环锁等待就是典型的死锁。】
	··死锁必要条件：4个
	··预防死锁：破坏4个之一

	··封锁协议（Locking Protocol）：
		 在运用X锁和S锁对数据对象加锁时，还需要约定一些规则，例如何时申请X锁或S锁、持锁时间、何时释放等。对封锁方式规定不同的规则，就形成了各种不同的封锁协议。不同的封锁协议，在不同的程度上为并发操作的正确调度提供一定的保证。

		一级封锁协议：事物T在修改数据R前必须对其加x锁直至结束
		二级：事物T在修改数据R前必须对其加x锁直至结束释放X，读取前先加S锁读完释放S
		三级：事物T在修改数据R前必须对其加x锁直至结束释放X，读取前先加S锁事务结束释放S

·MySQL的优点：
	1.开源免费；
	2.使用简单，安装小巧，可移植行高；
	3.使用标准的 SQL 数据语言形式；
	4.支持大型的数据库。可以处理拥有上千万条记录的大型数据库；
	5.MySQL 运行速度很快。




·mysql数据库名称规范：
	
	··数据库名使用小写英文以及下划线组成，尽量说明是那个应用或者系统在使用的；

	··数据表名使用小写英文以及下划线组成，尽量说明是那个应用或者系统在使用的；

	··字段名称使用单词组合完成，首字母小写，后面单词的首字母大写,最好是带表名前缀；表与表之间的相关联字段要用统一名称；

	··字段类型规范：用尽量少的存储空间来存 数一个字段的数据；




·MySQL 、oracle和 SQL Server 用法上的区别：

	Sqlserver、mysql、oracle三者是目前市场占有率最高的关系型数据库，网上总结的这3个数据库总体的特点如下：

	··Oracle：最贵，功能最多，安装最不方便，Oracle环境里的其他相关组件最多，支持平台数据量一般，使用中等方便，开发中等方便，不开源，速度最慢、最安全。
	··Microsoft SQL Server：中等贵，功能最少，安装中等方便，sqlserver环境里的其他相关组件最少，支持平台最少，使用最方便，开发最方便，运维最方便，不开源，速度中等，一般安全。
	··Mysql：免费，功能中等，安装最方便，mysql环境里的其他相关组件数量中等，支持平台最多，使用最不方便，开发最不方便，运维最不方便，有开源版本，速度最快，最不安全。


·其他：
	··acl：访问控制列表，是与对象关联的权限列表。这个列表是mysql服务器安全模型的基础。ACL缓存在内存中，当用户认证或者运行命令时，mysql会按照预定的顺序检查acl的认证信息和权限。

	··MySQL Replication主从复制：MySQL复制是指从一个MySQL主服务器(master)将数据拷贝到另一台或多台MySQL从服务器(slaves)的过程，将主数据库的DDL和DML操作通过二进制日志传到复制服务器上，然后在从服务器上对这些日志重新执行，从而使得主从服务器的数据保持同步。

	··所谓SQL注入，就是通过"构建一种特殊的SQL命令"输入到"Web表单"或"域名"或"页面请求的查询字符串"来提交，最终达到欺骗服务器执行恶意的SQL命令。我们永远不要信任用户的输入，我们必须认定用户输入的数据都是不安全的，我们都需要对用户输入的数据进行过滤处理。


