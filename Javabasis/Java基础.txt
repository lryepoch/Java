
基础语法：
------------------------
·Java命名格式：
    包名：一律采用小写。

    类名：首字母大写 、其余组成词依次首字母大写。

    方法名：首字母小写、其余组成词首字母大写。

    属性（变量名）：
    个人理解 分两种情况：1、变量名由多单词组成时，第一个单词的首字母小写，其后单词的首字母大写，俗称骆驼式命名法（也称驼峰命名法），如 myAge；
                       2、变量命名时，尽量简短且能清楚的表达变量的作用，做到见名知意。如：定义变量名 stuName 保存“学生姓名”信息；

       a：全局变量：大写规范。

       b：局部变量：小写规范。

       c：属性、常量：大写规范。




·区分Java中的关键字和Java标识符：
  ··关键字：
    1.Java 语言中有一些具有特殊用途的词被称为关键字。关键字对Java的编译器有着特殊的意义，在程序中应用时一定要慎重哦！！
    最常用的就有基本数据类型，try……catch……
    2.Java关键字是区分大小写的哦！所以void是关键字，但Void就不是了~~
      这个关键字常见的坑：
      true、false、null都不是关键字；
      goto、const是保留的关键字；


  ··标识符就是用于给 Java 程序中类、变量、方法等命名的符号。

    使用标识符时，需要遵守几条规则：
     1.标识符可以由字母、数字、下划线（_）、美元符（$）组成，但不能包含@、%、空格等其它特殊字符，不能以数字开头。譬如：123name就是不合法滴；
     2.标识符不能是Java关键字和保留字（Java预留的关键字，以后的升级版本中有可能作为关键字），但可以包含关键字和保留字。如：不可以使用void作为标识符，但是Myvoid可以；
     3.标识符是严格区分大小写的。所以涅，一定要分清楚imooc和IMooc是两个不同的标识符哦！
     4.标识符的命名最好能反映出其作用，做到见名知意。

     


对象和类：
-----------------------
·内部类：

	··对于外部类来说，只有两种修饰，public和默认（default）。因为外部类放在包中只有两种可能：包可见和包不可见。

	··对于内部类来说，可以有所有的修饰，因为内部类放在外部类中，与成员变量的地位一致，所以有四种可能。

		1.为什么使用内部类?
		使用内部类最吸引人的原因是：每个内部类都能独立地继承一个（接口的）实现，所以无论外围类是否已经继承了某个（接口的）实现，对于内部类都没有影响。

		使用内部类最大的优点就在于它能够非常好的解决多重继承的问题,使用内部类还能够为我们带来如下特性:
			>内部类可以用多个实例，每个实例都有自己的状态信息，并且与其他外围对象的信息相互独立 。
			>在单个外围类中，可以让多个内部类以不同的方式实现同一个接口，或者继承同一个类。
			>创建内部类对象的时刻并不依赖于外围类对象的创建。
			>内部类并没有令人迷惑的“is-a”关系，他就是一个独立的实体。
			>内部类提供了更好的封装，除了该外围类，其他类都不能访问。
			>定义内部类的好处是外部类可以访问内部类的所有方法和属性，包括私有方法和私有属性。


		2.内部类分类:

		(一).成员内部类:
			public class Outer{
			        private int age = 99;
			        String name = "Coco";
			        public class Inner{
			            String name = "Jayden";
			            public void show(){
			                System.out.println(Outer.this.name);		访问外部类的成员变量
			                System.out.println(name);
			                System.out.println(age);
			            }
			        }
			        public Inner getInnerClass(){
			            return new Inner();
			        }
			        public static void main(String[] args){
			            Outer o = new Outer();
			            Inner in = o.new Inner();
			            in.show();
			        }
			    }
				1.Inner 类定义在 Outer 类的内部，相当于 Outer 类的一个成员变量的位置，Inner 类可以使用任意访问控制符，如 public 、 protected 、 private 等
				2.Inner 类中定义的 show() 方法可以直接访问 Outer 类中的数据，而不受访问控制符的影响，如直接访问 Outer 类中的私有属性age。

				3.定义了成员内部类后，必须使用外部类对象来创建内部类对象，而不能直接去 new 一个内部类对象，即：内部类 对象名 = 外部类对象.new 内部类( );
				4.编译上面的程序后，会发现产生了两个 .class 文件: Outer.class,Outer$Inner.class{}

				5.成员内部类中不能存在任何 static 的变量和方法,可以定义常量:
					(1).因为非静态内部类是要依赖于外部类的实例,而静态变量和方法是不依赖于对象的,仅与类相关；简而言之:在加载静态域时,根本没有外部类,所以在非静态内部类中不能定义静态域或方法,编译不通过;非静态内部类的作用域是实例级别；
					(2).常量是在编译期就确定的,放到所谓的常量池了；

				★★友情提示:
				1.外部类是不能直接使用内部类的成员和方法的，可先创建内部类的对象，然后通过内部类的对象来访问其成员变量和方法;
				2.如果外部类和内部类具有相同的成员变量或方法，内部类默认访问自己的成员变量或方法，如果要访问外部类的成员变量，
				可以使用 this 关键字,如:Outer.this.name


		(二).静态内部类: 是 static 修饰的内部类：
				
				静态内部类才可以声明静态方法；静态方法不可以使用非静态变量；

				1.静态内部类不能直接访问外部类的非静态成员，但可以通过 new 外部类().成员 的方式访问 ；

				2.如果外部类的静态成员与内部类的成员名称相同，可通过“类名.静态成员”访问外部类的静态成员；
				如果外部类的静态成员与内部类的成员名称不相同，则可通过“成员名”直接调用外部类的静态成员；

				3.创建静态内部类的对象时，不需要外部类的对象，可以直接创建 内部类 对象名 = new 内部类()；

				public class Outer{
				            private int age = 99;
				            static String name = "Coco";
				            public static class Inner{
				                String name = "Jayden";
				                public void show(){
				                    System.out.println(Outer.name);			访问外部类的静态成员
				                    System.out.println(name);                  
				                }
				            }
				            public static void main(String[] args){
				                Inner i = new Inner();			可以直接创建 内部类 对象名 = new 内部类()；
				                i.show();
				            }
				        }

					内部类其实和类的属性没什么区别：
						public class Enclosingone {
						    //非静态内部类
						    public class InsideOne {}
						    //静态内部类
						    public static class InsideTwo{}
						}
						 
						class Mytest02{
						    public static void main(String args []){
						        Enclosingone.InsideOne obj1 = new Enclosingone().new InsideOne();//非静态内部类对象
						        Enclosingone.InsideTwo obj2 = new Enclosingone.InsideTwo();//静态内部类对象
						    }
						}


		(三).方法内部类：其作用域仅限于方法内，方法外部无法访问该内部类
			(1).局部内部类就像是方法里面的一个局部变量一样，是不能有 public、protected、private 以及 static 修饰符的

			(2).只能访问方法中定义的 final 类型的局部变量,因为:
			当方法被调用运行完毕之后，局部变量就已消亡了。但内部类对象可能还存在，直到没有被引用时才会消亡。此时就会出现一种情况，就是内部类要访问一个不存在的局部变量；	==>使用final修饰符不仅会保持对象的引用不会改变,而且编译器还会持续维护这个对象在回调方法中的生命周期。
			局部内部类并不是直接调用方法传进来的参数，而是内部类将传进来的参数通过自己的构造器备份到了自己的内部，自己内部的方法调用的实际是自己的属性而不是外部类方法的参数；防止被篡改数据,而导致内部类得到的值不一致。

	         /*
			使用的形参为何要为 final???
			在内部类中的属性和外部方法的参数两者从外表上看是同一个东西，但实际上却不是，所以他们两者是可以任意变化的，也就是说在内部类中我对属性的改变并不会影响到外部的形参，而然这从程序员的角度来看这是不可行的，毕竟站在程序的角度来看这两个根本就是同一个，如果内部类该变了，而外部方法的形参却没有改变这是难以理解和不可接受的，所以为了保持参数的一致性，就规定使用 final 来避免形参的不改变；
	         */

		        public class Outer{
		            public void Show(){
		                final int a = 25;
		                int b = 13;
		                class Inner{
		                    int c = 2;
		                    public void print(){
		                        System.out.println("访问外部类:" + a);
		                        System.out.println("访问内部类:" + c);
		                    }
		                }
		                Inner i = new Inner();
		                i.print();
		            }
		            public static void main(String[] args){
		                Outer o = new Outer();
		                o.show();
		            }
		        }    
			(3).注意:在JDK8版本之中,方法内部类中调用方法中的局部变量,可以不需要修饰为 final,匿名内部类也是一样的，主要是JDK8之后增加了 Effectively final 功能
			http://docs.oracle.com/javase/tutorial/java/javaOO/localclasses.html
			反编译jdk8编译之后的class文件,发现内部类引用外部的局部变量都是 final 修饰的


		(四).匿名内部类:
				(1).匿名内部类是直接使用 new 来生成一个对象的引用;
				(2).对于匿名内部类的使用它是存在一个缺陷的，就是它仅能被使用一次，创建匿名内部类时它会立即创建一个该类的实例，该类的定义会立即消失，所以匿名内部类是不能够被重复使用;
				(3).使用匿名内部类时，我们必须是继承一个类或者实现一个接口，但是两者不可兼得，同时也只能继承一个类或者实现一个接口;
				(4).匿名内部类中是不能定义构造函数的,  匿名内部类中不能存在任何的     静态成员变量和    静态方法;
				(5).匿名内部类不能是抽象的,它必须要实现继承的类或者实现的接口的所有抽象方法；
				(6).匿名内部类初始化：使用构造代码块！利用构造代码块能够达到为匿名内部类创建一个构造器的效果；

				匿名内部类用法与局部内部类不一致，首先从定义上就不一样，匿名类用在任何允许存在表达式的地方，而局部内部类用于在任何允许出现局部变量的地方出现。还有更重要的是匿名类只能使用一次，而局部类则可以在自己的定义域内多次使用。成员内部类位于外部类内部，可以直接调用外部类的所有方法（静态方法和非静态方法）

				匿名内部类是什么？
				关于 “Java 内部类 ” 和 "Java 继承、多态与类的复用" 的更详细的阐述，请查看我的两篇博文 “http://blog.csdn.net/justloveyou_/article/details/53245561” 和 
				“http://blog.csdn.net/justloveyou_/article/details/52798666”。 

		  public class OuterClass {
		            public InnerClass getInnerClass(final int num，String str2){
		                return new InnerClass(){
				                    int number = num + 3;
				                    public int getNumber(){
				                        return number;
				                    }
		                    };        /* 注意：分号不能省 */
		            }
		            public static void main(String[] args) {
		                OuterClass out = new OuterClass();
		                InnerClass inner = out.getInnerClass(2, "chenssy");
		                System.out.println(inner.getNumber());
		            }
		        }
		        interface InnerClass {			//接口
		            int getNumber();				//接口方法
             }         

		所谓的匿名内部类就是一个没有显式的名字的内部类，在实际开发中，此种内部类用的是非常多的。
		本质：匿名内部类会隐式的继承一个类或者实现一个接口，或者说，匿名内部类是一个继承了该类或者实现了该接口的子类匿名对象。
		格式：
				new 类名/接口/抽象类(){
					//实现的是它的实现类
				}

		public class Outer{
			public void method(){
				new inner(){
					public void info(){
						sout("helloworld");
					}
				}.info();
			}
			public static void main(String[] args){
				Outer outer = new Outer();
				outer.method();
			}
		}

		interface inner{
			public void info();
		}

		总结：通过程序看出，实际上我们的inner是一个接口，本身接口是不能直接new的，但是呢却又发现我们在new的时候，inner这个接口后面带了一对花括号，那么这个就表示实际上我现在new的是这个接口的实现类。但是发现，这个实现类是没有名字的。




·关于构造方法：

  ··构造方法也是类的方法，可以在创建对象时为成员变量赋值；
  ··构造方法可以进行重载，但是参数列表必须不相同，不以返回值和访问级别进行区分；
  ··构造方法没有返回值；
  ··构造方法一定要与定义为public的类同名；
  ··由于构造器的名字必须与类名相同，而匿名类没有类名，所以匿名类不能有构造器。
  ··如果Child是class，且只有一个有参数的构造函数，那么必然会调用Parent中相同参数的构造函数。错的！因为可以调用父类无参的构造函数，子类的有参构造函数和是否调用父类的有参数的构造函数无必然联系。

  ··其实，普通的类方法是可以和类名同名的，和构造方法唯一的区分就是，构造方法没有返回值。
  ··不显示提供构造方法时，Java才提供一个默认构造方法，当我们显示的提供一个无参或带参的构造方法时，Java都不会再提供构造方法了。java的构造函数在创建对象时，就会自动调用它。
  ··构造函数不能被继承，构造方法只能被显式或隐式的调用。

  ··问题： java中子类继承父类时是否继承构造函数呢？
  ﻿﻿
            java继承中对构造函数是不继承的。

            以下是例子：

             public class FatherClass {
             public FatherClass() {
                   System.out.println(100);
             }

             public FatherClass(int age) {
                  System.out.println(age);
             }

            }

            public class SonClass extends FatherClass{

                    public SonClass() {
                     }
                    public SonClass(int c) {
                             System.out.println(1234);
                    }
               
             public static void main(String[] args) {

              FatherClass f = new FatherClass(28);
              SonClass s = new SonClass(66);
             
             }
            }

            编译后执行结果如下是什么呢？
            
            分析：
            1. FatherClass f = new FatherClass(28);这句没有必要解释

            2.SonClass s = new SonClass(66);执行这句时，调用

             public SonClass(int c) {
                             System.out.println(1234);
                    }
            

            在这个构造函数中，等价于

             public SonClass(int c) {

                            super();//必须是第1行，否则不能编译
                             System.out.println(1234);
                    }

            所以结果是    100
                                     1234

            3.如果子类构造函数是这样写的

            public SonClass(int c) {

                            super(22);//必须是第1行，否则不能编译

                           //显示调用了super后，系统就不再调用super();
                             System.out.println(1234);
                    }

            执行结果是   22
                                     1234

            总结1：构造函数不能继承，只是调用而已。

            如果父类没有无参构造函数

            创建子类时，不能编译，除非在构造函数代码体中第一行，必须是第一行显示调用父类有参构造函数

            如下：

            SonClass (){

                super(777);//显示调用父类有参构造函数

                System.out.println(66);

            }
            
            如果不显示调用父类有参构造函数，系统会默认调用父类无参构造函数super();

            但是父类中没有无参构造函数，那它不是不能调用了。所以编译就无法通过了。

            总结2：创建有参构造函数后，系统就不再有默认无参构造函数。

            如果没有任何构造函数，系统会默认有一个无参构造函数。




·父类和子类的关系：

	··如果子类构造器没有显示地调用超类的构造器，则将自动地调用超类默认（没有参数）的构造器。如果超类没有不带参数的构造器，并且在子类的构造器中没有显示地调用超类的其他构造器，则Java编译器将报告错误。使用super调用构造器的语句必须是子类构造器的第一条语句。

	··调用构造方法时，调用父类的构造方法就用super，调用本类的构造方法就用this。

	··在一个子类被创建的时候，首先会在内存中创建一个父类对象，然后在父类对象外部放上子类独有的属性，两者合起来形成一个子类的对象。所以所谓的继承使子类拥有父类所有的属性和方法其实可以这样理解，子类对象确实拥有父类对象中所有的属性和方法，但是父类对象中的私有属性和方法，子类是无法访问到的，只是拥有，但不能使用。就像有些东西你可能拥有，但是你并不能使用。所以子类对象是绝对大于父类对象的，所谓的子类对象只能继承父类非私有的属性及方法的说法是错误的。可以继承，只是无法访问到而已。？？？？？？？？？？？？？

	··子类构造函数调用父类构造函数用super；子类重写父类方法后，若想调用父类中被重写的方法，用super；未被重写的方法可以直接调用。
		子类也可以new一个父类对象，然后调用父类方法，并不一定要使用super方法。

	··JAVA子类重写继承的方法时,不可以降低方法的访问权限，子类继承父类的访问修饰符要比父类的更大，也就是更加开放，假如我父类是protected修饰的，其子类只能是protected或者public，绝对不能是friendly(默认的访问范围)或者private，当然使用private就不是继承了。还要注意的是，继承当中子类抛出的异常必须是父类抛出的异常的子异常，或者子类抛出的异常要比父类抛出的异常要少。

	··子类继承父类，子类拥有了父类的所有属性和方法。
	　　程序验证，父类的私有属性和方法子类是无法直接访问的。当然私有属性可以通知过public修饰的getter和setter方法访问到的，但是私有方法不行。
	　　假设：子类不能够继承父类的私有属性和方法
	　　那么：分析道内存后，会发现，当一个子类被实例化的时候，默认会先调用父类的构造方法对父类进行初始化，即在内存中创建一个父类对象回，然后再父类对象的外部放上子类独有的属性，两者合起来成为一个子类的对象。
	　　所以：子类继承了父类的所有属性和方法或子类拥有父类的所有属性和方法是对的，答只不过父类的私有属性和方法，子类是无法直接访问到的。即只是拥有，但是无法使用。




·java向上转型和向下转型【包括类和接口的转型】https://jingyan.baidu.com/article/eae07827bcbbab1fec54853e.html

	··向上转型：指子类对象转换为父类对象。
		1.父类 对象= new 子类，无需强转，丢弃子类的方法。
		2.当调用对象的方法时，如果子类有覆盖方法，就听从子类的方法。
		3.如果调用父类没有的方法，编译会出错。要想调用的话需要先通过向下转型，SON son=(SON)base强制转换，然后用son.methodB()调用就可以了。
		

	··向下转型：	父类引用的对象转换为子类类型。
		1.子类 = （子类）父类对象，要强转。
		2.对象调用子类覆盖的方法，听子类的。
		3.当调用子类没有的方法，则听从父类的方法。

		如果 父类 对象= new 父类； 子类 =（子类）父类；这种情况，编译没有错，运行的时候会提示ClassCastException（类转换异常）错误，
		如果 父类 对象= new 子类；子类 =（子类）父类；这种情况，编译和运行都没有错。





变量类型：
-------------------------
·成员变量和局部变量的区别：
	··成员变量是独立于方法外的变量，局部变量是类的方法中的变量
		1.成员变量：包括实例变量和类变量，用static修饰的是类变量，不用static修饰的是实例变量，所有类的成员变量可以通过this来引用。
		2.局部变量：包括形参，方法局部变量，代码块局部变量，存在于方法的参数列表和方法定义中以及代码块中。

	··成员变量可以被public，protect，private，static等修饰符修饰，而局部变量不能被访问控制修饰符及static修饰；两者都可以定义成final型。

	··成员变量存储在堆，局部变量存储在栈。成员变量的作用域在整个类内部都是可见的，所有成员方法都可以使用它。如果访问权限允许，还可以在类的外部使用成员变量。局部变量的作用域仅限于定义它的方法，在该方法的外部无法访问它。

	··类的成员变量，如果是实例成员变量，它和对象的生存期相同。而静态成员变量的生存期是整个程序运行期。局部变量的生存周期与方法的执行期相同。当方法执行到定义局部变量的语句时，局部变量被创建；执行到它所在的作用域的最后一条语句时，局部变量被销毁。

	··成员变量在类加载或实例被创建时，系统自动分配内存空间，并在分配空间后自动为成员变量指定初始化值，初始化值为默认值，基本类型的默认值为0，复合类型的默认值为null（被final修饰且没有static的必须显式赋值）。局部变量在定义后必须经过显式初始化后才能使用，系统不会为局部变量执行初始化。

	··局部变量可以和成员变量同名，且在使用时，局部变量具有更高的优先级，直接使用同名访问，访问的是局部变量，如需要访问成员变量可以用this。




·Java中成员变量的隐藏：

	··Java文档中对隐藏域的定义：

	  在一个类中，子类中的成员变量如果和父类中的成员变量同名，那么即使他们类型不一样，只要名字一样。父类中的成员变量都会被隐藏。在子类中，父类的成员变量不能被简单的用引用来访问。而是，必须从父类的引用获得父类被隐藏的成员变量，一般来说，我们不推荐隐藏成员变量，因为这样会使代码变得难以阅读。

	  其实，简单来说，就是子类不会去重写覆盖父类的成员变量，所以成员变量的访问不能像方法一样使用多态去访问。

	··如何访问被隐藏的成员变量？

	其实，通过前面的例子，和刚刚关于成员变量的介绍，其实你已经知道了如何访问被隐藏的成员变量。 就是使用父类的引用来访问成员变量，如Super c2 = new Sub(); System.out.println(" c2.s : " + c2.s);。或者使用System.out.println(((Super)c1).s);。





修饰符：
-------------------------
·访问控制符：
	··public：可以被所有其他类所访问
		1.在一个文件中,有且只能有一个public类,该类与文件同名
		2.在一个文件中,可以不存在public类
		3.在一个文件中,可以不存在与文件同名的类(前提是此文件中没有public类)

	··protected：自身、子类及同一个包中类可以访问；
	··default：同一包中的类可以访问，声明时没有加修饰符，认为是friendly。default不能修饰变量；
	··private：只能被自己访问和修改；




运算符：
-------------------------
·Java中的逻辑运算符?
  
	位运算主要包括按位与(&)、按位或(|)、按位异或(^)、取反(~)、左移(<<)、右移(>>)这几种，其中除了取反(~)以外，其他的都是二目运算符，即要求运算符左右两侧均有一个运算量。

	&&：逻辑与，短路与
	!：逻辑非
	||：逻辑或，短路或
	^：逻辑异或

	简述逻辑操作(&,|,^)与条件操作(&&,||)的区别？

	答：区别主要有两点：a.条件操作只能操作布尔型的,而逻辑操作不仅可以操作布尔型,而且可以操作数值型；
						  b.逻辑操作不会产生短路。

	<<(向左位移)：针对二进制，转换成二进制后向左移动3位，后面用0补齐；
	            public static void main(String[] args) {
	                     System.out.println("2<<3运算的结果是 :"+(2<<3));
	                     //打印的结果是:   2<<3
	                     //运算的结果是 :16
	                 }

	>>(向右位移)：针对二进制，转换成二进制后向右移动3位，右移后左边的空位被填充为符号位；
	            public static void main(String[] args) {
	                     System.out.println("2>>3运算的结果是 :"+(2>>3));
	                     //打印的结果是:   2>>3运算的结果是 :0
	                 }

	>>>(无符号右移)：无符号右移，忽略符号位，左边的空位都以0补齐；
	  10进制转二进制的时候，因为二进制数一般分8位、 16位、32位以及64位表示一个十进制数，所以在转换过程中，最高位会补零；
	  在计算机中负数采用二进制的补码表示，10进制转为二进制得到的是原码。


	>>>与>>唯一的不同是它无论原来的最左边是什么数，统统都用0填充。
	  eg：byte是8位的，-1表示为byte型是11111111(补码表示法），b>>>4就是无符号右移4位，即00001111，这样结果就是15。

	没有<<<：因为<<后右边总是补0。




Java String类：
------------------------
·关于String类：
	··它是final类型的，不能继承和修改这个类。str=“tesk ok”，其实是隐含的让Java生成一个新的String对象，那么就与原来的“Hello”没有任何关
	系，当函数结束，str作用结束，所以输出的还是“Hello”。 char ch[] 是传递引用，修改了原内容。对于图片"Java只有值传递"中的解答，有要注意的点：
	1.Java只有值传递，所谓的引用传递其实是对象地址的值传递。
	2.String = "test OK" 并不是在栈中开辟空间，而是在堆中的常量池中开辟的。

	··putchar只能输出一个字符，puts只能输出一个串。多型就是数据元素的类型不确定。
		字符串常量:以双引号引起来的数据，如"he123" "a"。
		字符常量:以单引号引起的一个字符，如'a' '\n'。
		字符串的子串，就是字符串中的某一个连续片段。截取一个字符串长度需要一个起始位置和结束位置。n(n+1）/2   + 1 （+1包括空串）

	··空字符串和null的区别：null代表堆内存中根本没有这个东西，而空字符串也是字符串，是有内存空间的。

	··String s=null;没有给s开辟任何空间，当执行length()方法时候，因为没有具体指向的内存空间，所以报出NullPointerException。出现异常主要是因为执行了s.length()这句话.

	··String(byte[] bytes, String charsetName)
      通过使用指定的 charset 解码指定的 byte 数组，构造一个新的String。
      byte[]	getBytes(String charsetName)
      使用指定的字符集将此String编码为 byte 序列，并将结果存储到一个新的 byte 数组中。

    ··String x="fmn";  “fmn”是在常量池里的不可变对象。
		x.toUpperCase();   在堆中new一个"FMN"对象，但无任何引用指向它。
		String y=x.replace('f','F'); 在堆中 new一个"Fmn"对象，y指向它。
		y=y+"wxy"; 在堆中重新new一个"Fmnwxy"对象， 修改y指向，现在y指向它。

	··只有在String类中，equals（）方法返回的才是对象的内容的比较。

	··String str1="hello";    这样创建字符串是存在于常量池中
		String str2=new String("hello");    str2存在于堆中

		==是验证两个对象是否是一个（内存地址是否相同）
		用+拼接字符串时会创建一个新对象再返回。

	··char[] ch = new char[3];//默认空格
		int[] i = new int[2];//默认0
		String[] strings = new String[2];//默认null

	··String s = "hello";
		String t = "hello";
		char[] c = {'h','e','1','1','o'};
		System.out.println(s.equals (t)); //true  s和t指向内存常量区的同一个字符串;
		System.out.println(t.equals (c));//false 一个返回字符串，一个返回对象;
		System.out.println(s==t);// true  s和t指向内存常量区的同一个字符串;
		System.out.println(t.equals (new String ("hello")));//true equal用于比较两个对象的值是否相同,和内存地址无关

	··String str1 = "hello";这里的str1指的是方法区的字符串常量池中的“hello”，编译时期就知道的； String str2 = "he" + new String("llo");这里的str2必须在运行时才知道str2是什么，所以它是指向的是堆里定义的字符串“hello”，所以这两个引用是不一样的。
	如果用str1.equal(str2)，那么返回的是True；因为两个字符串的内容一样。




·String/StringBuilder/StringBuffer区别：

	首先，主要区别是运算速度和线程安全。
	1.运算速度：StringBuilder>StringBuffer>String;
	(Java中对String对象进行的操作实际上是一个不断创建新的对象并且将旧的对象回收的一个过程，所以执行速度很慢。而StringBuilder和StringBuffer的
		对象是变量，对变量进行操作就是直接对该对象进行更改，而不进行创建和回收的操作，所以速度要比String快很多。)

	2.StringBuilder线程不安全，StringBuffer线程安全。
	如果一个StringBuffer对象在字符串缓冲区被多个线程使用时，StringBuffer中很多方法可以带有synchronized关键字，所以可以保证线程是安全的，但
	StringBuilder的方法则没有该关键字，所以不能保证线程安全，有可能会出现一些错误的操作。所以如果要进行的操作是多线程的，那么就要使用StringBuffer，
	但是在单线程的情况下，还是建议使用速度比较快的StringBuilder。

	3.总结一下：
	　　String：适用于少量的字符串操作的情况；
	　　StringBuilder：适用于单线程下在字符缓冲区进行大量操作的情况；
	　　StringBuffer：适用多线程下在字符缓冲区进行大量操作的情况；




Java数组：
--------------------------
	··写一下个人理解的数组声明为什么这么写？
	1.为什么左边不用标大小，而右边需要标大小？ 
	首先数组一个对象，它不属于任何类，由jvm在运行期间在堆中创建并继承object，同时添加length属性。由于数组对象所占的内存在堆上，所以在声明时应明确告诉jvm自己所占的大小，方便分配，又因为数组对象的引用在栈中，所以声明时左边就无需标大小，之所以写成2个括号，就是为了表明这个引用指向堆中的二维数组。

	2.为什么右边数组可以只声明几行，无需声明每行的大小？ 
	大概jvm在运行期间会根据行数分配对应的可扩展空间，方便每一行进行扩充。其实又可以按c语言那样理解，行其实又是一种引用，行首地址又代表一个一维数组。

	··Java中数组是对象，不是基本数据类型（原生类），大小不可变且连续存储，因为是对象所以存在堆中。
	··数组类是在运行的过程中创建的 
	··Java中数组内容存储在连续的堆内存中，数组名（引用） 存储在栈内存中指向堆内存中的内容。

	··在java 中，声明一个数组时，不能直接限定数组长度，只有在创建实例化对象时，才能对给定数组长度。定义一个变量时，仅仅定义了一个变量，这个引用变量还未指向任何有效的内存 。

	··java中的数组自带length属性，例如：假设有个二维数组a[][]；  a.length就是行数，a[0].length就是列数啦；

	··二维数组：在定义二维数组时也可以只指定行的个数，然后再为每一行分别指定列的个数。如果每行的列数不同，则创建的是不规则的二维数组。

	··真数组： 数组元素在内存中是一个接着一个线性存放的，通过第一个元素就能访问随后的元素，避免了数据覆盖的可能性，和数据类型覆盖并没有关系。


	··使用Arrays类操作Java中的数组：
	Arrays类是Java中提供的一个工具类，在java.util包中。该类中包含了一些方法用来直接操作数组，比如可直接实现数组的排序、搜索等。
	Arrays中常用的方法：
	  1、排序
	  语法：Arrays.sort(数组名);
	  可以使用sort( )方法实现对数组的排序，只要将数组名放在sort( )方法的括号中，就可以完成对该数组的排序（按升序排列）。

	  2、将数组转换为字符串
	  语法：Arrays.toString(数组名);
	  可以使用 toString( )方法将一个数组转换成字符串，该方法按顺序把多个数组元素连接在一起，多个元素之间使用逗号和空格隔开。

	  Arrays.asList()方法返回的列表是Arrays.ArrayList类型的，并不是java.util.ArrayList；SimpleDateFormat是线程不安全的。





