
--------------
AQS详解：
	AbstractQuenedSynchronizer抽象的队列式同步器。是除了java自带的synchronized关键字之外的锁机制。这是实现Lock的基础。

	AQS有一个State标记位，值为1时表示有线程占用，其他线程需要进入到同步队列等待。同步队列是一个双向链表。
	当获得锁的线程需要等待某个条件时，会进入Condition的等待队列，等待队列可以有多个。
	当Condition条件满足时，线程会从等待队列重新进入到同步队列进行获取锁的竞争。

	用大白话来说，AQS就是基于CLH队列，用volatile修饰共享变量state，线程通过CAS去改变状态符，成功则获取锁成功，失败则进入等待队列，等待被唤醒。

	注意：AQS是自旋锁。在等待唤醒的时候，经常会使用自旋（while(!cas())）的方式，不停地尝试获取锁，直到被其他线程获取成功。

	实现了AQS的锁有：自旋锁、互斥锁、读锁写锁、条件产量、信号量、栅栏都是AQS的衍生物。
		Reentrantlock就是基于AQS实现的，Reentrantlock内部有公平锁和非公平锁两种实现，差别就在于新来的线程会不会比已经在同步队列中的等待线程更早获得锁。
		和Reentrantlock实现方式类似，Semaphore也是基于AQS，差别在于Reentrantlock是独占锁，Semaphore是共享锁。






请谈谈你对乐观锁、悲观锁、自旋锁、分段锁、读写锁、排它锁、共享锁等等锁的理解，他们有什么区别？

乐观锁:认为数据一般情况下不会造成冲突。每次都不加锁, 假设没有冲突而去完成某项操作; 如果发生冲突了那就去重试，直到成功为止。（实现通常用“版本号”）
		读多写少，提高系统吞吐
		1、JDK并发包中的原子类；2、数据库乐观锁、缓存乐观锁
		实现操作：
			使用版本号机制：加上一个version字段，表示数据被修改的次数；数据被修改时，version会自动加1；读取数据也读取version值，当该值等于数据库中的version时，才更新；否则，重试更新操作；【建议使用这个】

			或者CAS算法：compare and swap（比较和交换）一种无锁算法；缺点是ABA问题；


悲观锁:对数据被外界修改持保守态度（悲观），因此在整个数据处理过程中，将数据出于锁定状态，而别的任务处于被阻塞的状态；
		写多读少，保证写操作时的数据安全
		1、JVM中的synchronized和Lock；
		2、分布式环境基于数据库行锁、页锁、表锁、共享锁（读锁）、排它锁（写锁）【select语句最后加上for update】；
		3、基于zookeeper、Redis 的分布式锁

自旋锁:自旋锁是互斥锁的一种实现。
		在自旋锁中，当资源被加锁后，其他线程想要获取资源，此时该线程不会被阻塞睡眠而是陷入循环等待状态（CPU不能做其它事情），循环检查资源持有者是否已经释放了资源（挂起-可运行-运行-挂起……），这样做的好处是减少了线程从睡眠到唤醒的资源消耗，但会一直占用CPU的资源。
		适用于资源的锁被持有的时间短，而又不希望在线程的唤醒上花费太多资源的情况。

分段锁：简单的将锁细粒度化，将一个锁分成两段或者多段，线程根据自己操作的段来加锁解锁。这样做可以避免线程之间互相无意义的等待，减少线程的等待时间。
		常见的应用有ConcurrentHashMap，它内部实现了Segment<K,V>继承了ReentrantLock，分成了16段。

读写锁：将读锁和写锁分离。
		读写锁实际是一种特殊的自旋锁，它把对共享资源的访问者划分成读者和写者，读者只对共享资源进行读访问，写者则需要对共享资源进行写操作。这种锁相对于自旋锁而言，能提高并发性，因为在多处理器系统中，它允许同时有多个读者来访问共享资源，最大可能的读者数为实际的逻辑CPU数。写者是排他性的，一个读写锁同时只能有一个写者或多个读者（与CPU数相关），但不能同时既有读者又有写者。
		
		在读写锁保持期间也是抢占失效的。
		如果读写锁当前没有读者，也没有写者，那么写者可以立刻获得读写锁，否则它必须自旋在那里，直到没有任何写者或读者。
		如果读写锁没有写者，那么读者可以立即获得该读写锁，否则读者必须自旋在那里，直到写者释放该读写锁。

排它锁：又叫互斥锁、独占锁、写锁，一个锁在某一时刻只能被一个线程占有，其它线程必须等待锁被释放之后才可能获取到锁。如ReentrantLock。

共享锁：又称读锁，就是允许多个线程同时获取一个锁，一个锁可以同时被多个线程拥有。比如说ReadWriteLock。

公平锁：遵循了先到先得的原则，多个线程按照申请锁的顺序来获取锁。Java 中的ReentrantLock中可以通过构造函数构建公平锁，实现原理貌似是链表而不是队列。

非公平锁：加锁时不考虑排队等待问题, 直接尝试获取锁, 获取不到自动到队尾等待。ReentrantLock锁内部提供了公平锁与非公平锁内部类之分, 默认是非公平锁。

可重入锁：也叫做递归锁。某个线程已经获得某个锁，可以再次获取锁而不会出现死锁。比如说synchronized、ReentrantLock。






讲一讲CAS算法与ABA问题？

	CAS(Compare And Swap)：是一种有名的无锁算法。乐观锁的一种实现，是一种轻量级锁。
		Cas操作是线程在读取数据时不进行加锁，在准备写回数据时比较原值是否修改，若未被其他线程修改则写回；若已被修改，则重新执行读取流程。这是一种乐观策略，认为并发操作并不总会发生。比较并写回的操作是通过操作系统原语实现的，保证执行过程中不会被中断, 是靠硬件实现的，从而在硬件层面提升效率。

	ABA问题：CAS容易出现ABA问题，如果线程T1读取值A之后，发生过两次写入，先由线程T2写回了b，又由T3写回了A，此时T1在经过CAS写回比较时，值还是A，就无法判断是否发生过修改。
			ABA问题不一定会影响结果，但还是需要防范。
			解决办法：可以增加额外的标志位或者时间戳。
						JUC工具包中提供了这样的类，如AtomicStampedReference，这是一个带有时间戳的对象引用。
						还有一个原子类也可以解决，就是AtomicMarkableReference，它不是维护一个版本号，而是维护一个boolean类型的标记，用法没有AtomicStampedReference灵活。因此也只是在特定的场景下使用。