
-------------
背景：出于运行速率的考虑，java编译器会把经常访问的变量放到缓存（严格讲应该是工作内存）中，读取变量则从缓存中读。
		但是在多线程编程中，内存中的值和缓存中的值可能会出现不一致。

	总结：被volatile修饰的变量从主内存读取，保证每个线程能够获取该变量的最新值，从而避免出现数据脏读的现象。




volatile 的特性：
	volatile是java中的一个类型修饰符。它是被设计用来修饰被不同线程访问和修改的变量。如果不加入volatile，基本上会导致这样的结果：要么无法编写多线程程序，要么编译器失去大量优化的机会。
	volatile只能保证变量的安全，不能保证线程的安全，他保证变量对于其他线程的可见性。

	1.保证可见性，不保证原子性，也就不能保证线程安全：
	  可见性指的是在一个线程中对该变量的修改会马上由工作内存（Work Memory）写回主内存（Main Memory），所以会马上反应在其它线程的读取操作中。顺便
	  一提，工作内存和主内存可以近似理解为实际电脑中的高速缓存和主存，工作内存是线程独享的，主存是线程共享的。

	2.禁止指令重排序优化，实现有序性。解析：关于指令重排序的问题，可以查阅 DCL 双检锁失效相关资料。
	  禁止指令重排序优化。大家知道我们写的代码（尤其是多线程代码），由于编译器优化，在实际执行的时候可能与我们编写的顺序不同。编译器只保证程序执行结果
	  与源代码相同，却不保证实际指令的顺序与源代码相同。
	  这在单线程看起来没什么问题，然而一旦引入多线程，这种乱序就可能导致严重问题。volatile关键字就可以从语义上解决这个问题。

	  注意，禁止指令重排优化这条语义直到jdk1.5以后才能正确工作。此前的JDK中即使将变量声明为volatile也无法完全避免重排序所导致的问题。所以，在jdk1.5版本
	  前，双重检查锁形式的单例模式是无法保证线程安全的。




volatile如何防止指令重排？volatile关键字通过“内存屏障”来防止指令被重排序。



volatile 能使得一个非原子操作变成原子操作吗？
	一个典型的例子是在类中有一个 long 类型的成员变量。如果你知道该成员变量会被多个线程访问，如计数器、价格等，你最好是将其设置为 volatile。为什么？因为 Java 中读取 long 类型变量不是原子的，需要分成两步，如果一个线程正在修改该 long 变量的值，另一个线程可能只能看到该值的一半（前 32 位）。
	但是对一个 volatile型的 long或 double变量的读写是原子。






实现原理：




Happens-Before内存模型？
