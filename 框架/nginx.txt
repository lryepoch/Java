
-------------------
·正向代理：正向代理最大的特点是客户端非常明确要访问的服务器地址；服务器只清楚请求来自哪个代理服务器，而不清楚来自哪个具体的客户端；
			正向代理模式屏蔽或者隐藏了真实客户端信息。
			正向代理，"它代理的是客户端，代客户端发出请求"。
			
			用途：访问原来无法访问的资源，如google；
					可以做缓存，加速访问资源；
					对客户端访问授权，上网进行认证；
					代理可以记录用户访问记录（上网行为管理），对外隐藏用户信息；


·反向代理：反向代理，"它代理的是服务端，代服务端接收请求"，主要用于服务器集群分布式部署的情况下，反向代理隐藏了服务器的信息。
			客户端是无感知代理的存在的，反向代理对外都是透明的，访问者并不知道自己访问的是一个代理。因为客户端不需要任何配置就可以访问。
			
			作用：保证内网的安全，通常将反向代理作为公网访问地址，Web服务器是内网；
					负载均衡，通过反向代理服务器来优化网站的负载。



·nginx是一个web服务器，很快速，但是不能作为Servlet 容器独立运行，所以通常的工作方式是Nginx配合Tomcat来协同工作。 这就是为什么要单独提供Tomcat，以方便配合Nginx进行工作。
	
	动静分离就是指图片，css，js之类的都交给nginx来处理，nginx处理不了的，比如jsp就交给tomcat来处理。好处是nginx处理静态内容的吞吐量很高，比tomcat高多了，这样无形中提升了性能。




·使用场景：
	在前后端分离的项目中，例如前端采用 Vue，后端采用Spring-Boot等，大多都会遇到同一个问题，就是跨域的问题，下面将讲述一下如何使用Nginx来解决前后端分离的跨域问题。

	··解决跨域请求：
		···要么后端代码cors处理；
			跨域资源共享：
			从 ajax 里拿其它服务器的资源。
			可以看到，这个主要是为了解决前端人员的问题。但 ajax 里其实就有一个 url 参数，所以反向代理也能解决这个问题。
			是在被访问的服务器上配置（允许访问其他的服务器）。

		···要么nginx配置；
			反向代理：将一台服务器作为网关和代理服务器，负责将请求转发到子系统（其它服务器）；从用户的角度看，我只访问了一个域名，但其实可能你访问了很多服务器，是在访问其它服务器的服务器上配置（要转发到的服务器）。

			在servers文件夹下创建文件port_http.conf，填写如下代码：

			server {
			    listen *:8088;
			    server_name localhost;

			    
			    location ^~ /api/ {
			        proxy_pass http://127.0.0.1:8889/;
			    }
			    location ^~ /xx/ {
			        proxy_pass http://127.0.0.1:8089/xx/;
			    }
			}

			创建文件之后，启动(或重载)Nginx，配置便会生效

			启动 sudo nginx

			重载：sudo nginx -s reload	(若已经启动请执行此指令)

			以上代码表示 Nginx监听8088端口

			如果请求为 127.0.0.1:8088/api 则会被转发到127.0.0.1:8889

			如果请求为 127.0.0.1:8088/xx 则会被转发到127.0.0.1:8089/xxx

			所以，如果当你想调用127.0.0.1:8889/test 的接口时，则应该改为调用127.0.0.1:8088/api/test

			与此同时，前端原本为 127.0.0.1:8089/xx/profile 的网址，则应改为打开127.0.0.1:8088/xx/profile

			这样，相当于对前后端的操作都是在8088端口下进行操作的，所以接就能完美解决前后端分离的项目中的跨域问题啦




·配置nginx跨域：
	server {
	  listen       80;
	  server_name  api.abc.com;

	  # 是否允许请求带有验证信息
	  add_header Access-Control-Allow-Credentials true;
	  # 允许跨域访问的域名,可以是一个域的列表，空格隔开，也可以是通配符*（不建议）
	  add_header Access-Control-Allow-Origin  http://card.abc.com;
	  # 允许使用的请求方法，以逗号隔开，可以用 *
	  add_header Access-Control-Allow-Methods 'POST,GET,OPTIONS,PUT,DELETE';
	  # 预检命令的缓存，如果不缓存每次会发送两次请求，单位为秒。
	  # 第一次是浏览器使用OPTIONS方法发起一个预检请求，第二次才是真正的异步请求
	  add_header Access-Control-Max-Age 3600;

	  # 允许脚本访问的返回头
	  add_header Access-Control-Allow-Headers 'Authorization,Content-Type,Accept,Origin,User-Agent,DNT,Cache-Control,X-Mx-ReqToken,X-Requested-With';
	  # 允许自定义的头部，以逗号隔开,大小写不敏感
	  add_header Access-Control-Expose-Headers 'WWW-Authenticate,Server-Authorization';

	  # OPTIONS类的请求，是跨域先验请求
	  if ($request_method = 'OPTIONS') {
	     return 204; # http状态码 204 （无内容） 服务器成功处理了请求，但没有返回任何内容。可以返回 200
	  }
	  location / {
	    # proxy_pass http://127.0.0.1:3000;
	  }
	  location /card {
	    proxy_pass http://127.0.0.1:3001;
	  }
	  location /music {
	    proxy_pass http://127.0.0.1:3002;
	  }
	}


	

·关于CORS：
	同源策略(Same Origin Policy)：具有相同的Origin，也即是拥有相同的协议、主机地址以及端口。一旦这三项数据中有一项不同，那么该资源就将被认为是从不同的Origin得来的，进而不被允许访问。

	CORS是一个W3C标准，全称是"跨域资源共享"（Cross-origin resource sharing）。CORS就是为了解决SOP问题而生的，当然CORS不是唯一的解决方案。

	它允许浏览器向跨源(协议 + 域名 + 端口)服务器，发出XMLHttpRequest请求，从而克服了AJAX只能同源使用的限制。
	CORS需要浏览器和服务器同时支持。目前，所有浏览器都支持该功能，IE浏览器不能低于IE10。
	整个CORS通信过程，都是浏览器自动完成，不需要用户参与。对于开发者来说，CORS通信与同源的AJAX通信没有差别，代码完全一样。浏览器一旦发现AJAX请求跨源，就会自动添加一些附加的头信息，有时还会多出一次附加的请求，但用户不会有感觉。
	因此，实现CORS通信的关键是服务器。只要服务器实现了CORS接口，就可以跨源通信。

	浏览器将CORS请求分成两类：简单请求（simple request）和非简单请求（not-so-simple request）。
		浏览器发出CORS简单请求，只需要在头信息之中增加一个Origin字段。

		浏览器发出CORS非简单请求，会在正式通信之前，增加一次OPTIONS查询请求，称为"预检"请求（preflight）。浏览器先询问服务器，当前网页所在的域名是否在服务器的许可名单之中，以及可以使用哪些HTTP动词和头信息字段。只有得到肯定答复，浏览器才会发出正式的XMLHttpRequest请求，否则就报错。
		简单请求就是HEAD、GET、POST请求，并且HTTP的头信息不超出以下几种字段 Accept、Accept-Language、Content-Language、Last-Event-ID、Content-Type 注：Content-Type只限于三个值：application/x-www-form-urlencoded、multipart/form-data、text/plain

		反之，就是非简单请求。
		
	其实实现CORS很简单，就是在服务端加一些响应头，并且这样做对前端来说是无感知的，很方便。





· 详解响应头：
 * Access-Control-Allow-Origin 该字段必填。它的值要么是请求时Origin字段的具体值，要么是一个*，表示接受任意域名的请求。
 *
 * Access-Control-Allow-Methods 该字段必填。它的值是逗号分隔的一个具体的字符串或者*，表明服务器支持的所有跨域请求的方法。
 * 注意，返回的是所有支持的方法，而不单是浏览器请求的那个方法。这是为了避免多次"预检"请求。
 *
 * Access-Control-Expose-Headers 该字段可选。CORS请求时，XMLHttpRequest对象的getResponseHeader()方法只能拿到6个基本字段：Cache-Control、
 * Content-Language、Content-Type、Expires、Last-Modified、Pragma。如果想拿到其他字段，就必须在Access-Control-Expose-Headers里面指定。
 *
 * Access-Control-Allow-Credentials 该字段可选。它的值是一个布尔值，表示是否允许发送Cookie.默认情况下，不发生Cookie，即：false。对服务器有特殊要求的请求，
 * 比如请求方法是PUT或DELETE，或者Content-Type字段的类型是application/json，这个值只能设为true。如果服务器不要浏览器发送Cookie，删除该字段即可。
 *
 * Access-Control-Max-Age 该字段可选，用来指定本次预检请求的有效期，单位为秒。在有效期间，不用发出另一条预检请求。
 *
 * 顺便提一下，如果在开发中，发现每次发起请求都是两条，一次OPTIONS，一次正常请求。注意是每次，那么就需要配置Access-Control-Max-Age，避免每次都发出预检请求。





·解决跨域，办法有三种：

	第一种办法:

	import org.springframework.context.annotation.Configuration;
	import org.springframework.web.servlet.config.annotation.CorsRegistry;
	import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;

	@Configuration
	public class CorsConfig implements WebMvcConfigurer {
	    @Override
	    public void addCorsMappings(CorsRegistry registry) {
	        registry.addMapping("/**")
	                .allowedOrigins("*")
	                .allowedMethods("GET", "HEAD", "POST", "PUT", "DELETE", "OPTIONS")
	                .allowCredentials(true)
	                .maxAge(3600)
	                .allowedHeaders("*");
	    }
	}
	这种方式是全局配置的，网上也大都是这种解决办法，但是很多都是基于旧的spring版本，比如：

	★https://blog.csdn.net/tiangongkaiwu152368/article/details/81099169”
	文中WebMvcConfigurerAdapter在spring5.0已经被标记为Deprecated，点开源码可以看到：

	/**
	 * An implementation of {@link WebMvcConfigurer} with empty methods allowing
	 * subclasses to override only the methods they're interested in.
	 *
	 * @author Rossen Stoyanchev
	 * @since 3.1
	 * @deprecated as of 5.0 {@link WebMvcConfigurer} has default methods (made
	 * possible by a Java 8 baseline) and can be implemented directly without the
	 * need for this adapter
	 */
	@Deprecated
	public abstract class WebMvcConfigurerAdapter implements WebMvcConfigurer {}
	像这种过时的类或者方法，spring的作者们一定会在注解上面说明原因，并告诉你新的该用哪个，这是非常优秀的编码习惯，点赞！

	spring5最低支持到jdk1.8，所以注释中明确表明，你可以直接实现WebMvcConfigurer接口，无需再用这个适配器，因为jdk1.8支持接口中存在default-method。


	第二种办法:

	import org.springframework.context.annotation.Configuration;
	import javax.servlet.*;
	import javax.servlet.annotation.WebFilter;
	import javax.servlet.http.HttpServletResponse;
	import java.io.IOException;

	@WebFilter(filterName = "CorsFilter ")
	@Configuration
	public class CorsFilter implements Filter {
	    @Override
	    public void doFilter(ServletRequest req, ServletResponse res, FilterChain chain) throws IOException, ServletException {
	        HttpServletResponse response = (HttpServletResponse) res;
	        response.setHeader("Access-Control-Allow-Origin","*");
	        response.setHeader("Access-Control-Allow-Credentials", "true");
	        response.setHeader("Access-Control-Allow-Methods", "POST, GET, PATCH, DELETE, PUT");
	        response.setHeader("Access-Control-Max-Age", "3600");
	        response.setHeader("Access-Control-Allow-Headers", "Origin, X-Requested-With, Content-Type, Accept");
	        chain.doFilter(req, res);
	    }
	}
	这种办法，是基于过滤器的方式，方式简单明了，就是在response中写入这些响应头，好多文章都是第一种和第二种方式都叫你配置，其实这是没有必要的，只需要一种即可。

	这里也吐槽一下，大家不求甚解的精神。


	第三种办法：

	public class GoodsController {
	    @CrossOrigin(origins = "http://localhost:4000")
	    @GetMapping("goods-url")
	    public Response queryGoodsWithGoodsUrl(@RequestParam String goodsUrl) throws Exception {}
	}  
	没错就是**@CrossOrigin**注解，点开注解

	@Target({ ElementType.METHOD, ElementType.TYPE })
	@Retention(RetentionPolicy.RUNTIME)
	@Documented
	public @interface CrossOrigin {}
	从元注解@Target可以看出，注解可以放在method、class等上面，类似RequestMapping，也就是说，整个controller下面的方法可以都受控制，也可以单个方法受控制。

	也可以得知，这个是最小粒度的cors控制办法了，精确到单个请求级别。
















