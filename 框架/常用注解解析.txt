
SpringMVC注解：
---------------------

·@RequestParam注解：接收请求参数。
	@RequestParam是位列Controller层，作用是为获取前端参数，方式主要有两种，一种是request.getParameter("name")，另外一种是用注解@RequestParam直接获取，解决的是前后端参数不一致的问题。
	(@RequestParam（value/name="id"，required=false，defaultValue=1）Integer id)【required默认是true，@RequestParam(required=true)表示当前参数必须传入，不传值会抛出异常。当设置为false时，不传id时不会出错，以defaultValue值显示】

·@PathVariable
	这个注解能够识别URL里面的一个模板。
	【注意：】如果URL中无参数，将会出错；
				如果URL有参数，但是没有使用@PathVariable该注解，那么URL的参数不会默认与方法参数绑定！方法里的参数会默认绑定表单里面对应的参数！
				如果参数名与占位符一致，则可直接使用@PathVariable；如果不一致，则在@PathVariable( )括号内绑定占位符。

	带占位符的URL是Spring3.0新增的功能，该功能在SpringMVC向REST目标挺进发展过程中具有里程碑的意义，
	通过@PathVariable可以将URL中占位符参数绑定到控制器处理方法的入参中：URL中的{xxx}占位符可以通过@PathVariable(“xxx“)绑定到操作方法的入参中。

	eg：如果要获取某个id下此条问题答案的查询次数的话，则后台就需要动态获取参数，其注解为@PathVariable，并且requestMapping中的value应为value="/{id}/queryNum"。

·@RequestParam和@PathVariable区别与联系：
	··@RequestParam和@PathVariable注解是用于从request中接收请求的，两个都可以接收参数；
	··不同的是@RequestParam是从request里面拿取值，而 @PathVariable是从一个URI模板里面来填充；
	··总的来说，@RequestParam均是键值对形式。与@PathVariable中的占位符形式不同！！！


·@RequestBody
	一般是post请求的时候才会使用这个请求，把参数丢在@Requestbody里面。


·@RequestParam和@RequestBody区别：
	··使用@RequestParam获取参数，然后使用@RequestBody对json格式的参数转换为Java类型；
	··@RequestBody需要把所有请求参数作为json解析，因此，不能包含key=value这样的写法在请求url中，所有的请求参数都是一个json。直接通过浏览器输入url时，@RequestBody获取不到json对象，需要用java编程或者基于ajax的方法请求，将Content-Type设置为application/json；


·@ResponseBody
	@responseBody表示服务器返回的时候以一种什么样的方式进行返回， 将内容或对象作为 HTTP 响应正文返回，值有很多，一般设定为json。
	Spring的ResponseBody和RestController注解返回的json数据不是json字符串，而是json对象，因为可以点出对象里面的属性。


·@RequestMapping:
	··可以用于类或方法上，在类上表示所有响应请求的方法都是以该地址作为"父路径"；
	··params只是在其中的一个参数而已；
	··该注解有6个属性，分三类：
			a.value,method(重要)			##@RequestMapping(value = "/editCourse", method = {RequestMethod.GET})
			b.consumes,produces
			c.params,headers
			@RequestMapping注解：设置访问路径，一般和方法名一致。如果没有写/，会自动加上/。


·@PathParam
	这个注解是和spring的pathVariable是一样的，也是基于模板的，但是这个是jboss包下面的一个实现，上面的是spring的一个实现，都要导包。

·@QueryParam
	@QueryParam是JAX-RS本来就提供的，和Spring的RequestParam作用一致。



·@Valid：@Valid不提供分组功能；
	··@Valid注解用于校验，所属包为：javax.validation.Valid；

	··首先需要在实体类的相应字段上添加用于充当校验条件的注解，如：@Min,如下代码（age属于Girl类中的属性）：
		@Min(value = 18,message = "未成年禁止入内")  
		private Integer age;

	··其次在controller层的方法的要校验的参数上添加@Valid注解，并且需要传入BindingResult对象，用于获取校验失败情况下的反馈信息，
		@Validated注解用于验证一个入参，验证之后的消息绑定到BindingResult类中。

		如下代码：
		@PostMapping("/girls")  
		public Girl addGirl(@Valid Girl girl, BindingResult bindingResult) {  
		    if(bindingResult.hasErrors()){  
		        System.out.println(bindingResult.getFieldError().getDefaultMessage());  
		        return null;  
		    }  
		    return girlResposity.save(girl);  
		}  

		解析：bindingResult.getFieldError.getDefaultMessage()用于获取相应字段上添加的message中的内容，如：@Min注解中message属性的内容。
				这样使用注解来验证参数就很方便了，不用再写代码去验证入参了。



shiro:
-------------------------
·@RequirePermission：添加权限
	这种方式直观，哪里需要权限，哪里写就行。但是，真正项目开发的时候，这种方式就很有局限性了。
	当权限配置关系发生变化，每次都要修改代码，编译打包重启系统，这肯定是不能够被接受的。

	所以，最好的方式，还是通过动态配置，给不同的用户配置不同的角色，权限，修改之后立马生效这种方式。 为了实现这个效果，就需要基于URL配置权限的方式来做了。






MyBatis：
---------------------------
·@Param：
	MyBatis所提供的(org.apache.ibatis.annotations.Param)，作为Dao层的注解，作用是用于传递参数，从而可以与SQL中的的字段名相对应，一般在2=<参数个数<=5时使用最佳。




Spring：
-----------------------------
	·修饰类：
		@Componet注解：代表将该对象放入到IOC容器中，括号里面的名字代表该对象在IOC容器中的唯一标识名字，名字任意取。该注解写在代码第一行。

		@Repository：表示持久层的组件，修改Service层对象添加到IOC容器的注解方式；
		@Service：表示业务逻辑层的组件，修改Servlet层对象添加到IOC容器的注解方式为；
		@Controller：表示控制层的组件；

	·属性注入：
		@Value：设置普通属性的值；

		@Autowired：按照类型（byType）进行装配依赖对象；
		默认情况下它要求依赖对象必须存在，如果允许null值，可以设置它的required属性为false。
		如果我们想使用按照名称（byName）来装配，可以结合@Qualifier注解一起使用。如下：

		public class TestServiceImpl {
		    @Autowired
		    @Qualifier("userDao")

		    }
		-----------------------------
		@Resource（不带括号的注解），必须要保证该类型只有一个变量，所以一般情况下我们还是优先使用@Resource(name=””)注解。
		@Resource（name=“”）：用于将该对象依赖的属性从IOC容器中找到并注入，括号里面的name属性值必须跟@Compenent注解里填入的名字相同。

		@Resource有两个重要的属性：name和type，Spring将@Resource注解的name属性解析为bean的名字，而type属性则解析为bean的类型。
			如果既不制定name也不制定type属性，这时将通过反射机制使用byName自动注入策略。

		@Resource装配顺序：

			①如果同时指定了name和type，则从Spring上下文中找到唯一匹配的bean进行装配，找不到则抛出异常。

			②如果指定了name，则从上下文中查找名称（id）匹配的bean进行装配，找不到则抛出异常。

			③如果指定了type，则从上下文中找到类似匹配的唯一bean进行装配，找不到或是找到多个，都会抛出异常。

			④如果既没有指定name，又没有指定type，则自动按照byName方式进行装配；如果没有匹配，则回退为一个原始类型进行匹配，如果匹配则自动装配。

			@Resource的作用相当于@Autowired，只不过@Autowired按照byType自动注入。
		--------------------------------

	·其他注解：
		@RequestMapping：映射一个URL到一个类或者一个特定方法上。
		@Scope：范围注解；默认单例；多例如@Scope（“prototype”）

	·@Configuration 和 @Component 区别：
		相同点是都是注解在类上的注解，不同点就是@Component注解的范围最广，所有类都可以注解；但是@Configuration注解一般注解在这样的类上：这个类里面有@Value注解的成员变量和@Bean注解的方法，就是一个配置类。

		@Component注解是说这个类需要被组件扫描器扫描到并实例化对象到IOC容器；@Configuration注解是说这个类是一个类似XML文件的配置类，里面用bean标签标记的方法需要被实例化到IOC容器中。在springboot中取消了XML文件并大量使用@Configuration注解的类实现配置。

		@Configuration中所有带@Bean注解的方法都会被动态代理，因此调用该方法返回的都是同一个实例；
		从定义来看， @Configuration 注解本质上还是 @Component，因此 <context:component-scan/> 或者 @ComponentScan 都能处理@Configuration 注解的类。

		虽然Component注解也会当做配置类，但是并不会为其生成CGLIB代理Class，所以在生成Driver对象时和生成Car对象时调用car()方法执行了两次new操作，所以是不同的对象。
		当时Configuration注解时，生成当前对象的子类Class，并对方法拦截，第二次调用car()方法时直接从BeanFactory之中获取对象，所以得到的是同一个对象。




springboot：
----------------------------
·@ServletComponentScan：
	在SpringBootApplication上使用，该注解使得Servlet、Filter、Listener可以直接通过@WebServlet、@WebFilter、@WebListener注解自动注册，无需其他代码。

·@Configuation加载Spring方法
	1.1、@Configuration配置spring并启动spring容器
	@Configuration标注在类上，相当于把该类作为spring的xml配置文件中的<beans>，作用为：配置spring容器(应用上下文)
	1.2、@Configuration启动容器+@Bean注册Bean，@Bean下管理bean的生命周期
	@Bean标注在方法上(返回某个实例的方法)，等价于spring的xml配置文件中的<bean>，作用为：注册bean对象
	1.3、@Configuration启动容器+@Component注册Bean
	1.6、@Configuation总结
	 @Configuation等价于<Beans></Beans>
	 @Bean等价于<Bean></Bean>
	 @ComponentScan等价于<context:component-scan base-package="com.dxz.demo"/>



·@Scheduled：
	cron表达式是一个字符串，字符串以5或6个空格隔开，分开共6或7个域，每一个域代表一个含义；
	cron表达式语法：[秒] [分] [小时] [日] [月] [周] [年]。注：[年]不是必须的域，可以省略[年]，则一共6个域



·打印日志：
	··@Slf4j：log.info();
	··Logger logger = LoggerFactory.getLogger(this.getClass());
	  logger.info();


·@ConfigurationProperties(prefix="")：
	··大量的参数配置在 application.properties 或 application.yml 文件中，通过 @ConfigurationProperties 注解，我们可以方便的获取这些参数值；
	··可以使用 @Value 注解或着使用 Spring Environment bean 访问这些属性，是这种注入配置方式有时显得很笨重。我们将使用更安全的方式(@ConfigurationProperties )来获取这些属性；






实体类属性注解：
---------------------------
注解	     作用类型	                   解释
@NotNull	 基本类型	                属性不能为null
@NotEmpty	 集合类	                    集合不能为null，且size大于0
@NotBlanck	 字符串、字符	            字符类不能为null，且去掉空格之后长度大于0
@AssertTrue	 Boolean、boolean	        布尔属性必须是true
@Min	    数字类型（原子和包装）	    限定数字的最小值（整型）
@Max	    同@Min	                    限定数字的最大值（整型）
@DecimalMin	同@Min	                限定数字的最小值（字符串，可以是小数）
@DecimalMax	同@Min	                限定数字的最大值（字符串，可以是小数）
@Range	    数字类型（原子和包装）	    限定数字范围（长整型）
@Length	    字符串	                    限定字符串长度
@Size	    集合	                    限定集合大小
@Past	    时间、日期	            必须是一个过去的时间或日期
@Future	    时期、时间	            必须是一个未来的时间或日期
@Email	    字符串	                必须是一个邮箱格式
@Pattern	字符串、字符	        正则匹配字符串
以上注解用到要验证参数的封装类中的属性上：


public class Test {
    
    @NotNull(message = "ID不能为空")
    @Range(min = 1, max = 100, message = "ID必须在1到100之间")
    private Integer id;

    @NotBlank(message = "姓名不能为空")
    @Length(min = 2, max = 6, message = "姓名必须在2到6位之间")
    private String name;

    @NotNull(message = "余额不能为空")
    @DecimalMax(value = "30.50", message = "余额不能超过30.5")
    @DecimalMin(value = "1.50", message = "余额不能低于1.5")
    private BigDecimal amount;

    @NotNull(message = "生日不能为空")
    @Past(message = "生日必须是过去")
    private Date birthday;

    @NotBlank(message = "邮箱不能为空")
    @Email(message = "邮箱格式不正确")
    private String email;

    @NotBlank(message = "手机号不能为空")
    @Pattern(regexp = "^(((13[0-9])|(14[579])|(15([0-3]|[5-9]))|(16[6])|(17[0135678])|(18[0-9])|(19[89]))\\d{8})$", message = "手机号格式错误")
    private String phone;

}




