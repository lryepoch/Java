
SpringMVC注解：
---------------------

·@RequestParam注解：接收请求参数。
	@RequestParam是位列Controller层，作用是为获取前端参数，方式主要有两种，一种是request.getParameter("name")，另外一种是用注解@RequestParam直接获取，解决的是前后端参数不一致的问题。
	(@RequestParam（value/name="id"，required=false，defaultValue=1）Integer id)【required默认是true，@RequestParam(required=true)表示当前参数必须传入，不传值会抛出异常。当设置为false时，不传id时不会出错，以defaultValue值显示】

·@PathVariable
	这个注解能够识别URL里面的一个模板。
	【注意：】如果URL中无参数，将会出错；
				如果URL有参数，但是没有使用@PathVariable该注解，那么URL的参数不会默认与方法参数绑定！方法里的参数会默认绑定表单里面对应的参数！
				如果参数名与占位符一致，则可直接使用@PathVariable；如果不一致，则在@PathVariable( )括号内绑定占位符。

	带占位符的URL是Spring3.0新增的功能，该功能在SpringMVC向REST目标挺进发展过程中具有里程碑的意义，
	通过@PathVariable可以将URL中占位符参数绑定到控制器处理方法的入参中：URL中的{xxx}占位符可以通过@PathVariable(“xxx“)绑定到操作方法的入参中。

	eg：如果要获取某个id下此条问题答案的查询次数的话，则后台就需要动态获取参数，其注解为@PathVariable，并且requestMapping中的value应为value="/{id}/queryNum"。

·@RequestParam和@PathVariable区别与联系：
	··@RequestParam和@PathVariable注解是用于从request中接收请求的，两个都可以接收参数；
	··不同的是@RequestParam是从request里面拿取值，而 @PathVariable是从一个URI模板里面来填充；
	··总的来说，@RequestParam均是键值对形式。与@PathVariable中的占位符形式不同！！！


·@RequestBody
	一般是post请求的时候才会使用这个请求，把参数丢在@Requestbody里面。


·@RequestParam和@RequestBody区别：
	··使用@RequestParam获取参数，然后使用@RequestBody对json格式的参数转换为Java类型；
	··@RequestBody需要把所有请求参数作为json解析，因此，不能包含key=value这样的写法在请求url中，所有的请求参数都是一个json。直接通过浏览器输入url时，@RequestBody获取不到json对象，需要用java编程或者基于ajax的方法请求，将Content-Type设置为application/json；


·@ResponseBody
	@responseBody表示服务器返回的时候以一种什么样的方式进行返回， 将内容或对象作为 HTTP 响应正文返回，值有很多，一般设定为json。
	Spring的ResponseBody和RestController注解返回的json数据不是json字符串，而是json对象，因为可以点出对象里面的属性。


·@RequestMapping:
	··可以用于类或方法上，在类上表示所有响应请求的方法都是以该地址作为"父路径"；
	··params只是在其中的一个参数而已；
	··该注解有6个属性，分三类：
			a.value,method(重要)			##@RequestMapping(value = "/editCourse", method = {RequestMethod.GET})
			b.consumes,produces
			c.params,headers
			@RequestMapping注解：设置访问路径，一般和方法名一致。如果没有写/，会自动加上/。


·@PathParam
	这个注解是和spring的pathVariable是一样的，也是基于模板的，但是这个是jboss包下面的一个实现，上面的是spring的一个实现，都要导包。

·@QueryParam
	@QueryParam是JAX-RS本来就提供的，和Spring的RequestParam作用一致。



·@Valid：@Valid不提供分组功能；
	··@Valid注解用于校验，所属包为：javax.validation.Valid；

	··首先需要在实体类的相应字段上添加用于充当校验条件的注解，如：@Min,如下代码（age属于Girl类中的属性）：
		@Min(value = 18,message = "未成年禁止入内")  
		private Integer age;

	··其次在controller层的方法的要校验的参数上添加@Valid注解，并且需要传入BindingResult对象，用于获取校验失败情况下的反馈信息，
		@Validated注解用于验证一个入参，验证之后的消息绑定到BindingResult类中。

		如下代码：
		@PostMapping("/girls")  
		public Girl addGirl(@Valid Girl girl, BindingResult bindingResult) {  
		    if(bindingResult.hasErrors()){  
		        System.out.println(bindingResult.getFieldError().getDefaultMessage());  
		        return null;  
		    }  
		    return girlResposity.save(girl);  
		}  

		解析：bindingResult.getFieldError.getDefaultMessage()用于获取相应字段上添加的message中的内容，如：@Min注解中message属性的内容。
				这样使用注解来验证参数就很方便了，不用再写代码去验证入参了。


·@Validated：可以用在类型、方法和方法参数上。但是不能用在成员属性（字段）上；@Valid：可以用在方法、构造函数、方法参数和成员属性（字段）上；

			两者是否能用于成员属性（字段）上直接影响能否提供嵌套验证的功能。



shiro:
-------------------------
·@RequirePermission：添加权限
	这种方式直观，哪里需要权限，哪里写就行。但是，真正项目开发的时候，这种方式就很有局限性了。
	当权限配置关系发生变化，每次都要修改代码，编译打包重启系统，这肯定是不能够被接受的。

	所以，最好的方式，还是通过动态配置，给不同的用户配置不同的角色，权限，修改之后立马生效这种方式。 为了实现这个效果，就需要基于URL配置权限的方式来做了。






MyBatis：
---------------------------
·@Param：
	MyBatis所提供的(org.apache.ibatis.annotations.Param)，作为Dao层的注解，作用是用于传递参数，从而可以与SQL中的的字段名相对应，一般在2=<参数个数<=5时使用最佳。




Spring：
-----------------------------
	·修饰类：
		@Componet注解：代表将该对象放入到IOC容器中，括号里面的名字代表该对象在IOC容器中的唯一标识名字，名字任意取。该注解写在代码第一行。

		@Repository：表示持久层的组件，修改Service层对象添加到IOC容器的注解方式；
		@Service：表示业务逻辑层的组件，修改Servlet层对象添加到IOC容器的注解方式为；
		@Controller：表示控制层的组件；

	·属性注入：
		@Value：设置普通属性的值；

		@Autowired：按照类型（byType）进行装配依赖对象；
		默认情况下它要求依赖对象必须存在，如果允许null值，可以设置它的required属性为false。
		如果我们想使用按照名称（byName）来装配，可以结合@Qualifier注解一起使用。如下：

		public class TestServiceImpl {
		    @Autowired
		    @Qualifier("userDao")

		    }
		-----------------------------
		@Resource（不带括号的注解），必须要保证该类型只有一个变量，所以一般情况下我们还是优先使用@Resource(name=””)注解。
		@Resource（name=“”）：用于将该对象依赖的属性从IOC容器中找到并注入，括号里面的name属性值必须跟@Compenent注解里填入的名字相同。

		@Resource有两个重要的属性：name和type，Spring将@Resource注解的name属性解析为bean的名字，而type属性则解析为bean的类型。
			如果既不制定name也不制定type属性，这时将通过反射机制使用byName自动注入策略。

		@Resource装配顺序：

			①如果同时指定了name和type，则从Spring上下文中找到唯一匹配的bean进行装配，找不到则抛出异常。

			②如果指定了name，则从上下文中查找名称（id）匹配的bean进行装配，找不到则抛出异常。

			③如果指定了type，则从上下文中找到类似匹配的唯一bean进行装配，找不到或是找到多个，都会抛出异常。

			④如果既没有指定name，又没有指定type，则自动按照byName方式进行装配；如果没有匹配，则回退为一个原始类型进行匹配，如果匹配则自动装配。

			@Resource的作用相当于@Autowired，只不过@Autowired按照byType自动注入。
		--------------------------------

	·其他注解：
		@RequestMapping：映射一个URL到一个类或者一个特定方法上。
		@Scope：范围注解；默认单例；多例，如@Scope（“prototype”）

	·@Configuration 和 @Component 区别：
		相同点是都是注解在类上的注解，不同点就是@Component注解的范围最广，所有类都可以注解；但是@Configuration注解一般注解在这样的类上：这个类里面有@Value注解的成员变量和@Bean注解的方法，就是一个配置类。

		@Component注解是说这个类需要被组件扫描器扫描到并实例化对象到IOC容器；@Configuration注解是说这个类是一个类似XML文件的配置类，里面用bean标签标记的方法需要被实例化到IOC容器中。在springboot中取消了XML文件并大量使用@Configuration注解的类实现配置。

		@Configuration中所有带@Bean注解的方法都会被动态代理，因此调用该方法返回的都是同一个实例；
		从定义来看， @Configuration 注解本质上还是 @Component，因此 <context:component-scan/> 或者 @ComponentScan 都能处理@Configuration 注解的类。

		虽然Component注解也会当做配置类，但是并不会为其生成CGLIB代理Class，所以在生成Driver对象时和生成Car对象时调用car()方法执行了两次new操作，所以是不同的对象。
		当时Configuration注解时，生成当前对象的子类Class，并对方法拦截，第二次调用car()方法时直接从BeanFactory之中获取对象，所以得到的是同一个对象。




springboot：
----------------------------
·@ServletComponentScan：
	在SpringBootApplication上使用，该注解使得Servlet、Filter、Listener可以直接通过@WebServlet、@WebFilter、@WebListener注解自动注册，无需其他代码。

·@Configuation加载Spring方法
	1.1、@Configuration配置spring并启动spring容器
	@Configuration标注在类上，相当于把该类作为spring的xml配置文件中的<beans>，作用为：配置spring容器(应用上下文)
	1.2、@Configuration启动容器+@Bean注册Bean，@Bean下管理bean的生命周期
	@Bean标注在方法上(返回某个实例的方法)，等价于spring的xml配置文件中的<bean>，作用为：注册bean对象
	1.3、@Configuration启动容器+@Component注册Bean
	1.6、@Configuation总结
	 @Configuation等价于<Beans></Beans>
	 @Bean等价于<Bean></Bean>
	 @ComponentScan等价于<context:component-scan base-package="com.dxz.demo"/>



·@Scheduled：
	cron表达式是一个字符串，字符串以5或6个空格隔开，分开共6或7个域，每一个域代表一个含义；
	cron表达式语法：[秒] [分] [小时] [日] [月] [周] [年]。注：[年]不是必须的域，可以省略[年]，则一共6个域



·打印日志：
	··@Slf4j：log.info();
	··Logger logger = LoggerFactory.getLogger(this.getClass());
	  logger.info();


·@ConfigurationProperties(prefix="")：
	··大量的参数配置在 application.properties 或 application.yml 文件中，通过 @ConfigurationProperties 注解，我们可以方便的获取这些参数值；
	··可以使用 @Value 注解或着使用 Spring Environment bean 访问这些属性，是这种注入配置方式有时显得很笨重。我们将使用更安全的方式(@ConfigurationProperties )来获取这些属性；






实体类属性校验注解：
---------------------------
@Null  被注释的元素必须为null
@NotNull  被注释的元素不能为null
@AssertTrue  该字段只能为true
@AssertFalse  该字段的值只能为false
@Min(value)  被注释的元素必须是一个数字，其值必须大于等于指定的最小值
@Max(value)  被注释的元素必须是一个数字，其值必须小于等于指定的最大值
@DecimalMin("value")  被注释的元素必须是一个数字，验证小数的最小值
@DecimalMax("value")  被注释的元素必须是一个数字，验证小数的最大值
@Size(max,min)  查该字段的size是否在min和max之间，可以是字符串、数组、集合、Map等
@Digits(integer,fraction) 检查是否是一种数字的整数、分数,小数位数的数字
@Past  被注释的元素必须是一个过去的日期
@Future  被注释的元素必须是一个将来的日期
@Pattern(regexp = "[abc]") 被注释的元素必须符合指定的正则表达式。
@Email 被注释的元素必须是电子邮件地址
@Length(max=5,min=1,message="长度在1~5")    检查所属的字段的长度是否在min和max之间,只能用于字符串
@NotEmpty  被注释的字符串必须非空
@Range  被注释的元素必须在合适的范围内   
@CreditCardNumber 对信用卡号进行一个大致的验证
@NotBlank 不能为空，检查时会将空格忽略
@NotEmpty 不能为空，这里的空是指空字符串

以上注解在使用时，都可以设置自定义message提示信息。


entity类：
public class Test {
    
    @NotNull(message = "ID不能为空")
    @Range(min = 1, max = 100, message = "ID必须在1到100之间")
    private Integer id;

    @NotBlank(message = "姓名不能为空")
    @Length(min = 2, max = 6, message = "姓名必须在2到6位之间")
    private String name;

    @NotNull(message = "余额不能为空")
    @DecimalMax(value = "30.50", message = "余额不能超过30.5")
    @DecimalMin(value = "1.50", message = "余额不能低于1.5")
    private BigDecimal amount;

    @NotNull(message = "生日不能为空")
    @Past(message = "生日必须是过去")
    private Date birthday;

    @NotBlank(message = "邮箱不能为空")
    @Email(message = "邮箱格式不正确")
    private String email;

    @NotBlank(message = "手机号不能为空")
    @Pattern(regexp = "^(((13[0-9])|(14[579])|(15([0-3]|[5-9]))|(16[6])|(17[0135678])|(18[0-9])|(19[89]))\\d{8})$", message = "手机号格式错误")
    private String phone;

}


controller层：
public class TestController {
 
	@PostMapping("/a")
    @ApiOperation(value = "测试", notes = "")
	public void test(@RequestBody @Valid Test test,BindingResult bindingResult) {
		System.out.println(test.toString());
		if (bindingResult.hasErrors()) {
			throw new 自定义Exception("错误提示码",bindingResult.getFieldError().getDefaultMessage());
		}
	}
}


总结：@Valid和BindingResult配套使用，@Valid用在参数前，BindingResult作为校验结果绑定返回。

		bindingResult.hasErrors()判断是否校验通过，校验未通过，bindingResult.getFieldError().getDefaultMessage()获取在Test的属性设置的自定义message，如果没有设置，则返回默认值"javax.validation.constraints.XXX.message"。

		注意：在实体类使用校验注解时，controller一定要使用bindingResult处理校验结果，且实体类作为查询参数时，避免被其他方法使用，不然有的地方需要限制，有的没有，不需要限制的方法会报错。



lombok：
----------------------------
	@Accessors：Accessor的中文含义是存取器，@Accessors用于配置getter和setter方法的生成结果，下面介绍三个属性：

	··fluent的中文含义是流畅的，设置为true，则getter和setter方法的方法名都是基础属性名，且setter方法返回当前对象。如下

		@Data
		@Accessors(fluent = true)
		public class User {
		    private Long id;
		    private String name;
		    
		    // 生成的getter和setter方法如下，方法体略
		    public Long id() {}
		    public User id(Long id) {}
		    public String name() {}
		    public User name(String name) {}
		}

	··chain的中文含义是链式的，设置为true，则setter方法返回当前对象。如下

		@Data
		@Accessors(chain = true)
		public class User {
		    private Long id;
		    private String name;
		    
		    // 生成的setter方法如下，方法体略
		    public User setId(Long id) {}
		    public User setName(String name) {}
		}

	··prefix的中文含义是前缀，用于生成getter和setter方法的字段名会忽视属性的指定前缀（遵守驼峰命名）。如下

		@Data
		@Accessors(prefix = "p")
		class User {
			private Long pId;
			private String pName;
			
			// 生成的getter和setter方法如下，方法体略
			public Long getId() {}
			public void setId(Long id) {}
			public String getName() {}
			public void setName(String name) {}
		}





·自定义注解：
··定义：
	注解是一种元数据形式。即注解是属于java的一种数据类型，和类、接口、数组、枚举类似。
	注解用来修饰，类、方法、变量、参数、包。
	注解不会对所修饰的代码产生直接的影响。

	注解其实就是一种标记，可以在程序代码中的关键节点（类、方法、变量、参数、包）上打上这些标记，然后程序在编译时或运行时可以检测到这些标记从而执行一些特殊操作。

··基本语法：在底层实现上，所有定义的注解都会自动继承java.lang.annotation.Annotation接口。

··常用元注解：
	@Target		限定某个自定义注解能够被应用在哪些Java元素
				注解类型元素，有些元素是没有默认值的，这要求我们在使用的时候必须在标记名后面打上()，并且在()内以“元素名=元素值“的形式挨个填上所有没有默认值的注解类型元素（有默认值的也可以填上重新赋值），中间用“,”号分割；

	@Retention  注解的生命周期有三个阶段：1、Java源文件阶段；2、编译到class文件阶段；3、运行期阶段。
	@Documented 被用来指定自定义注解是否能随着被定义的java文件生成到JavaDoc文档当中
	@Inherited  指定某个自定义注解如果写在了父类的声明部分，那么子类的声明部分也能自动拥有该注解。@Inherited注解只对那些@Target被定义为ElementType.TYPE的自定义注解起作用。

··反射操作获取注解：
	1.如果我们要获得的注解是配置在方法上的，那么我们要从Method对象上获取；如果是配置在属性上，就需要从该属性对应的Field对象上去获取，如果是配置在类型上，需要从Class对象上去获取。总之在谁身上，就从谁身上去获取！
	2.isAnnotationPresent(Class<? extends Annotation> annotationClass)方法是专门判断该元素上是否配置有某个指定的注解；
	3.getAnnotation(Class<A> annotationClass)方法是获取该元素上指定的注解。之后再调用该注解的注解类型元素方法就可以获得配置时的值数据；
	4.反射对象上还有一个方法getAnnotations()，该方法可以获得该对象身上配置的所有的注解。它会返回给我们一个注解数组，需要注意的是该数组的类型是Annotation类型，这个Annotation是一个
		来自于java.lang.annotation包的接口。









·@PostConstruct注解好多人以为是Spring提供的。其实是Java自己的注解。

Java中该注解的说明：@PostConstruct该注解被用来修饰一个非静态的void（）方法。被@PostConstruct修饰的方法会在服务器加载Servlet的时候运行，并且只会被服务器执行一次。PostConstruct在构造函数之后执行，init（）方法之前执行。

通常我们会是在Spring框架中使用到@PostConstruct注解 该注解的方法在整个Bean初始化中的执行顺序：

Constructor(构造方法) -> @Autowired(依赖注入) -> @PostConstruct(注释的方法)
