
·docker概念：
	··docker可以让开发者打包他们的应用以及依赖包到一个轻量级、可移植的容器中，然后发布到任何流行的Linux机器上，也可以实现虚拟化。
		容器是完全使用沙箱机制，相互之间不会有任何接口（类似 iPhone 的 app）,更重要的是容器性能开销极低。

　　··docker：最早是dotCloud公司出品的一套容器管理工具，但后来Docker慢慢火起来了，连公司名字都从dotCloud改成Docker。

　　··dockerfile：它是Docker镜像的描述文件，可以理解成火箭发射的A、B、C、D……的步骤。

　　··Dockerfile由多条指令组成，每条指令在编译镜像时执行相应的程序完成某些功能，由指令+参数组成，以逗号分隔，
		#作为注释起始符，虽说指令不区分大小写，但是一般指令使用大些，参数使用小写；

　　··docker镜像：通过Dockerfile做出来的，包含操作系统基础文件和软件运行环境，它使用分层的存储方式。镜像不包含任何动态数据，其内容在构建之后也不会被改变。

　　··docker容器：是运行起来的镜像，简单理解，Docker镜像相当于程序，容器相当于进程。容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等。
					Docker容器通过 Docker镜像来创建。

	··docker仓库：镜像构建完成后，可以很容易的在当前宿主机上运行。但是，如果需要在其它服务器上使用这个镜像，我们就需要一个集中的存储、分发镜像的服务，Docker Registry 					就是这样的服务。
					一个Docker Registry中可以包含多个仓库；每个仓库可以包含多个标签；每个标签对应一个镜像，其中标签可以理解为镜像的版本号。
					Docker仓库用来保存镜像，可以理解为代码控制中的代码仓库。Docker Hub(https://hub.docker.com) 提供了庞大的镜像集合供使用。

	··Docker版本：Docker划分为CE 和EE。CE即社区版（免费，支持周期三个月），EE即企业版，强调安全，付费使用。

	··分层存储：镜像只是一个虚拟的概念，其实际体现并非由一个文件组成，而是由一组文件系统组成，或者说，由多层文件系统联合组成。
				镜像构建时，会一层层构建，前一层是后一层的基础。每一层构建完就不会再发生改变，后一层上的任何改变只发生在自己这一层。比如，删除前一层文件的操作，实际不是真的删除前一层的文件，而是仅在当前层标记为该文件已删除。在最终容器运行的时候，虽然不会看到这个文件，但是实际上该文件会一直跟随镜像。因此，在构建镜像的时候，需要额外小心，每一层尽量只包含该层需要添加的东西，任何额外的东西应该在该层构建结束前清理掉。
				分层存储的特征还使得镜像的复用、定制变的更为容易。甚至可以用之前构建好的镜像作为基础层，然后进一步添加新的层，以定制自己所需的内容，构建新的镜像。





·文件src/main/docker/Dockerfile。每一个指令都会在镜像上创建一个新的层，每一个指令的前缀都必须是大写的。
	Dockerfile的基本指令有十三个，分别是：FROM、MAINTAINER、RUN、CMD、EXPOSE、ENV、ADD、COPY、ENTRYPOINT、VOLUME、USER、WORKDIR、ONBUILD。

	#使用JDK8环境为基础镜像，如果镜像不是本地的将会从DockerHub进行下载
	FROM java:8

	#允许指定端口转发(可无)
	EXPOSE 8080

	#在宿主机的/var/lib/docker目录下创建一个临时文件并把他链接到tomcat容器的工作目录 /tmp
	VOLUME /tmp

	#项目的jar文件作为"app.jar"添加到容器中。复制文件并且重命名
	ADD springboot-docker.jar app.jar

	#运行jar包（可无）
	RUN base -c 'touch /app.jar'

	#用于为docker容器设置环境变量（可无）
	ENV JAVA_OPTS=""

	#ENTRYPOINT执行项目app.jar。为了缩短Tomcat启动时间，添加一个系统属性指向"/dev/urandom"作为Entropy Source
	ENTRYPOINT ["java","-Djava.security.egd=file:/dev/./urandom","-jar","/app.jar"]





·安装docker-ce版本：
	yum install docker-ce；
	sudo yum -y install docker-ce；安装最新版本

·部署文件：一般来说，在服务器新建一个docker文件夹/docker，将maven打包好的jar包和Dockerfile文件复制到该docker文件夹下
·设置docker镜像：vi  /etc/docker/daemon.json
·常见指令:
	docker build -t xxx .       #制作镜像，-t 参数是指定此镜像的tag名，xxx为自定义的镜像名称， . 代表当前目录，也就是Dockerfile所在的目录
	docker images                     #命令查看镜像
	docker ps 					#列出容器
	docker run -d -p 8080:8085 xxx    #启动容器，-d 指定容器在后台运行，-p 8080:8085 用于将容器内的8085端口映射到宿主机的8080端口，也可以换成其他本机端口。 
									【-P将容器内部开放的网络端口随机映射到宿主机的一个端口上；
									  -p指定要映射的端口，一个指定端口上只可以绑定一个容器；】

	--------------------------------					  
	docker kill CONTAINER_ID        #停止指定ID容器
	docker port CONTAINER_ID		#查看映射端口配置

	docker start 		#启动一个或多个已经被停止的容器
	docker restart 		#重启容器
	docker create 		#创建一个新的容器但不启动它
	docker exec 		#在运行的容器中执行命令
	docker commit 		#从容器创建一个新的镜像

	docker pull xxx		# 从镜像仓库中拉取或者更新指定镜像
	docker push xxx			#将本地的镜像上传到镜像仓库,要先登陆到镜像仓库
	docker search xxx			#从Docker Hub查找镜像
	docker info 			#显示 Docker 系统信息，包括镜像和容器数
	docker version 			#显示 Docker 版本信息。

	docker stop $(docker ps -a -q)		#停止所有的容器
	docker rm $(docker ps -a -q)		#删除所有的容器（只删除单个时把后面的变量改为image id即可）

	docker rmi $(docker images -q)		#删除全部的images
	docker rmi <image id>		#删除指定id的镜像
	docker rmi $(docker images | grep "^" | awk "{print $3}")   	#想要删除untagged images，也就是那些id为的image的话可以用
	docker rmi -f $(docker images -q)		#当要删除的iamges和其他的镜像有关联而无法删除时，可通过 -f 参数强制删除





·常见两种方式使用docker部署springboot项目：
	··创建一个文件夹docker里面放置 Dockerfile和 springBoot打包的项目docker_spring_boot.jar
		docker build -t docker .
		docker run -d -p 8080:8080 docker
	
	··把整个工程代码拷到centos服务器某个目录下（包括src、target、pom.xml），
		在该目录下，创建镜像：mvn package docker:build      
					查看镜像：docker images
					运行镜像：docker run -d -p 8010:8010 -t springio/gs-spring-boot-docker-master