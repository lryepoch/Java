
·mybatis的缺点：
    1.mybatis sql工作量很大，尤其是字段多的时候。虽然说单表的增删改查操作可以通过mybatis generator工具来生成（或者自己写模板工具生成），但项目开发的过程中总免不了要新添加新字段，这些工具就帮不了我了，我得把新字段写到原来的所有增删改查的sql中。这是个痛苦的过程，特别是当你重复了很多次之后。

    2.mybatis的单表操作也是贼麻烦的事，因为筛选的条件可能会各种各样，所以你不得不写很多动态sql来兼容查询条件，这也让我不能集中精力去处理业务。



·mybatis plus：是一个 Mybatis 的增强工具，在 Mybatis 的基础上只做增强不做改变，为简化开发、提高效率而生。

·mybatis plus的特性：
    1.mybatis-plus不仅仅封装了基本的CRUD操作，内置了防SQL注入操作、常用的分页插件，还有我最喜欢的ActiveRecord模式
    用过jfinal的人应该都知道ActiveRecord是啥。Active Record 是一种数据访问设计模式，它可以帮助你实现数据对象Object到关系数据库的映射。

    常用注解：
    @TableName ：表名注解；
    @TableId ：主键注解；
        @TableId(value = “id”,type = IdType.INPUT) 
        主键生成方式类型如下（IdType）：

                AUTO(0, “数据库ID自增”),
                INPUT(1, “用户输入ID”),
                ID_WORKER(2, “全局唯一ID”),
                UUID(3, “全局唯一ID”),
                NONE(4, “该类型为未设置主键类型”),
                ID_WORKER_STR(5, “字符串全局唯一ID”);


    @Version :乐观锁标记注解；
    @TableField ：字段注解；
    @KeySequence ：序列主键策略注解；


    2.当数据库的表字段名是驼峰命名时无需注解处理。
    或者全局配置： 下划线命名 dbColumnUnderline 设置 true , 大写 isCapitalMode 设置 true。使用mp代码生成器自动生成主体后直接覆盖原来的就行了，减少人工的失误，方便快捷。

    3.简化CURD：
    喜欢ActiveRecord的模式写法，因为我不用注入userMapper，new了一个对象之后直接调用方法操作就行了复杂的查询也很简单，新建一个EntityWrapper作为查询对象，Wrapper接口封装了很多常用的方法。几乎sql能写出来的条件调用Wrapper的方法就能表现出来。





·虽然Mybatis Plus帮我们提供了大量的默认方法，但我们为了实现多表关联查询，或者根据不同的查询条件传参，实现不同的动态SQL。在这种情况下我们还是需要自定义SQL。



·官方表示，mybatis plus 提供3.x支持Lambda表达式。



·条件构造器queryWrapper和updateWrapper：
    ··QueryWrapper： Entity 对象封装操作类。
        CarEntity Entity = this.carMapper.selectOne(new QueryWrapper<CarEntity>()
                                            .lambda()
                                            .eq(CarEntity::getTerminalid, tEntity.getTerminalid()));


    ··UpdateWrapper ： Update 条件封装，用于Entity对象更新操作；不是用lambda语法。
        UpdateWrapper<CarEntity> ew = new UpdateWrapper<>();
        ew.lambda().set(CarEntity::getTerminalcode,null)
                .set(CarEntity::getTerminalid,null)
                .set(CarEntity::getModifiedon,LocalDateTime.now())
                .eq(CarEntity::getCarid,cEntity.getCarid());
        this.carMapper.update(null, ew);




·QueryWrapper
    最基础的使用方式是这样
    // 查询条件构造器
    QueryWrapper<BannerItem> wrapper = new QueryWrapper<>();
    wrapper.eq("banner_id", id);

    // 查询操作
    List<BannerItem> bannerItems = bannerItemMapper.selectList(wrapper);

    然后我们可以引入lambda，避免我们在代码中写类似的于banner_id的硬编码

    QueryWrapper<BannerItem> wrapper = new QueryWrapper<>();
    wrapper.lambda().eq(BannerItem::getBannerId, id);
    List<BannerItem> bannerItems = bannerItemMapper.selectList(wrapper);

·LambdaQueryWrapper
    为了简化lambda的使用，我们可以改写成LambdaQueryWrapper构造器，语法如下：
    LambdaQueryWrapper<BannerItem> wrapper = new QueryWrapper<BannerItem>().lambda();
    wrapper.eq(BannerItem::getBannerId, id);
    List<BannerItem> bannerItems = bannerItemMapper.selectList(wrapper);

    我们可以再次将QueryWrapper<BannerItem>.lambda()简化，变成这个样子

    LambdaQueryWrapper<BannerItem> wrapper = new LambdaQueryWrapper<>();
    wrapper.eq(BannerItem::getBannerId, id);
    List<BannerItem> bannerItems = bannerItemMapper.selectList(wrapper);

    链式查询
    MyBatis-Plus还提供了一种链式查询的方式，和上面的代码效果一样。
    但是这种写法偏向于炫技，可读性没有上面的代码强，大家可以根据需要自行选择方式。
    List<BannerItem> bannerItems = new LambdaQueryChainWrapper<>(bannerItemMapper)
                            .eq(BannerItem::getBannerId, id)
                            .list();



·BaseMapper？