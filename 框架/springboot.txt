
·优点：
	··可以创建独立的Spring应用程序，并且有内置的服务器。不需要将我们的项目单独的发布到tomcat或者jboss等某个HHTP服务器上，因为它有内置的tomcat、jetty等服务器，它直接回归到了我们最初学习java	时的启动方式。也就是通过一个main函数的方式来启动我们的项目。只不过我们的main函数上面多了一个@SpringBootApplication的注解。
	··可以大量减少构建配置。基本上不需要代码的生成、XML的配置以及尽可能多的提供第三方库。SpringBoot只需通过注解的形式配置开发当中一些动态的参数即可；


·入门：
	··建立过程：
		1.新建一个maven工程；
		2.导入相应的jar包；
		3.创建 Application.java，其注解 @SpringBootApplication 表示这是一个SpringBoot应用，运行其主方法就会启动tomcat,默认端口是8080；
			注意：启动类Application.java应该位于什么位置呢？因为要扫描所有的类，所以必须位于所有子包的上一层！！！！否则就要手动指定要加载的包！！！

	··关注点：
		1、application.java内嵌有tomcat，所以当启动项目时，像正常滴启动一个java application即可。
		2、springboot是使用maven管理的，注意maven的创建过程。
			SpringBoot 应用，本质上是一个Java 程序，其采用的风格是 maven 风格，所以又是一个 Maven 项目，接下来我们就按照 maven 项目的方式创建就行了。 不要被花里胡哨的插件掩盖了其本质。
		3、热部署：当发现任何类发生了改变，马上通过JVM类加载的方式，加载最新的类到虚拟机中。这样就不需要重新启动也能看到修改后的效果了。完成热部署只需在pom.xml中新增加一个依赖和一个插件即可。Springboot 部署会采用两种方式：全部打包成一个jar，或者打包成一个war。
		4、通过修改application.properties，修改访问的端口号和上下文路径；

	··视图：
		1.Springboot的默认视图支持是Thymeleaf。也可支持jsp。thymeleaf跟JSP一样，就是运行之后，就得到纯HTML了。 
		
		2.区别在于不运行之前，thymeleaf也是纯html。所以thymeleaf不需要 服务端的支持，就能够被以html的方式打开，这样就方便前端人员独立设计与调试。
		 jsp就不行了，不启动服务器jsp都没法运行出结果来。


	··异常处理：
		1.新建一个异常类：
		2.使用@ControllerAdvice + @ExceptionHandler进行全局的Controller层异常处理。而且，@Validated校验器注解的异常，也可以一起处理，无需手动判断绑定校验结果BindingResult/Errors了！
		但是，只能处理Controller层未捕获（往外抛）的异常，对于 Interceptor（拦截器）层的异常，Spring框架层的异常，就无能为力了。


	··配置文件格式：
		1.springboot的配置文件还支持yml格式。application.properties，application.yml是2种不同的格式，但作用是一样的。
		2.在application.yml 文件书写注意：
								1)不同“等级” 用冒号隔开；
								2)次等级的前面是空格，不能使用制表符(tab)；
								3)冒号之后如果有值，那么冒号和值之间至少有一个空格，不能紧贴着；
		3.要么用application.properties ，要么用 application.yml。不要都用。


·springboot默认static中放静态页面，而templates中放动态页面；
	··templates文件夹，是放置模板文件的，因此需要视图解析器来解析它。所以必须通过服务器内部进行访问，也就是要走控制器--服务--视图解析器这个流程才行。
	··static文件夹，既不能直接访问，也不能通过服务器访问到。因此，这个文件夹，可能是放一些css、图片这样的文件供服务器内部引用。




·springboot异常处理：【status/code/message/data】
	
	Springboot异常的处理，可以通过一下几种方法：
	1、通过自定义BasicErrorController 错误处理，这个是处理是基于状态码的。
		··在启动器里面，添加EmbeddedServletContainerCustomizer，然后在里面注册处理相应状态码的界面；
		··定义错误处理控制器，这个控制器和普通控制器类似，主要是用来处理状态码对应的错误的视图；

	2、使用@ControllerAdvice来进行统一异常处理，@ExceptionHandler(value = Exception.class)来指定捕获的异常 ；

		··定义一个返回值的数据结构；
		··定义全局异常处理器@ControllerAdvice，里面定义了异常捕抓器@ExceptionHandler，可以捕抓参数检测不合格（MethodArgumentNotValidException）、其他Exception类及其子异常类、自定义异常类（GlobalException）；
		··定义一个错误码枚举类；
			常见状态码：200-OK-响应成功
						400-Bad Request-请求出现语法错误，一般请求参数不对
						401-Unauthorized-访问被拒绝
						403-Forbidden-资源不可用
						404-Not Found-无法找到指定位置的资源
						500-Internal server error-服务器内部错误

		··编译异常需要提前捕获或者抛出，编译异常处理完成之后程序继续往下执行，而运行异常会被全局异常处理器所捕获处理；
		
		··自定义异常：继承Exception/RuntimeException；定义成员code/message；构造方法；
						系统中需要手动throw new Exception(…);

		··controller层处理异常，service层中使用spring事务，处理异常之后需要再次抛出。如果service处理了异常，那么事务就不会回滚。



·单元测试：
	@RunWith(SpringRunner.class)
	@SpringBootTest(classes = Application.class)
	test方法加上@Test注解