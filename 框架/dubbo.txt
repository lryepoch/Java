-------------
·本地过程调用：本机上内部的方法调用都可以称为本地过程调用；

·远程过程调用RPC(Remote Procedure Call)：指的是你本地调用了远程机子上的某个方法;
	RPC广泛应用在大规模分布式应用中，作用是有助于系统的垂直拆分，使系统更易拓展。Java中的RPC框架比较多，各有特色，广泛使用的有RMI、Hessian、Dubbo等。RPC还有一个特点就是能够跨语言，RPC是与语言无关的。


·RPC要如何调用远程的方法呢？可以走 HTTP、也可以是基于 TCP自定义协议。

·服务消费者：
	··首先消费者面向接口编程，所以需要得知有哪些接口可以调用，可以通过公用 jar 包的方式来维护接口。
	··需要来个代理类，让消费者只管调，啥事都别管了。需要告诉代理，你调用的是哪个方法，并且参数的值是什么。
	··需要有个注册中心，这样调用方从注册中心可以知晓可以调用哪些服务提供方。提供方一般都是集群部署，那调用方需要通过负载均衡来选择一个调用，可以通过某些策略例如同机房优先调用啊啥的。
	··需要有容错机制，毕竟这是远程调用，网络是不可靠的，所以可能需要重试什么的。
	··还要和服务提供方约定一个协议，例如我们就用 HTTP 来通信就好啦，也就是大家要讲一样的话，不然可能听不懂了。
	··序列化必不可少，毕竟我们本地的结构是“立体”的，需要序列化之后才能传输，因此还需要约定序列化格式。
	··并且这过程中间可能还需要掺入一些Filter，来作一波统一的处理，例如调用计数啊等等。


·服务提供者：
	服务提供者肯定要实现对应的接口这是毋庸置疑的。
	然后需要把自己的接口暴露出去，向注册中心注册自己，暴露自己所能提供的服务。
	然后有消费者请求过来需要处理，提供者需要用和消费者协商好的协议来处理这个请求，然后做反序列化。
	序列化完的请求应该扔到线程池里面做处理，某个线程接受到这个请求之后找到对应的实现调用，然后再将结果原路返回。


·注册中心：相当于一个平台，大家在上面暴露自己的服务，也在上面得知自己能调用哪些服务。当然还能做配置中心，将配置集中化处理，动态变更通知订阅者。


·监控运维：面对众多的服务，精细化的监控和方便的运维必不可少。


·大致上一个 RPC 框架需要做的就是约定要通信协议，序列化的格式、一些容错机制、负载均衡策略、监控运维和一个注册中心！




-----------------
·Apache Dubbo是一款高性能Java RPC框架；

·整体流程：首先服务提供者Provider启动，然后向注册中心注册自己所能提供的服务。

			服务消费者Consumer启动，向注册中心订阅自己所需的服务。然后注册中心将提供者元信息通知给Consumer，之后Consumer因为已经从注册中心获取提供者的地址，因此可以通过负载均衡选择一个Provider直接调用 。

			之后服务提供方元数据变更的话，注册中心会把变更推送给服务消费者。

			服务提供者和消费者都会在内存中记录着调用的次数和时间，然后定时的发送统计数据到监控中心。

·一些注意点：
	首先注册中心和监控中心是可选的，你可以不要监控，也不要注册中心，直接在配置文件里面写然后提供方和消费方直连。
	
	然后注册中心、提供方和消费方之间都是长连接，和监控方不是长连接，并且消费方是直接调用提供方，不经过注册中心。
	
	就算注册中心和监控中心宕机了也不会影响到已经正常运行的提供者和消费者，因为消费者有本地缓存提供者的信息。


·Dubbo分层架构：
	大的三层分别为 Business（业务层）、RPC 层、Remoting，并且还分为 API 层和 SPI 层。继续细分有10层。只有层次分明，职责边界清晰才能更好的扩展。

	而分 API 层和 SPI 层这是 Dubbo 成功的一点，采用微内核设计+SPI扩展，使得有特殊需求的接入方可以自定义扩展，做定制的二次开发。



·看看每一层都是干嘛的：

	Service，业务层，就是咱们开发的业务逻辑层。

	Config，配置层，主要围绕 ServiceConfig 和 ReferenceConfig，初始化配置信息。

	Proxy，代理层，服务提供者还是消费者都会生成一个代理类，使得服务接口透明化，代理层做远程调用和返回结果。

	Register，注册层，封装了服务注册和发现。

	Cluster，路由和集群容错层，负责选取具体调用的节点，处理特殊的调用要求和负责远程调用失败的容错措施。

	Monitor，监控层，负责监控统计调用时间和次数。

	Portocol，远程调用层，主要是封装 RPC 调用，主要负责管理 Invoker，Invoker代表一个抽象封装了的执行体，之后再做详解。

	Exchange，信息交换层，用来封装请求响应模型，同步转异步。

	Transport，网络传输层，抽象了网络传输的统一接口，这样用户想用 Netty 就用 Netty，想用 Mina 就用 Mina。

	Serialize，序列化层，将数据序列化成二进制流，当然也做反序列化。
