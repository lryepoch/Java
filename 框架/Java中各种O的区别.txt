Java中各种O的区别：

·VO
View Object表现层对象。
主要对应界面显示的数据对象。对于一个WEB页面，用一个VO对象对应整个界面的值。
我的理解：查询数据库返回给前端的实体；

·PO
Persistant Object持久对象。
可以理解为数据库中表的一条记录。好处是可以把一条记录作为一个对象处理，可以方便的转为其他对象。
如果持久层是关系型数据库，那么，数据表中的每个字段（或若干个）就对应PO的一个（或若干个）属性。

·DTO
Data Transfer Object数据传输对象。
主要用于远程调用等需要大量传输对象的地方。 
比如我们一张表有100个字段，那么对应的PO就有100个属性。 
但是我们界面上只要显示10个字段，客户端用WEB service来获取数据，没有必要把整个PO对 象传递到客户端，
这时我们就可以用只有这10个属性的DTO来传递结果到客户端，这样也不会暴露服务端表结构。到达客户端以后，如果用这个对象来对应界面显示，那此时它的身份就转为VO

·DO
Domain Object领域对象，就是从现实世界中抽象出来的有形或无形的业务实体。
一个DTO可能对应多个DO，一个PO可能对应多个DO。
我的理解：页面查询时，需要输入的条件实体；

----------------------
·POJO
简单java对象。简单无规则，只有setter和getter。
可以理解为VO和PO的父类。
一个POJO持久化以后就是PO；直接用它传递、传递过程中就是DTO；直接用来对应表示层就是VO。

·BO
Business Object业务对象。
主要作用是把业务逻辑封装为一个对象。这个对象可以包括一个或者多个其他的对象。用来处理业务逻辑。
比如一个简历，有教育经历、工作经历、社会关系等等。 
我们可以把教育经历对应一个PO，工作经历对应一个PO，社会关系对应一个PO。 
建立一个对应简历的BO对象处理简历，每个BO包含这些PO。 
这样处理业务逻辑时，我们就可以针对BO去处理。

·DAO
Data Access Object数据访问对象。
主要用来封装对数据库的访问。通过它可以把POJO持久化为PO，用PO组装出来VO、DTO。



注：不要陷入过度设计，大可不必为了设计而设计一定要在代码中区分各个对象。一句话技术是为应用服务的。


·模型：下面以一个时序图建立简单模型来描述上述对象在三层架构应用中的位置。 

		>用户发出请求（可能是填写表单），表单的数据在展示层被匹配为VO。

		>展示层把VO转换为service层对应方法所要求的DTO，传送给服务层。

		>服务层首先根据DTO的数据构造（或重建）一个DO，调用DO的业务方法完成具体业务。

		>服务层把DO转换为持久层对应的PO（可以使用ORM工具，也可以不用），调用持久层的持久化方法，把PO传递给它，完成持久化操作。

		>对于一个逆向操作，如读取数据，也是用类似的方式转换和传递，略。



·VO与DTO的区别：
对于绝大部分的应用场景来说，DTO和VO的属性值基本是一致的，而且他们通常都是POJO，因此没必要多此一举，但不要忘记这是实现层面的思维，对于设计层面来说，概念上还是应该存在VO和DTO，因为两者有着本质的区别，DTO代表服务层需要接收的数据和返回的数据，而VO代表展示层需要显示的数据。

·VO与DTO的应用：
当需求非常清晰稳定，而且客户端很明确只有一个的时候，没有必要把VO和DTO区分开来，这时候VO可以退隐，用一个DTO即可，为什么是VO退隐而不是DTO？回到设计层面，服务层的职责依然不应该与展示层耦合。


·DTO与DO的区别：
DTO是展示层和服务层之间的数据传输对象（可以认为是两者之间的协议），而DO是对现实世界各种业务角色的抽象，这就引出了两者在数据上的区别，例如UserInfo和User，对于一个getUser方法来说，本质上它永远不应该返回用户的密码，因此UserInfo至少比User少一个password的数据。

·DTO与DO的应用：



·DO与PO的区别：
DO和PO在绝大部分情况下是一一对应的，PO是只含有get/set方法的POJO，但某些场景还是能反映出两者在概念上存在本质的区别：

·DO与PO的应用：
由于ORM框架的功能非常强大而大行其道，而且JavaEE也推出了JPA规范，现在的业务应用开发，基本上不需要区分DO与PO，PO完全可以通过JPA，Hibernate Annotations/hbm隐藏在DO之中。虽然如此，但有些问题我们还必须注意：



--摘自 https://www.cnblogs.com/zxf330301/p/6534643.html