Java中各种O的区别：

·VO
View Object表现层对象。
主要对应界面显示的数据对象。对于一个WEB页面，用一个VO对象对应整个界面的值。

·PO
Persistant Object持久对象。
可以理解为数据库中表的一条记录。好处是可以把一条记录作为一个对象处理，可以方便的转为其他对象。
如果持久层是关系型数据库，那么，数据表中的每个字段（或若干个）就对应PO的一个（或若干个）属性。

·DTO
Data Transfer Object数据传输对象。
是一种设计模式之间传输数据的软件应用系统。泛指用于展示层与服务层之间的数据传输对象。
数据传输目标往往是数据访问对象从数据库中检索数据。
数据传输对象与数据交互对象或者数据访问对象之间的差异是一个以不具有任何行为除了存储和检索的数据（访问和存取器）。

----------------------
·POJO
简单java对象。简单无规则，只有setter和getter。
可以理解为VO和PO的父类。一个POJO持久化以后就是PO；直接用它传递、传递过程中就是DTO；直接用来对应表示层就是VO。

·BO
Business Object业务对象。
主要作用是把业务逻辑封装为一个对象。这个对象可以包括一个或者多个其他的对象。用来处理业务逻辑。

·DAO
Data Access Object数据访问对象。
主要用来封装对数据库的访问。通过它可以把POJO持久化为PO，用PO组装出来VO、DTO。

·DO
Domain Object领域对象，就是从现实世界中抽象出来的有形或无形的业务实体。
一个DTO可能对应多个DO，一个PO可能对应多个DO。



·模型：下面以一个时序图建立简单模型来描述上述对象在三层架构应用中的位置。 

		>用户发出请求（可能是填写表单），表单的数据在展示层被匹配为VO。

		>展示层把VO转换为service层对应方法所要求的DTO，传送给服务层。

		>服务层首先根据DTO的数据构造（或重建）一个DO，调用DO的业务方法完成具体业务。

		>服务层把DO转换为持久层对应的PO（可以使用ORM工具，也可以不用），调用持久层的持久化方法，把PO传递给它，完成持久化操作。

		>对于一个逆向操作，如读取数据，也是用类似的方式转换和传递，略。



·VO与DTO的区别：
对于绝大部分的应用场景来说，DTO和VO的属性值基本是一致的，而且他们通常都是POJO，因此没必要多此一举，但不要忘记这是实现层面的思维，对于设计层面来说，概念上还是应该存在VO和DTO，因为两者有着本质的区别，DTO代表服务层需要接收的数据和返回的数据，而VO代表展示层需要显示的数据。

·VO与DTO的应用：
当需求非常清晰稳定，而且客户端很明确只有一个的时候，没有必要把VO和DTO区分开来，这时候VO可以退隐，用一个DTO即可，为什么是VO退隐而不是DTO？回到设计层面，服务层的职责依然不应该与展示层耦合。


·DTO与DO的区别：
DTO是展示层和服务层之间的数据传输对象（可以认为是两者之间的协议），而DO是对现实世界各种业务角色的抽象，这就引出了两者在数据上的区别，例如UserInfo和User，对于一个getUser方法来说，本质上它永远不应该返回用户的密码，因此UserInfo至少比User少一个password的数据。

·DTO与DO的应用：



·DO与PO的区别：
DO和PO在绝大部分情况下是一一对应的，PO是只含有get/set方法的POJO，但某些场景还是能反映出两者在概念上存在本质的区别：

·DO与PO的应用：
由于ORM框架的功能非常强大而大行其道，而且JavaEE也推出了JPA规范，现在的业务应用开发，基本上不需要区分DO与PO，PO完全可以通过JPA，Hibernate Annotations/hbm隐藏在DO之中。虽然如此，但有些问题我们还必须注意：



--摘自 https://www.cnblogs.com/zxf330301/p/6534643.html