
·shiro框架：shiro可以完成认证、授权、加密、会话管理、与web集成、缓存等等。
     	   一个开源框架，一个权限管理框架，主要实现用户认证、用户授权。


·shiro和spring security区别：
	1.简单、灵活；复杂、笨重；
	2.可脱离spring；不可脱离spring；
	3.粒度较粗；粒度更细；


·整体架构：

	subject：主体，可以是用户也可以是程序，主体要访问系统，系统需要对主体进行认证、授权。
					主体，代表了当前“用户”，这个用户不一定是一个具体的人，与当前应用交互的任何东西都是Subject，如网络爬虫，机器人等；即一个抽象概念；
					所有Subject都绑定到SecurityManager，与Subject的所有交互都会委托给SecurityManager；
					可以把Subject认为是一个门面；SecurityManager才是实际的执行者；

	securityManager：安全管理器，主体进行认证和授权都是通过securityManager进行。所有与安全有关的操作都会与SecurityManager交互；且它管理着所有Subject；可以看出它是Shiro的核心，它								负责与后边介绍的其他组件进行交互，如果学习过SpringMVC，你可以把它看成DispatcherServlet前端控制器；

	authenticator：认证器，主体进行认证最终通过authenticator进行的。

	authorizer：授权器，主体进行授权最终通过authorizer进行的。

	sessionManager：web应用中一般是用web容器对session进行管理，shiro也提供一套session管理的方式。

	SessionDao：  通过SessionDao管理session数据，针对个性化的session数据存储需要使用sessionDao。

	cache Manager：缓存管理器，主要对session和授权数据进行缓存，比如将授权数据通过cacheManager进行缓存管理，和ehcache整合对缓存数据进行管理。

	realm：域，通过realm存取认证、授权相关数据。
			Shiro从Realm获取安全数据（如用户、角色、权限），可以把Realm看成DataSource，即安全数据源。
			SecurityManager要验证用户身份，那么它需要从Realm获取相应的用户进行比较以确定用户身份是否合法；
			也需要从Realm得到用户相应的角色/权限进行验证用户是否能进行操作。

	cryptography：密码管理，提供了一套加密/解密的组件，方便开发。比如提供常用的散列、加/解密等功能。比如 md5散列算法。



·shiro的Realm：
	内置Realm
	··IniRealm：
	··JdbcRealm讲解：继承了AuthorizingRealm类；
	··自定义Realm：也要继承AuthorizingRealm类；

	··Realm概念：
		Realm在Shiro里到底扮演什么角色呢？ 它是真正进行用户认证和授权的关键地方。
		当应用程序向Shiro提供了账号和密码之后， Shiro就会问Realm这个账号密码是否对， 如果对的话，其所对应的用户拥有哪些角色，哪些权限。 

		所以Realm其实就是个中介。 
		Realm得到了Shiro给的用户和密码后，有可能去找ini文件，就像Shiro入门中的shiro.ini，也可以去找数据库。

		通过realm从数据库中查询用户信息，所以realm的作用可想而知：根据token中的身份信息去查询数据库（入门程序我们使用ini配置文件模拟数据库）。如果查到用户则返回认证信息，如果查询不到就返回null。



·shiro认证过程：【登录】
	
	认证就是验证用户身份的过程。在认证过程中，用户需要提交实体信息【principals】和凭据信息【credentials】以检验用户是否合法。最常见的“实体/凭证”组合便是“用户名/密码”组合。

	创建SecurityManager
	主体提交认证
	SecurityManager认证
	Authenticator认证
	Realm验证


	认证过程：
	1、首先调用Subject.login(token)进行登录，其会自动委托给SecurityManager，调用之前必须通过SecurityUtils.setSecurityManager()设置。

	2、SecurityManager负责真正的身份验证逻辑；它会委托给Authenticator进行身份验证。

	3、Authenticator才是真正的身份验证者，Shiro API中核心的身份认证入口点，此处可以自定义插入自己的实现。

	4、Authenticator可能会委托给相应的AuthenticationStrategy进行多Realm身份验证，默认ModularRealmAuthenticator会调用AuthenticationStrategy进行多Realm身份验证。

	5、Authenticator会把相应的token传入Realm，从Realm获取身份验证信息，如果没有返回/抛出异常表示身份验证失败了。此处可以配置多个Realm，将按照相应的顺序及策略进行访问。



·shiro授权过程：访问控制，即应用中控制谁访问哪些资源；

				在用户认证通过后(注意只有当用户认证通过后才能对用户进行授权)，系统对用户访问资源进行控制，用户具有资源的访问权限方可访问。

	创建SecurityManager
	主体授权
	SecurityManager授权
	Authorizer授权
	Realm获取角色权限数据


	授权流程：
	1、对subject进行授权，调用方法isPermitted（"permission串"）

	2、SecurityManager执行授权，通过ModularRealmAuthorizer执行授权

	3、ModularRealmAuthorizer执行realm（自定义的Realm）从数据库查询权限数据

	调用realm的授权方法：doGetAuthorizationInfo

	4、realm从数据库查询权限数据，返回ModularRealmAuthorizer

	5、ModularRealmAuthorizer调用PermissionResolver进行权限串比对

	6、如果比对后，isPermitted中"permission串"在realm查询到权限数据中，说明用户访问permission串有权限，否则 没有权限，抛出异常。


	Shiro支持三种方式的授权： 
	1.编程式：通过写if/else授权代码块完成： 
	Subject subject = SecurityUtils.getSubject();  
	if(subject.hasRole(“admin”)) {  
	    //有权限  
	} else {  
	    //无权限  
	}   
	
	2.注解式：通过在执行的Java方法上放置相应的注解完成： 
	@RequiresRoles("admin")  
	public void hello() {  
	    //有权限  
	}   
	没有权限将抛出相应的异常；

	3.JSP/GSP标签：在JSP/GSP页面通过相应的标签完成：
	<shiro:hasRole name="admin">  
	<!— 有权限 —>  
	</shiro:hasRole>   




·shiro加密：
	··用户密码是明文的，这样是有巨大风险的，一旦泄露，就不好了。所以，通常都会采用非对称加密。

		什么是非对称呢？就是不可逆的，而md5就是这样一个算法：
		eg：123用md5加密后，得到字符串： 202CB962AC59075B964B07152D234B70。这个字符串，却无法通过计算反过来得到源密码是 123。

		这个加密后的字符串就存在数据库里了，下次用户再登陆，输入密码 123， 同样用md5加密后，再和这个字符串一比较，就知道密码是否正确了。
		如此这样，既能保证用户密码校验的功能，又能保证不暴露密码。
	

	··盐：
		虽然每次123经过md5加密之后都是202CB962AC59075B964B07152D234B70，但是我加上盐，即123+随机数，那么md5值就不一样了。
		这个随机数，就是盐。
		这个随机数也会在数据库里保存下来，每个不同的用户，随机数也是不一样的。
		
		再就是加密次数，加密一次是202CB962AC59075B964B07152D234B70。加密两次，就是另一个数了。而黑客即便是拿到了加密后的密码，如果不知道到底加密了多少次，也是很难办的。



