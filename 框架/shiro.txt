
shiro框架：shiro可以完成认证、授权、加密、会话管理、与web集成、缓存等等。
     	   一个开源框架，一个权限管理框架，主要实现用户认证、用户授权。



--shiro和spring security区别：
	1.简单、灵活；复杂、笨重；
	2.可脱离spring；不可脱离spring；
	3.粒度较粗；粒度更细；




--整体架构：

	subject：主体，可以是用户也可以是程序，主体要访问系统，系统需要对主体进行认证、授权。
					主体，代表了当前“用户”，这个用户不一定是一个具体的人，与当前应用交互的任何东西都是Subject，如网络爬虫，机器人等；即一个抽象概念；所有Subject都绑定到SecurityManager，与Subject的所有交互都会委托给SecurityManager；可以把Subject认为是一个门面；SecurityManager才是实际的执行者；

	securityManager：安全管理器，主体进行认证和授权都是通过securityManager进行。所有与安全有关的操作都会与SecurityManager交互；且它管理着所有Subject；可以看出它是Shiro的核心，它								负责与后边介绍的其他组件进行交互，如果学习过SpringMVC，你可以把它看成DispatcherServlet前端控制器；

	authenticator：认证器，主体进行认证最终通过authenticator进行的。

	authorizer：授权器，主体进行授权最终通过authorizer进行的。

	sessionManager：web应用中一般是用web容器对session进行管理，shiro也提供一套session管理的方式。

	SessionDao：  通过SessionDao管理session数据，针对个性化的session数据存储需要使用sessionDao。

	cache Manager：缓存管理器，主要对session和授权数据进行缓存，比如将授权数据通过cacheManager进行缓存管理，和ehcache整合对缓存数据进行管理。

	realm：域，领域，相当于数据源，通过realm存取认证、授权相关数据。
				注意：在realm中存储授权和认证的逻辑。

				域，Shiro从从Realm获取安全数据（如用户、角色、权限），就是说SecurityManager要验证用户身份，那么它需要从Realm获取相应的用户进行比较以确定用户身份是否合法；也需要从Realm得到用户相应的角色/权限进行验证用户是否能进行操作；可以把Realm看成DataSource，即安全数据源。

	cryptography：密码管理，提供了一套加密/解密的组件，方便开发。比如提供常用的散列、加/解密等功能。比如 md5散列算法。




--shiro认证过程：【登录】
	
	认证就是验证用户身份的过程。在认证过程中，用户需要提交实体信息【principals】和凭据信息【credentials】以检验用户是否合法。最常见的“实体/凭证”组合便是“用户名/密码”组合。

	创建SecurityManager
	主体提交认证
	SecurityManager认证
	Authenticator认证
	Realm验证

	认证过程：

	1、首先调用Subject.login(token)进行登录，其会自动委托给SecurityManager，调用之前必须通过SecurityUtils. setSecurityManager()设置。

	2、SecurityManager负责真正的身份验证逻辑；它会委托给Authenticator进行身份验证。

	3、Authenticator才是真正的身份验证者，Shiro API中核心的身份认证入口点，此处可以自定义插入自己的实现。

	4、Authenticator可能会委托给相应的AuthenticationStrategy进行多Realm身份验证，默认ModularRealmAuthenticator会调用AuthenticationStrategy进行多Realm身份验证。

	5、Authenticator会把相应的token传入Realm，从Realm获取身份验证信息，如果没有返回/抛出异常表示身份验证失败了。此处可以配置多个Realm，将按照相应的顺序及策略进行访问。



--shiro授权过程：访问控制，即应用中控制谁访问哪些资源；

							在用户认证通过后(注意只有当用户认证通过后才能对用户进行授权)，系统对用户访问资源进行控制，用户具有资源的访问权限方可访问。

	创建SecurityManager
	主体授权
	SecurityManager授权
	Authorizer授权
	Realm获取角色权限数据

	授权流程：
	1、对subject进行授权，调用方法isPermitted（"permission串"）

	2、SecurityManager执行授权，通过ModularRealmAuthorizer执行授权

	3、ModularRealmAuthorizer执行realm（自定义的Realm）从数据库查询权限数据

	调用realm的授权方法：doGetAuthorizationInfo

	4、realm从数据库查询权限数据，返回ModularRealmAuthorizer

	5、ModularRealmAuthorizer调用PermissionResolver进行权限串比对

	6、如果比对后，isPermitted中"permission串"在realm查询到权限数据中，说明用户访问permission串有权限，否则 没有权限，抛出异常。




--shiro的Realm：
		内置Realm
		---IniRealm：
		---JdbcRealm讲解：继承了AuthorizingRealm类；
		---自定义Realm：也要继承AuthorizingRealm类；

	Realm概念：
		在 Shiro 中存在 Realm 这么个概念， Realm 这个单词翻译为 域，其实是非常难以理解的。 
		域 是什么鬼？和权限有什么毛关系？ 这个单词Shiro的作者用的非常不好，让人很难理解。 

		那么 Realm 在 Shiro里到底扮演什么角色呢？ 
		当应用程序向 Shiro 提供了 账号和密码之后， Shiro 就会问 Realm 这个账号密码是否对， 如果对的话，其所对应的用户拥有哪些角色，哪些权限。 
		所以Realm 是什么？ 其实就是个中介。 Realm 得到了 Shiro 给的用户和密码后，有可能去找 ini 文件，就像Shiro 入门中的 shiro.ini，也可以去找数据库，就如同本知识点中的 DAO 查询信息。
		Realm 就是干这个用的，它才是真正进行用户认证和授权的关键地方。

		通过realm从数据库中查询用户信息，所以realm的作用可想而知:根据token中的身份信息去查询数据库（入门程序我们使用ini配置文件模拟数据库），如果查到用户则返回认证信息，如果查询不到就返回null。



--shiro加密：
	用户密码是明文的，这样是有巨大风险的，一旦泄露，就不好了。
	所以，通常都会采用非对称加密，什么是非对称呢？就是不可逆的，而 md5 就是这样一个算法.
	如代码所示 123 用 md5 加密后，得到字符串： 202CB962AC59075B964B07152D234B70
	这个字符串，却无法通过计算，反过来得到源密码是 123.
	这个加密后的字符串就存在数据库里了，下次用户再登陆，输入密码 123， 同样用md5 加密后，再和这个字符串一比较，就知道密码是否正确了。
	如此这样，既能保证用户密码校验的功能，又能保证不暴露密码。
	
	---盐：
	虽然每次 123 md5 之后都是202CB962AC59075B964B07152D234B70，但是 我加上盐，即 123+随机数，那么md5值不就不一样了吗？ 这个随机数，就是盐，而这个随机数也会在数据库里保存下来，每个不同的用户，随机数也是不一样的。
	再就是加密次数，加密一次是202CB962AC59075B964B07152D234B70，我可以加密两次呀，就是另一个数了。 而黑客即便是拿到了加密后的密码，如果不知道到底加密了多少次，也是很难办的。





--RBAC 概念：

	RBAC 是当下权限系统的设计基础，同时有两种解释：
	一： Role-Based Access Control，基于角色的访问控制，基于角色的访问控制是不利于系统维护(可扩展性不强)。
	即，你要能够删除产品，那么当前用户就必须拥有产品经理这个角色；


	二：Resource-Based Access Control，基于资源的访问控制，
	即，你要能够删除产品，那么当前用户就必须拥有删除产品这样的权限；

	基于 RBAC 概念， 就会存在3 张基础表： 用户，角色，权限， 以及 2 张中间表来建立 用户与角色的多对多关系，角色与权限的多对多关系。 用户与权限之间也是多对多关系，但是是通过 角色间接建立的。

	注： 补充多对多概念： 用户和角色是多对多，即表示：
	一个用户可以有多种角色，一个角色也可以赋予多个用户。 
	一个角色可以包含多种权限，一种权限也可以赋予多个角色。




--注解@RequirePermission，这种方式直观，哪里需要权限，哪里写就行。但是，真正项目开发的时候，这种方式就很有局限性了。
	当权限配置关系发生变化，每次都要修改代码，编译打包重启系统，这肯定是不能够被接受的。

	所以，最好的方式，还是通过动态配置，给不同的用户配置不同的角色，权限，修改之后立马生效这种方式。 为了实现这个效果，就需要基于URL配置权限的方式来做了。





	subject.login(token),这个方法是去判断用户密码是否正确的，我知道他会调用AuthorizingRealm子类里面的doGetAuthenticationInfo方法去校。
	但是我想知道login是如何走到这个方法的，并且AuthorizingRealm子类是如何配置成shiro的校验类的？