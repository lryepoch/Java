设计模式：

·设计模式主要是基于以下的面向对象设计原则：
	对接口编程而不是对实现编程。
	优先使用对象组合而不是继承。


·模式分类：
	··创建型模式->对象怎么来
	这些设计模式提供了一种在创建对象的同时隐藏创建逻辑的方式，而不是使用new运算符直接实例化对象。这使得程序在判断针对某个给定实例需要创建哪些对象时更加灵活。

	··结构型模式->对象和谁有关
	这些设计模式关注类和对象的组合。继承的概念被用来组合接口和定义组合对象获得新功能的方式。

	··行为型模式->对象与对象在干嘛
	这些设计模式特别关注对象之间的通信。

	··J2EE 模式->对象合起来要干嘛（表现层,文中表示层个人感觉用的不准确）java是面向对象的语言,所以要搞好对象,模式（套路）就是用来更加好的搞对象滴。
	这些设计模式特别关注表示层。这些模式是由 Sun Java Center 鉴定的。



设计模式的六大原则：
		开闭原则：实现热插拔，提高扩展性。
		里氏代换原则：实现抽象的规范，实现子父类互相替换；
		依赖倒转原则：针对接口编程，实现开闭原则的基础；
		接口隔离原则：降低耦合度，接口单独设计，互相隔离；
		迪米特法则，又称不知道原则：功能模块尽量独立；
		合成复用原则：尽量使用聚合，组合，而不是继承；


UML四种关系：
耦合度大小关系：泛化 = 实现 > 组合 > 聚合 > 关联 > 依赖

依赖：依赖关系在Java语言中体现为局域变量、方法的形参，或者对静态方法的调用。
			Driver的drive方法只有传入了一个Car对象才能发挥作用，因此我们说Driver类依赖于Car类。
关联：它使一个类知道另一个类的属性和方法。关联可以是双向的，也可以是单向的。在Java语言中，关联关系一般使用成员变量来实现。包括单向关联、双向关联和自关联。

聚合：是关联关系的一种，是强的关联关系。聚合是整体和个体之间的关系，但个体可以脱离整体而存在。与关联关系一样，聚合关系也是通过成员变量实现的。但是关联关系所涉及的两个类是处在同一层次上的，而在聚合关系中，两个类是处在不平等层次上的，一个代表整体，另一个代表部分。聚合关系强调是“整体”包含“部分”，但是“部分”可以脱离“整体”而单独存在。

组合：是关联关系的一种，是比聚合关系强的关系，也以成员变量的形式出现。在某一个时刻，部分对象只能和一个整体对象发生组合关系，由后者排他地负责生命周期。部分和整体的生命周期一样。整体可以将部分传递给另一个对象，这时候该部分的生命周期由新整体控制，然后旧整体可以死亡。这里的“部分”脱离了“整体”便不复存在。

继承：实线+空心三角形；
实现：虚线+空心三角形；


----------------------
创建型：5

·单例模式：一个类只有一个实例，并提供一个全局访问点（方法）。

·简单工厂模式：一个工厂类根据传入的参数，动态决定创建哪一级产品的类实例，被创建的实例具有共同的父类。

·工厂方法模式：把简单工厂中具体的工厂类划分成2层：抽象工厂层+具体工厂子类层。
	       【工厂方法模式丰富了框架的更多情况，当增加选择时，不像简单工厂，这个不用修改原有代码而是直		 	 接新建工厂，工厂方法式优于简单工厂模式】

·抽象工厂模式：不同于工厂方法模式的单产品系，抽象工厂是多产品系的。

·原型模式：

·生成器模式：


结构型：7

·代理模式：动态代理和静态代理；

·装饰者模式：

·适配器模式：

·组合模式：

·享元模式：java自动装箱和拆箱。

·桥接模式：

·外观模式：


·结构型模式是描述如何将类对象结合在一起，形成一个更大的结构，结构模式描述两种不同的东西：类与类的实例。故可以分为类结构模式和对象结构模式。
	在GoF设计模式中，结构型模式有：
	1.适配器模式 Adapter
		  		适配器模式是将一个类的接口转换成客户希望的另外一个接口。适配器模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。
		  		两个成熟的类需要通信，但是接口不同，由于开闭原则，我们不能去修改这两个类的接口，所以就需要一个适配器来完成衔接过程。
	2.桥接模式 Bridge
			  桥接模式将抽象部分与它的实现部分分离，是它们都可以独立地变化。它很好的支持了开闭原则和组合锯和复用原则。实现系统可能有多角度分类，
			  每一种分类都有可能变化，那么就把这些多角度分离出来让他们独立变化，减少他们之间的耦合。
				定义 ：将抽象部分与它的实现部分分离，使它们都可以独立地变化。
				意图 ：将抽象与实现解耦。
				桥接模式所涉及的角色 
				1.  Abstraction ：定义抽象接口，拥有一个Implementor类型的对象引用 
				2.  RefinedAbstraction ：扩展Abstraction中的接口定义 
				3.  Implementor ：是具体实现的接口，Implementor和RefinedAbstraction接口并不一定完全一致，实际上这两个接口可以完全不一样Implementor提供具体操
				作方法，而Abstraction提供更高层次的调用 
				4.  ConcreteImplementor ：实现Implementor接口，给出具体实现
				Jdk中的桥接模式：JDBC 
				JDBC连接 数据库 的时候，在各个数据库之间进行切换，基本不需要动太多的代码，甚至丝毫不动，原因就是JDBC提供了统一接口，每个数据库提供各自的实现，
				用一个叫做数据库驱动的程序来桥接就行了。
	3.组合模式 Composite
	  		组合模式将对象组合成树形结构以表示部分-整体的层次结构，组合模式使得用户对单个对象和组合对象的使用具有一致性。
	4.装饰模式 Decorator
			装饰模式动态地给一个对象添加一些额外的职责，就增加功能来说，它比生成子类更灵活。也可以这样说，装饰模式把复杂类中的核心职责和装饰功
			能区分开了，这样既简化了复杂类，有去除了相关类中重复的装饰逻辑。 装饰模式没有通过继承原有类来扩展功能，但却达到了一样的目的，而且比
			继承更加灵活，所以可以说装饰模式是继承关系的一种替代方案。
	5.外观模式 Facade
			 外观模式为子系统中的一组接口提供了同意的界面，外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。
			外观模式中，客户对各个具体的子系统是不了解的，所以对这些子系统进行了封装，对外只提供了用户所明白的单一而简单的接口，用户直接使用这
			个接口就可以完成操作，而不用去理睬具体的过程，而且子系统的变化不会影响到用户，这样就做到了信息隐蔽。
	6.享元模式 Flyweight
			 享元模式为运用共享技术有效的支持大量细粒度的对象。因为它可以通过共享大幅度地减少单个实例的数目，避免了大量非常相似类的开销。.
			      享元模式是一个类别的多个对象共享这个类别的一个对象，而不是各自再实例化各自的对象。这样就达到了节省内存的目的。
	7.代理模式 Proxy   
			为其他对象提供一种代理，并由代理对象控制对原对象的引用，以间接控制对原对象的访问。




行为型：11

·观察者模式：一个对象的状态发生变化，所有依赖于它的对象都得到通知并被自动更新。
	     【被观察者：注册（用到集合类）、更新（setter和getter）、发通知（调用观察者的更新方法）】

·策略模式：子类实现接口的方法，并且都有各自不同的实现，这些子类弱耦合、互相独立的。

·命令模式：

·迭代器模式：

·模板方法模式：

·责任链模式：

·访问者模式：

·中介者模式：

·备忘录模式：

·状态模式：

·解释器模式：


--------------------------
重点：

·MVC模式：

		MVC 模式代表 Model-View-Controller（模型-视图-控制器） 模式。这种模式用于应用程序的分层开发。

		Model（模型） - 模型代表一个存取数据的对象或JAVA POJO。它也可以带有逻辑，在数据变化时更新控制器。
		View（视图） - 视图代表模型包含的数据的可视化。
		Controller（控制器） - 控制器作用于模型和视图上。它控制数据流向模型对象，并在数据变化时更新视图。使视图与模型分离开。

		MVC要实现的目标是将软件用户界面和业务逻辑分离以使代码可扩展性、可复用性、可维护性、灵活性加强。



·单例模式
		概念：保证一个类仅有一个实例，并提供一个访问它的全局访问点。避免了频繁地创建和销毁对象而带来性能的损耗；

		应用场景：
	　　（1）资源共享的情况下，避免由于资源操作时导致的性能或损耗等。如上述中的日志文件，应用配置。
	　　（2）控制资源的情况下，方便资源之间的互相通信。如数据库连接池，多线程线程池，Windows任务管理器。
	    （3）实际上，配置信息类、管理类、控制类、门面类、代理类。通常被设计为单例类，像Java的Struts、Spring框架，.Net的Spring.Net框架，以及Php的Zend框架都大量使用了单例模式。

		举例：1.Spring容器中使用的注册表式实现的单例模式，简单来说，就是使用同一个工具类，管理多个不同类的实例创建，每次只需在工具类中注册该类，即可获得该类的实例。
　　    	2.像我们在搭建heibernate框架时，是sessionFactory创建session，session对象操作数据库的。当多个线程共享session时就会出现数据安全问题，因此企业开发中，我们不会把它设计成单例模式。
		

		·饿汉式：线程安全；但是类加载时就初始化，浪费内存。

		·懒汉式：线程不安全；因为没有加锁 synchronized，所以严格意义上它并不算单例模式。

		·懒汉式改进1：lazy loading，能够在多线程中很好的工作，但是，效率很低；


		·懒汉式改进2：增加一个静态内部类，在这个静态内部类中创建外部类的实例，这个内部类和外部类并没有绑定的关系，而且只有被调用到才会装载，从而也可以实现了延迟加载。线程安全。


		·双检锁：线程安全且在多线程情况下能保持高性能。
						类加载时申明对象,  volatile解决多线程共享变量下及时感知变量的最新状态。 

			  问题：为什么必须要加volatile，主要用来避免重排序问题导致其他的线程看到了一个已经分配内存和地址但没有初始化的对象，也就是说这个对象还不是处于可用状态，但是就被其他线程引用了。

						双重检验锁是对同步块加锁的方法。为什么会称为双重检验，因为有两次对instance == null的检查，一次在同步块中/一次在同步块外部。

						对于两次instance是否为空的判断解释：
						1.第一次判断：
						       为了提高性能！！！
						       如果去掉这次的判断，直接运行synchronized，会使每个线程进入getInstance()都会得到一个静态内部锁。这样的话，锁的获得以及释放的开销（包括上下文切换，内存同步等）都不可避免，降低了效率。所以在synchronized前面加一次判断是否为空，则会大大减少synchronized同步块的执行次数。

						2.第二次判断：
								为了线程安全！！！
								因为可能会有多个线程一起进入同步块外的 if，如果在同步块内不进行二次检验的话就会生成多个实例。



							//饿汉式
							public class Singleton{
								private Singleton(){

								}
								private static Singleton singleton=new Singleton();
								public static Singleton getInstance(){
									return singleton;
								}
							}

							//懒汉式
							public class Singleton{
								private Singleton(){

								}
								private static Singleton singleton;
								public static Singleton getInstance(){
									if(singleton==null)
										instance=new Singleton();
									 return singleton;
								}
							}

							//懒汉式改进1
							public class Singleton{
								private Singleton(){

								}
								private static Singleton singleton;

								private static Singleton getInstance(){
									if(singleton==null)
										singleton = new Singleton();
									return singleton;
								}
							}


							//静态内部类
							public class Singleton{
								private Singleton(){

								}

								private static class SingletonH{
									private static final Singleton singleton=new Singleton();
								}

								public static final Singleton getInstance(){
									//静态内部类调用其成员属性
									return SingletonH.singleton;
								}
							}


							//双检锁
							public class Singleton{
								private Singleton(){

								}
								private volatile static Singleton singleton;
								public static Singleton getInstance(){
									if(instance==null){
										synchronized(Singleton.class){
											if (instance==null) {
												singleton= new Singleton();
											}
										}
									}
									return singleton;
								}
							}



·工厂模式：
		·简单工厂模式：
				·举例：一个鼠标工厂，根据参数决定生产戴尔鼠标还是惠普鼠标，Dell鼠标和Acer鼠标都继承自鼠标类；

				·说明：由一个工厂类根据传入的参数，动态决定应该创建出哪一个类的实例，被创建的实例通常具有共同的父类；
							简单工厂模式不是 23 种设计模式里的一种，简而言之，就是有一个专门生产某个产品的类。
				


		·工厂方法模式：
				·举例：鼠标工厂是个父类，有生产鼠标这个接口；戴尔鼠标工厂，惠普鼠标工厂继承它，可以分别生产戴尔鼠标，惠普鼠标；生产哪种鼠标不再由参数决定，而是在创建鼠标工厂时，由工厂创建；

				·说明：定义一个创建对象的接口，让其子类自己决定实例化哪一个工厂类，工厂模式使其创建过程延迟到子类进行。
							将对象的创建和使用相分离，采用工厂模式，即应用程序将对象的创建及初始化职责交给工厂对象。

				·包含：抽象工厂，具体工厂，抽象产品，具体产品。

				·使用场景： 
				1、日志记录器：记录可能记录到本地硬盘、系统事件、远程服务器等，用户可以选择记录日志到什么地方。 2、数据库访问，当用户不知道最后系统采用哪一类数据库，以及数据库可能有变化时。 3、设计一个连接服务器的框架，需要三个协议，"POP3"、"IMAP"、"HTTP"，可以把这三个作为产品类，共同实现一个接口。



		·抽象工厂模式：
				·举例：PC厂商是个父类，有生产鼠标，生产键盘两个接口；戴尔工厂，惠普工厂继承它，可以分别生产戴尔鼠标+戴尔键盘和惠普鼠标+惠普键盘；创建工厂时，如果决定戴尔工厂创建，那么，后							续工厂.生产鼠标()则生产戴尔鼠标，工厂.生产键盘()则生产戴尔键盘。

				·说明：与工厂方法模式不同的是，工厂方法模式中的工厂只生产单一的产品，而抽象工厂模式中的工厂生产多个产品。
								所以，当产品只有一个的时候，抽象工厂变成了工厂方法；当产品有多个的时候，工厂方法变成了抽象工厂。
				
				·使用场景： 1、QQ 换皮肤，一整套一起换（帽子、衣服等）。 2、生成不同操作系统的程序。

-------------------

·观察者模式
		·定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。
		·关键代码：在抽象类里有一个 ArrayList 存放观察者们。
		·应用实例： 1、拍卖的时候，拍卖师观察最高标价，然后通知给其他竞价者竞价。
		·注意事项： 1、JAVA 中已经有了对观察者模式的支持类。 2、避免循环引用。 3、如果顺序执行，某一观察者错误会导致系统卡壳，一般采用异步方式。
		·步骤：
			··观察者们实现同一个接口或者抽象类；
			··观察者们在被观察者那里注册，即添加到ArrayList集合中；
			··被观察者发通知给观察者们；
		·使用场景：
				一个抽象模型有两个方面，其中一个方面依赖于另一个方面。将这些方面封装在独立的对象中使它们可以各自独立地改变和复用。
				一个对象的改变将导致其他一个或多个对象也发生改变，而不知道具体有多少对象将发生改变，可以降低对象之间的耦合度。
				一个对象必须通知其他对象，而并不知道这些对象是谁。
				需要在系统中创建一个触发链，A对象的行为将影响B对象，B对象的行为将影响C对象……，可以使用观察者模式创建一种链式触发机制。



·策略模式
		·定义一系列算法，把他们封装起来，并且使它们可以相互替换。
		·何时使用：一个系统有许多许多类，而区分它们的只是他们直接的行为。
		·主要解决：在有多种算法相似的情况下，使用 if...else 所带来的复杂和难以维护。
		·关键代码：实现同一个接口。
		·应用实例： 1、诸葛亮的锦囊妙计，每一个锦囊就是一个策略。 2、旅行的出游方式，选择骑自行车、坐汽车，每一种旅行方式都是一个策略。 3、JAVA AWT 中的 LayoutManager。
		·优点： 1、算法可以自由切换。 2、避免使用多重条件判断。 3、扩展性良好。
		·缺点： 1、策略类会增多。 2、所有策略类都需要对外暴露。

		·使用场景： 1、如果在一个系统里面有许多类，它们之间的区别仅在于它们的行为，那么使用策略模式可以动态地让一个对象在许多行为中选择一种行为。 2、一个系统需要动态地在几种算法中选择一种。 3、如果一个对象有很多的行为，如果不用恰当的模式，这些行为就只好使用多重的条件选择语句来实现。



---------------------

·原型模式
		·用于创建重复的对象，同时又能保证性能。
		·实现了一个原型接口，该接口用于创建当前对象的克隆。当直接创建对象的代价比较大时，则采用这种模式。
		·主要解决：在运行期建立和删除原型。
		·如何解决：利用已有的一个原型对象，快速地生成和原型对象一样的实例。
		·关键代码：实现克隆操作，在 JAVA 继承 Cloneable，重写 clone()。
		·使用场景：在实际项目中，原型模式很少单独出现，一般是和工厂方法模式一起出现，通过 clone 的方法创建一个对象，然后由工厂方法提供给调用者。原型模式已经与Java融为浑然一体，大家可以随手拿来使用。
		·模式总结：
					      1、原型模式向客户隐藏了创建对象的复杂性。客户只需要知道要创建对象的类型，然后通过请求就可以获得和该对象一模一样的新对象，无须知道具体的创建过程。
					      2、克隆分为浅克隆和深克隆两种。
					      3、我们虽然可以利用原型模式来获得一个新对象，但有时对象的复制可能会相当的复杂，比如深克隆。
		·例子中也使用到了Java集合类。
		·使用场景： 1、资源优化场景。 2、类初始化需要消化非常多的资源，这个资源包括数据、硬件资源等。 3、性能和安全要求的场景。 4、通过 new 产生一个对象需要非常繁琐的数据准备或访问权限，则可以使用原型模式。 5、一个对象多个修改者的场景。 6、一个对象需要提供给其他对象访问，而且各个调用者可能都需要修改其值时，可以考虑使用原型模式拷贝多个对象供调用者使用。 7、在实际项目中，原型模式很少单独出现，一般是和工厂方法模式一起出现，通过 clone 的方法创建一个对象，然后由工厂方法提供给调用者。原型模式已经与 Java 融为浑然一体，大家可以随手拿来使用。



·享元模式
		·运用共享技术有效地支持大量细粒度的对象。
		·重用现有的同类对象；
		·主要用于减少创建对象的数量，以减少内存占用和提高性能。
		·尝试重用现有的同类对象，如果未找到匹配的对象，则创建新对象。
		·关键代码：用 HashMap 存储这些对象。
		·使用场景： 1、系统有大量相似对象。 2、需要缓冲池的场景。
		·注意事项： 1、注意划分外部状态和内部状态，否则可能会引起线程安全问题。
							 2、这些类必须有一个工厂对象加以控制。
		·在JAVA语言中，String类型就是使用了享元模式。String对象是final类型，对象一旦创建就不可改变。在JAVA中字符串常量 都是存在常量池中的，JAVA会确保一个字符串常量在常量池中只有一个拷贝。







