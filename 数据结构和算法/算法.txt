
-----------------------
·关于算法：
	曾经问过百度的一位面试官，为什么你们面试都喜欢考算法？
	回答是：“首先，算法是一种通用的考察点，不管哪个技术岗都可以进行考察；
			其次，算法包含了太多的逻辑思维，可以考察应聘者思考问题的逻辑和解决问题的能力；
			最后，连这么有难度的算法题你都可以搞定，那么其他只需要看看写写用用就可以掌握的基础知识和相关技术框架还怕学不会吗？”
	所以说，我认为算法的重要性相当高。

	画图，将有助于我们解决问题。


·程序=算法+数据结构。
	程序：在数据结构的基础上设计和选择算法。
	算法：实现某种操作。算法总是依赖于某种数据结构而实现的。算法的本质就是模拟数学规律。
	数据结构：静态描述数据之间的关系。




【查找】：线性表查找【顺序查找、折半查找(二分查找)、分块查找(包含顺序查找和折半查找)】；树结构查找；散列表查找；
【排序】：8大排序；
【搜索】：深度优先搜索；广度优先搜索；

【高级算法】：递归、动态规划、分治法、贪心算法、（树、链表、数组、字符串……）
-------------------------

·递归和迭代对比：
	··递归和迭代都是循环的一种。

	··简单地说，递归是重复调用函数自身实现循环。迭代是函数内某段代码实现循环，而迭代与普通循环的区别是：循环代码中参与运算的变量同时是保存结果的变量，当前保存的结果作为下一次循环计算的初始值。

	··递归循环中，遇到满足终止条件的情况时逐层返回来结束。迭代则使用计数器结束循环。当然很多情况都是多种循环混合采用，这要根据具体需求。




·动态规划：


·分治法：


·贪心算法：



·背包问题：




·其它：
----------------------
·KMP算法：字符串匹配算法；
	kmp算法：
		１后移， 直到字符串有一个字符，与搜索词的第一个字符相同为止．
		２接着比较字符串和搜索词的下一个字符，直到字符串有一个字符，与搜索词对应的字符不相同为止
		３根据部分匹配表，移动位数 = 已匹配的字符数 - 对应的部分匹配值
		４ 逐位比较，直到搜索词的最后一位


·LRU算法：
	··背景：
		达到这样一种情形的算法是最理想的：每次调换出的页面是所有内存页面中最迟将被使用的；这可以最大限度的推迟页面调换，这种算法，被称为理想页面置换算法。可惜的是，这种算法是无法实现的。 
		为了尽量减少与理想算法的差距，产生了各种精妙的算法，最近最少使用页面置换算法便是其中一个。

	··概念：
		···LRU（Least recently used，最近最少使用）算法根据数据的历史访问记录来进行淘汰数据，其核心思想是“如果数据最近被访问过，那么将来被访问的几率也很高”，反过来说“如果数据最近这段时间一直都没有访问,那么将来被访问的概率也会很低”，两种理解是一样的；常用于页面置换算法，是为虚拟页式存储管理服务的。这个，就是著名的局部性原理——比内存速度还要快的cache，也是基于同样的原理运行的。因此，我们只需要在每次调换时，找到最近最少使用的那个页面调出内存。
		···也就是说，当限定的空间已存满数据时，应当把最久没有被访问到的数据淘汰。

	··为什么需要页面置换算法？
				内存是有限的，不可能把所有的页面都装进来 
				– 缺页时需要进行页面置换

				页面置换的背后是个通用的问题 
				–Web服务器的缓存 
				–Redis ，memcached 的缓存 
				–……
	··为什么不用 （先进先出） 
		使用 FIFO （先进先出） 实现页面置换算法：很明显， 按照FIFO算法， 虽然一个页面被频繁访问， 它还是很有可能被置换出去。
	··两种策略：
		LRU（Least Recently Used 最近最少使用）算法有两种策略(均以队列的方式实现)，一种是不调整的，另外一种是随时进行调整的，即缓存命中后，将这个数据缓存项移到LRU队列的最前端。

	··实现LRU
     
		1.用一个数组来存储数据，给每一个数据项标记一个访问时间戳，每次插入新数据项的时候，先把数组中存在的数据项的时间戳自增，并将新数据项的时间戳置为0并插入到数组中。每次访问数组中的数据项的时候，将被访问的数据项的时间戳置为0。当数组空间已满时，将时间戳最大的数据项淘汰。

		2.利用一个链表来实现，每次新插入数据的时候将新数据插到链表的头部；每次缓存命中（即数据被访问），则将数据移到链表头部；那么当链表满的时候，就将链表尾部的数据丢弃。

		3.利用链表和hashmap。当需要插入新的数据项的时候，如果新数据项在链表中存在（一般称为命中），则把该节点移到链表头部，如果不存在，则新建一个节点，放到链表头部，若缓存满了，则把链表最后一个节点删除即可。在访问数据的时候，如果数据项在链表中存在，则把该节点移到链表头部，否则返回-1。这样一来在链表尾部的节点就是最近最久未访问的数据项。

		对于第一种方法，需要不停地维护数据项的访问时间戳，另外，在插入数据、删除数据以及访问数据时，时间复杂度都是O(n)。对于第二种方法，链表在定位数据的时候时间复杂度为O(n)。所以在一般使用第三种方式来是实现LRU算法。
		
		具体如下：
		使用LinkedHashMap实现：
		     LinkedHashMap底层就是用的HashMap加双链表实现的，而且本身已经实现了按照访问顺序的存储。当某个位置被命中，通过调整链表的指向将该位置调整到头位置，新加入的内容直接放在链表头，如此一来，最近被命中的内容就向链表头移动，需要替换时，链表最后的位置就是最近最少使用的位置。此外，LinkedHashMap中本身就实现了一个方法removeEldestEntry用于判断是否需要移除最不常读取的数，方法默认是直接返回false，不会移除元素，所以需要重写该方法。即当缓存满后就移除最不常用的数。我们使用LinkedHashMap实现LRU缓存的方法就是对LinkedHashMap实现简单的扩展。
			    
			public class LRU<K,V> {
			 
			  private static final float hashLoadFactory = 0.75f;
			  private LinkedHashMap<K,V> map;
			  private int cacheSize;
			 
			  public LRU(int cacheSize) {
			    this.cacheSize = cacheSize;
			    int capacity = (int)Math.ceil(cacheSize / hashLoadFactory) + 1;
			    map = new LinkedHashMap<K,V>(capacity, hashLoadFactory, true){
			      private static final long serialVersionUID = 1;
			 
			      @Override
			      protected boolean removeEldestEntry(Map.Entry eldest) {
			        return size() > LRU.this.cacheSize;
			      }
			    };
			  }
			 
			  public synchronized V get(K key) {
			    return map.get(key);
			  }
			 
			  public synchronized void put(K key, V value) {
			    map.put(key, value);
			  }
			 
			  public synchronized void clear() {
			    map.clear();
			  }
			 
			  public synchronized int usedSize() {
			    return map.size();
			  }
			 
			  public void print() {
			    for (Map.Entry<K, V> entry : map.entrySet()) {
			      System.out.print(entry.getValue() + "--");
			    }
			    System.out.println();
			  }
			}

