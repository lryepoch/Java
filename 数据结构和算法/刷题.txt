

--------------------
字符串

·对字符串的操作可以归结为以下几类：
	字符串的比较、连接操作（不同编程语言实现方式有所不同）；
	涉及子串的操作，比如前缀，后缀等；
	字符串间的匹配操作，如 KMP 算法、BM 算法等。






数组

·用来处理常见的排序和二分搜索问题，典型的处理技巧包括对撞指针、滑动窗口等。

	双指针：左指针指向当前已经处理好的序列的尾部，右指针指向待处理序列的头部。右指针不断向右移动，每次右指针指向非零数，则将左右指针对应的数交换，同时左指针右移。
	对撞指针：
	滑动窗口：






链表

·链表有很多种不同的类型：单向链表，双向链表以及循环链表。
·通常可以衍生出循环链表，静态链表，双链表等。对于链表使用，需要注意头结点的使用。







栈

·栈的基本操作除了在栈顶进行插入和删除外，还有栈的初始化，判空以及取栈顶元素等。
·LIFO
·DFS







队列

·队列常用的方法有：add、remove、element、offer、poll、peek、put、take。
·FIFO
·BFS









树

·理解和区分树的遍历方法

	当你删除树中的节点时，删除过程将按照后序遍历的顺序进行。 也就是说，当你删除一个节点时，你将首先删除它的左节点和它的右边的节点，然后再删除节点本身。

	另外，后序在数学表达中被广泛使用。编写程序来解析后缀表示法更为容易。

	您可以使用中序遍历轻松找出原始表达式。 但是程序处理这个表达式时并不容易，因为你必须检查操作的优先级。

	如果你想对这棵树进行后序遍历，使用栈来处理表达式会变得更加容易。 每遇到一个操作符，就可以从栈中弹出栈顶的两个元素，计算并将结果返回到栈中。

	public class TreeNode{
		int val;
		TreeNode left;
		TreeNode right;
		TreeNode() {}
		TreeNode(int val) {	this.val=val;	}
		TreeNode(int val, TreeNode left, TreeNode right) {
			this.val=val;
			this.left=left;
			this.right=right;
		}
	}


·能够运用递归方法解决树的为前序遍历、中序遍历和后序遍历问题：
	前序遍历，时间复杂度：O(n)，空间复杂度：最坏是O(n)，平均是O(logN)【n是节点个数】
	中序遍历，时间复杂度：O(n)，空间复杂度：O(logN)【n是节点个数】
	后序遍历，时间复杂度：O(n)，空间复杂度：最坏是O(n)，平均是O(logN)【n是节点个数】


	许多树问题可以通过递归的方式来解决。对于每个递归层级，我们只能关注单个节点内的问题，并通过递归调用函数来解决其子节点问题。
	
	通常，我们可以通过 “自顶向下” 或 “自底向上” 的递归来解决树问题。
	
	 “自顶向下” 的解决方案可以被认为是一种前序遍历。
	 “自底向上” 是另一种递归方法。在每个递归层次上，我们首先对所有子节点递归地调用函数，然后根据返回值和根节点本身的值得到答案。这个过程可以看作是后序遍历的一种。

	当遇到树问题时，请先思考一下两个问题：

		你能确定一些参数，从该节点自身解决出发寻找答案吗？
		你可以使用这些参数和节点本身的值来决定什么应该是传递给它子节点的参数吗？
		如果答案都是肯定的，那么请尝试使用 “自顶向下” 的递归来解决此问题。

		或者你可以这样思考：对于树中的任意一个节点，如果你知道它子节点的答案，你能计算出该节点的答案吗？ 
		如果答案是肯定的，那么 “自底向上” 的递归可能是一个不错的解决方法。



·能用运用迭代方法解决树的为前序遍历、中序遍历和后序遍历问题：
	前序遍历，显式调用栈，进栈前加入到集合中
	中序遍历，显式调用栈，出栈时加入到集合中
	后序遍历，显式调用栈，出栈时加入到集合中，进栈方式跟中序遍历不同；





·能用运用广度优先搜索解决树的层序遍历问题：

	层序遍历就是逐层遍历树结构。

	广度优先搜索是一种广泛运用在树或图这类数据结构中，遍历或搜索的算法。该算法从一个根节点开始，首先访问节点本身。然后遍历它的相邻节点，其次遍历它的二级邻节点、三级邻节点，以此类推。

	当我们在树中进行广度优先搜索时，我们访问的节点的顺序是按照层序遍历顺序的。通常，我们使用队列来帮助我们做广度优先搜索。



图









---------------------
递归

迭代




动态规划




分治法





深度优先

	DFS（深度优先搜索）和 BFS（广度优先搜索）就像孪生兄弟，提到一个总是想起另一个。然而在实际使用中，我们用 DFS 的时候远远多于 BFS。那么，是不是 BFS 就没有什么用呢？

	如果我们使用 DFS/BFS 只是为了遍历一棵树、一张图上的所有结点的话，那么 DFS 和 BFS 的能力没什么差别，我们当然更倾向于更方便写、空间复杂度更低的 DFS 遍历。不过，某些使用场景是 DFS 做不到的，只能使用 BFS 遍历。这就是本文要介绍的两个场景：「层序遍历」、「最短路径」。






广度优先

	通常，我们使用队列来帮助我们做广度优先搜索。

