

--------------------
字符串

·对字符串的操作可以归结为以下几类：
	字符串的比较、连接操作；
	涉及子串的操作，比如前缀，后缀等；
	字符串间的匹配操作，如 KMP算法、BM算法等。

最长公共前缀
最长回文子串




数组

·用来处理常见的排序和二分搜索问题，典型的处理技巧包括对撞指针、滑动窗口等。

	双指针：左指针指向当前已经处理好的序列的尾部，右指针指向待处理序列的头部。右指针不断向右移动，每次右指针指向非零数，则将左右指针对应的数交换，同时左指针右移。

	对撞指针：

	滑动窗口：






链表

·链表有很多种不同的类型：单向链表，双向链表以及循环链表。
·通常可以衍生出循环链表，静态链表，双链表等。对于链表使用，需要注意头结点的使用。







栈

·栈的基本操作除了在栈顶进行插入和删除外，还有栈的初始化，判空以及取栈顶元素等。
·LIFO
·DFS
·数组和单链表

·单调栈





队列

·队列常用的方法有：add、remove、element、offer、poll、peek、put、take。
·FIFO
·BFS
·数组和单链表

·循环队列








树

·理解和区分树的遍历方法

	当你删除树中的节点时，删除过程将按照后序遍历的顺序进行。 也就是说，当你删除一个节点时，你将首先删除它的左节点和它的右边的节点，然后再删除节点本身。

	另外，后序在数学表达中被广泛使用。编写程序来解析后缀表示法更为容易。

	您可以使用中序遍历轻松找出原始表达式。 但是程序处理这个表达式时并不容易，因为你必须检查操作的优先级。

	如果你想对这棵树进行后序遍历，使用栈来处理表达式会变得更加容易。 每遇到一个操作符，就可以从栈中弹出栈顶的两个元素，计算并将结果返回到栈中。

	public class TreeNode{
		int val;
		TreeNode left;
		TreeNode right;
		TreeNode() {}
		TreeNode(int val) {	this.val=val;	}
		TreeNode(int val, TreeNode left, TreeNode right) {
			this.val=val;
			this.left=left;
			this.right=right;
		}
	}


·能够运用递归方法解决树的为前序遍历、中序遍历和后序遍历问题：
	前序遍历，时间复杂度：O(n)，空间复杂度：最坏是O(n)，平均是O(logN)【n是节点个数】
	中序遍历，时间复杂度：O(n)，空间复杂度：O(logN)【n是节点个数】
	后序遍历，时间复杂度：O(n)，空间复杂度：最坏是O(n)，平均是O(logN)【n是节点个数】


	许多树问题可以通过递归的方式来解决。对于每个递归层级，我们只能关注单个节点内的问题，并通过递归调用函数来解决其子节点问题。
	
	通常，我们可以通过 “自顶向下” 或 “自底向上” 的递归来解决树问题。
	
	 “自顶向下” 的解决方案可以被认为是一种前序遍历。
	 “自底向上” 是另一种递归方法。在每个递归层次上，我们首先对所有子节点递归地调用函数，然后根据返回值和根节点本身的值得到答案。这个过程可以看作是后序遍历的一种。

	当遇到树问题时，请先思考一下两个问题：

		你能确定一些参数，从该节点自身解决出发寻找答案吗？
		你可以使用这些参数和节点本身的值来决定什么应该是传递给它子节点的参数吗？
		如果答案都是肯定的，那么请尝试使用 “自顶向下” 的递归来解决此问题。

		或者你可以这样思考：对于树中的任意一个节点，如果你知道它子节点的答案，你能计算出该节点的答案吗？ 
		如果答案是肯定的，那么 “自底向上” 的递归可能是一个不错的解决方法。



·能用运用迭代方法解决树的为前序遍历、中序遍历和后序遍历问题：
	前序遍历，显式调用栈，进栈前加入到集合中
	中序遍历，显式调用栈，出栈时加入到集合中
	后序遍历，显式调用栈，出栈时加入到集合中，进栈方式跟中序遍历不同；





·能用运用广度优先搜索解决树的层序遍历问题：

	层序遍历就是逐层遍历树结构。

	广度优先搜索是一种广泛运用在树或图这类数据结构中，遍历或搜索的算法。该算法从一个根节点开始，首先访问节点本身。然后遍历它的相邻节点，其次遍历它的二级邻节点、三级邻节点，以此类推。

	当我们在树中进行广度优先搜索时，我们访问的节点的顺序是按照层序遍历顺序的。通常，我们使用队列来帮助我们做广度优先搜索。



图









---------------------
迭代


递归



动态规划：DP
背景：
	通过把原问题分解为相对简单的子问题的方式求解复杂问题的方法。
	动态规划常常适用于有重叠子问题和最优子结构性质的问题，动态规划方法所耗时间往往远少于朴素解法。
	最优子结构规定的是子问题与原问题的关系
	重复子问题规定的是子问题与子问题的关系。

	动态规划往往用于优化递归问题。

思考过程：
	考虑能否将问题规模减小；
	数组上常用的两种思路：1.每次减少一半；2.每次减少一个；

	解决动态规划问题最难的地方有两点：
		如何定义f(n)
		如何通过f(1), f(2), … f(n−1) 推导出f(n)，即状态转移方程

	1. 递归。有了状态转移方程，实际上已经可以直接用递归进行实现了。
	2. 自顶向下（记忆化）
	递归的解法需要非常多的重复计算，如果有一种办法能避免这些重复计算，可以节省大量计算时间。记忆化就是基于这个思路的算法。在递归地求解子问题 f(1)f(1), f(2)f(2)... 过程中，将结果保存到一个表里，在后续求解子问题中如果遇到求过结果的子问题，直接查表去得到答案而不计算。

	3. 自底向上（迭代）
	有了状态转移方程，我们就知道如何从最小的问题规模入手，然后不断地增加问题规模，直到所要求的问题规模为止。在这个过程中，我们同样地可以记忆每个问题规模的解来避免重复的计算。这种方法就是自底向上的方法，由于避免了递归，这是一种更好的办法。
	但是迭代法需要有一个明确的迭代方向，例如线性，区间，树形，状态压缩等比较主流的动态规划问题中，迭代方向都有相应的模式。


分治法：把一个复杂的问题分成两个或更多的相同或相似的子问题，直到最后子问题可以简单的直接求解，原问题的解即子问题的解的合并。

	分治法与动态规划主要共同点：
	二者都要求原问题具有最优子结构性质，都是将原问题分而治之，分解成若干个规模较小(小到很容易解决的程序)的子问题。然后将子问题的解合并，形成原问题的解。

	分治法与动态规划实现方法：
	① 分治法通常利用递归求解。
	② 动态规划通常利用迭代法自底向上求解，但也能用具有记忆功能的递归法自顶向下求解。

	分治法与动态规划主要区别：
	① 分治法将分解后的子问题看成相互独立的。
	② 动态规划将分解后的子问题理解为相互间有联系，有重叠部分。



深度优先

	DFS（深度优先搜索）和 BFS（广度优先搜索）就像孪生兄弟，提到一个总是想起另一个。然而在实际使用中，我们用 DFS 的时候远远多于 BFS。那么，是不是 BFS 就没有什么用呢？

	如果我们使用 DFS/BFS 只是为了遍历一棵树、一张图上的所有结点的话，那么 DFS 和 BFS 的能力没什么差别，我们当然更倾向于更方便写、空间复杂度更低的 DFS 遍历。不过，某些使用场景是 DFS 做不到的，只能使用 BFS 遍历。这就是本文要介绍的两个场景：「层序遍历」、「最短路径」。






广度优先

	通常，我们使用队列来帮助我们做广度优先搜索。

