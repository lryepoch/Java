
-------------------
·结构分类：
	逻辑结构：集合、线性、树形、图形
	存储结构：顺序、链式



·数据结构：
	【字符串】

	【线性表】
	  【数组】
	  【链表】
	  【栈】
	  【队列】

	【树】
		1).树
		2).二叉树基本概念…
		3).二叉查找树
		4).平衡二叉树
		5).红黑树

	【图】
		1).深度优先算法；
		2).广度优先算法；
		3).最小生成树；

	【散列表】

	【堆】：实际上是一颗 完全二叉树，但是它还满足父结点大于（或小于）子结点特性。大根堆、小根堆··>堆排序。





--------------------
【字符串】：
	题型：在字符串的考察中，比较经典的是自定义一个函数实现字符串转整数的功能；
		加大难度之后，会考察以下常见的5种关于字符串中“最长”问题：
		最长公共子序列
		最长公共子串
		最长递增子序列
		最长公共前缀
		最长不含重复元素的子串

	··字符数组char[] a转化成字符串String：new String(a)。
	··字符串转化成字符数组：string.toCharArray()。
	··字符串转换成byte数组：byte[] str = string.getBytes();

	··Stringbuffer s 转化成String：s.toString()。
	··向字符串变量中添加字符：Stringbuffer有append()。

	··遍历字符串： for(int i=0;i<string.length();i++)
	        				{        string.charAt(i)；}。
	
	··将数组中的某个值转化成单个字符：string.valueOf(a[j++])。

	··contains()方法是判断是否存在包含关系，比如说a =[1,2,3,4], b=1那么a就包含b。contains返回的是布尔类型true和false，包含的话就返回true，不包含的话就返回false。

	··next()一定要读取到有效字符后才可以结束输入。对输入有效字符之前遇到的空格键、Tab键或Enter键等结束符，next()方法会自动将其去掉，只有在输入有效字符之后，next()方法才将其后输入的空格键、Tab键或Enter键等视为分隔符或结束符。所以next方法不能得到带空格的字符串。

		nextLine()方法的结束符只是Enter键。即nextLine()方法返回的是Enter键之前的所有字符，它是可以得到带空格的字符串的。

	··判断字符是不是英文字母：(ch>='A' && ch <='Z') || (ch>='a' && ch <='z')
	··判断字符是不是数字：Character.isDigit('c')

	··string 和 int 型都支持直接加减
		'C'+'8'-'3'= 'C'+'5',由于'C'+1='D'，所以结果为char 'H' => %c；
		‘9’-‘0’：平时写代码的时候经常int（0~9）转换char就用的+'0',因此结果直接就是int 9 => %d。

	··str.substring(int beginIndex，int endIndex);截取str中从beginIndex开始至endIndex结束时的字符串；【只有一个参数的话，表示截取从这个参数位置起到结尾】

		  substring()函数是取一个string子串，如果j=1，那么str.substring(j+1)就是取从第二位开始的子串，所以str.substring(j+1)等于"345";
 		  valueOf是Integer类的一个静态方法，它是把一个string参数转换为Integer类型，那么经过Integer.valueOf（"345"）转换，345就是一个Integer类型了;
		  最后说这个intValue函数，它是将一个Integer类型转换成原始类型int，所以最后len就等于345了。

	··以特定字符分割字符串，并返回字符串数组：String[] str=string.split("-");




---------------------
【数组】：
	题型：拼接一个最大/小的数字、合并两个有序数组、调整数组顺序使奇数位于偶数前面、查找多数元素、数组中的重复元素；

	··数据结构的鼻祖——数组，可以说数组几乎能表示一切的数据结构，在每一门编程语言中，数组都是重要的数据结构，当然每种语言对数组的实现和处理也不相同，但是本质是都是用来存放数据的的结构。
	··在Java中，数组是用来存放同一种数据类型的集合，注意只能存放同一种数据类型(Object类型数组除外)。

	··数组是一种大小固定的数据结构，对线性表的所有操作都可以通过数组来实现。虽然数组一旦创建之后，它的大小就无法改变了，但是当数组不能再存储线性表中的新元素时，我们可以创建一个新的大的数组来替换当前数组。这样就可以使用数组实现动态的数据结构。
	
	··Math.pow(底数,几次方)。可以用math.pow()实现数组的交错求和。

	··数组实现的线性表优点在于可以通过下标来访问或者修改元素，比较高效，主要缺点在于插入和删除的花费开销较大，比如当在第一个位置前插入一个元素，那么首先要把所有的元素往后移动一个位置。为了提高在任意位置添加或者删除元素的效率，可以采用链式结构来实现线性表。



---------------------
【单链表】：
	··常见的链表题有：单链表反转、合并有序单链表、求单链表的中间节点、判断单链表相交或者有环、求出进入环的第一个节点、求单链表相交的第一个节点等。

	··快慢指针中的快慢是指移动的步长，及每次向前移速度的快慢。例如：快指针每次沿链表向前移动2，慢指针每次向前移动1。快指针控制进栈和出栈的时机，慢指针然后将出栈的跟后面一半的数据进行比较。
    	
    	快慢指针应用:
			1.判断单链表是否为循环链表。 2.寻找链表的中间位置（当不是数组时）。 3.如果链表有环，如何找到环的入口。

	··单链表数据结构：
		class ListNode {
		    int val;
		    ListNode next=null;

		    ListNode(int val) {
		        this.val = val;
		     }
		}

	首元节点：链表中第一个元素所在的节点，它是头节点后边的第一个节点。
			其实，首元节点和链表中存放数据的其他节点没什么不同，只是因为该节点位于链表的头部，所以被称为首元节点。

	头节点：有时，在链表的第一个节点之前会额外增设一个节点，该节点的数据域一般不存放数据（有些情况下也可以存放链表的长度等信息），此节点被称为头节点。
			若链表中存在头节点，且头节点的指针域为空（NULL），表明链表是空表。
			头节点对于链表来说，不是必须的，换句话说，一个完整的链表中可以不设有头节点。那么，可能有人会问：既然头节点无关紧要，那它有什么作用？在处理某些问题时，给链表添加头节点会使问题变得简单。

	头指针：链表的头指针永远指向链表中第一个节点的位置，换句话说，如果链表有头节点，头指针指向头节点；否则，头指针指向首元节点。
			一个链表可以没有头节点，但不能没有头指针。

	头节点和头指针的区别是：
			头指针是一个指针，头指针指向链表的头节点或者首元节点；
			头节点是一个实际存在的节点，它包含有数据域和指针域。
			头节点和头指针的区别在程序中的直接体现是：头指针只声明而没有分配存储空间，头节点需要声明并分配一个节点的实际物理内存。

    ··ListNode head中head。p = head->next；表示head的指针域，即p指向首元结点。

	··单链表添加头结点主要是方便算法的实现，从而在单链表为空与非空时，保持插入与删除操作的一致。但是带来内存开销。
    ··不带头结点的单链表选head==NULL，带头结点的单链表选head->next==NULL；

    ··创建一个新的链表：ListNode small = new ListNode(-1); 。-1就表示不是正常节点，常用来表示头结点，就是一个值而已，你用一千，一万，999999都行。
    	其中，next是用ListNode修饰的，表明next是当前结点的下一个ListNode结点，也包括val和next。
    
    ··ListNode small = new ListNode(-1);和ListNode small=null区别：
    	第一个声明一个引用，分配空间，然后这个引用 引用这个空间；
		第二个就声明一个引用而已；
		“=”意味着一种左边的指向右边的意思。



【双向链表】:数据、直接前驱、直接后继。
	··循环单链表：主要是链表的最后一个节点指向第一个节点，整体构成一个链环。 
		双向链表：主要是节点中包含两个指针部分，一个指向前驱元，一个指向后继元，JDK中LinkedList集合类的实现就是双向链表。 
		循环双向链表：是最后一个节点指向第一个节点。





---------------------
【栈】：push()、pop()、peek()、empty()、search()、isEmpty()【可由数组或者链表实现】
	·· 新建一个栈：Stack stack = new Stack（）；
	··可以自定义栈，指定初始化大小。数据成员包括（数组、当前指针），构造方法包括无参构造（大小是10）和有参构造（自定义数组大小），常见的普通方法包括“进出空满当前”。

	··泛型是Java SE5.0的重要特性，使用泛型编程可以使代码获得最大的重用。由于在使用泛型时要指明泛型的具体类型，这样就避免了类型转换。
		Stack<T> stack = new Stack<T>()；




--------------------
【队列】:【可由循环数组或者双向链表实现】
	··Queue使用时要尽量避免Collection的add()和remove()方法，而是要使用offer()来加入元素，使用poll()来获取并移出元素。
		它们的优点是通过返回值可以判断成功与否，而add()和remove()方法在失败的时候会抛出异常。element()或peek()只是查看对头元素，不移除。
		
		值得注意的是，Queue接口与List、Set同一级别，都是继承了Collection接口。LinkedList实现了Queue接口。因此我们可以把LinkedList当成Queue来用。

	··LinkedList:特有方法：
			addFirst();	向链表表头添加一个新节点，该节点中的数据是参数element指定的对象
			addLast();		向链表表尾添加一个新节点，该节点中的数据是参数element指定的对象

			getFirst();		得到链表第一个节点的对象
			getLast();		得到链表最后一个节点的对象
			获取元素，但不删除元素。如果集合中没有元素，会出现NoSuchElementException
			get(index);		获取指定位置上的对象；

			removeFirst();		删除第一个节点并返回这个节点中的对象
			removeLast();		删除最后一个节点并返回这个节点中的对象
			获取元素，但是元素被删除。如果集合中没有元素，会出现NoSuchElementException

			int indexOf(Object element) 		返回节点对象element在链表中首次出现的位置，如果链表中无此节点的对象则返回-1
			public int lastIndexOf(Object element)		返回节点对象element在链表中最后出现的位置，如果链表中无此节点的对象则返回-1
			public Object set(int index,Object element)		将当前链表index位置节点中的对象替换成参数element指定的对象，返回被替换对象

			public int size()		返回链表的长度即节点个数
			public  boolean  contains(Object element)		判断链表节点对象中是否含有element


			在JDK1.6出现了替代方法。

			offerFirst();
			offerLast();

			peekFirst();
			peekLast();
			获取元素，但不删除元素。如果集合中没有元素，会返回null。


			pollFirst();
			pollLast();
			获取元素，但是元素被删除。如果集合中没有元素，会返回null。


	·· 新建一个队列：Queue<Type> queue = new Queue<>(100000)；好像没有这个的吧？？？？？毕竟Queue是接口。

		注意Queue创建的方式：Queue<TreeNode> queue = new LinkedList<TreeNode>();

	··可以自定义队列，成员包括（数组，有效数据多少，队头，队尾），构造方法包括无参构造（大小是10）和有参构造（自定义数组大小），常见的普通方法包括“进出空满当前”。

	··队列分为：
	　　单向队列（Queue）：只能在一端插入数据，另一端删除数据。
	　　双向队列（Deque）：每一端都可以进行插入数据和删除数据操作。

【优先级队列】：
	··与普通队列相比，队列中元素是有序的，关键字最小或者最大的总在队头。插入时会按照顺序插入到合适位置以确保队列顺序。
	··内部实现可以是数组或者一种  特别的树··堆  来实现。




------------------
【树】：能同时具备数组查找快的优点以及链表插入和删除快的优点！
			  为了对动态查找表进行更高效率的查找可以使用树表。

	··森林/树 对 二叉树的转换：
		···过程：首先，森林中的各棵树转换成各棵二叉树；然后，各棵二叉树转换成一棵二叉树；
		···口诀：兄弟相连，长兄为父，孩子靠左；
		···树与二叉树遍历的对应关系：先序对先序，后序对中序。
		···森林与二叉树遍历的对应关系：先序对先序，中序对中序。
	··满二叉树：除了最后一层无子结点外，其余各层都有左右两个结点。
	··完全二叉树：除了最后一层，其余各层都有两个结点，最后一层结点都连续集中在左侧。

	··二叉树的定义：
		class TreeNode{
			int data;		//可以有多个数据项
			TreeNode leftchild=null;
			TreeNode rightchild=null;

			TreeNode(int data){
				this.data=data;
			}
		}
		class Tree{
			TreeNode root;
		}

	··二叉树的插入：灵活使用current【相当于当前指针】。将root赋值给current，将current赋值给parent，这样parent才可以引出leftchild和rightchild。小于根结点走左边；大于根结点走右边。
	··二叉树的查找：将root赋值给current，current为null，则返回null，否则返回current。
	··二叉树的遍历：前序、中序、后序。【使用递归】
	··二叉树的删除：
		1.删除的是叶子结点；【将指向该结点的引用设置为null】
		2.删除的结点有1个子结点；【将引用直接指向要删除结点的子结点】
		3.删除的结点有2个子结点；【使用中序后继结点来代替该结点，所谓的中序后继结点就是比删除结点要大的所有结点中的最小的一个，即从删除结点位置先往右再往左遍历寻找】

	··哈夫曼树：在通信编码有广泛应用。构造了哈夫曼树，按分支在左路径写0，右路径写1，然后从上到下叶节点的代码序列就是该结点的最优前缀码，即哈夫曼编码。
		用哈夫曼编码来编码：
			(1)先算每个字符的概率，按出现的概率大小排队，把两个最小的概率相加，作为新的概率和剩余的概率重新排队，再把最小的两个概率相加，再重新排队，直到最后变成1（可以从下往上画出哈夫曼树）。
			(2)然后从上往下，对每一个字符进行编码，即可得到每个字符的哈夫曼编码。
			(3)代入字符串即可得到字符串的哈夫曼编码。

	------------------------
	【二叉排序树（BST）】
	··二叉排序树要求：空树 or 若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值；若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值；

						它的左、右子树也分别为二叉排序树。【满足中序遍历结点值递增的规律】
	··二叉排序树又称二叉查找树，它对排序和查找都有用。
	··在理想情况下，二叉查找树增删改查的时间复杂度为O(logN)，但是若是二叉树极度不平衡，比如形成了一个线性链后，就会产生最坏运行情况O(N)；
	
	-----------------------
	【平衡二叉树】：典型的有AVL树和红黑树；
	为了维持二叉树的平衡：
		··AVL树（平衡二叉树）：空树 or 左子树和右子树深度之差不超过1 and 左右子树都是平衡二叉树；
		··AVL是严格的平衡二叉树，但是插入和删除的性能较差，所以在实际生产环境中不如红黑树应用广泛；

	------------------------
	【红黑树RBTree】:
		··红黑树：节点是红色或者黑色的平衡二叉树，通过颜色的约束来维持着二叉树的平衡。
		··红黑树从本质上来说就是一颗二叉查找树，但是在二叉树的基础上增加了着色相关的性质，使得红黑树可以保证相对平衡，从而保证红黑树的增删改查的时间复杂度最坏		也能达到O(log N)；
		··典型的用途：实现关联数组；
		··规则：
			1、每个节点都只能是红色或者黑色
			2、根节点是黑色
			3、每个叶节点（NIL节点，空节点）是黑色的。
			4、如果一个结点是红的，则它两个子节点都是黑的。也就是说在一条路径上不能出现相邻的两个红色结点。
			5、从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点。
			5条特性确保：从根到叶子的最长的可能路径不多于最短的可能路径的两倍长，使得整棵树大致上是平衡的。树上的增删改查操作的最坏情况时间都与树的高度成正比，所以红黑树在最坏情况下也是高效的。
			在红黑树中一般用黑的NIL节点表示叶节点，不包含值，只是标志该分支结束，有时候绘图中会直接省略。

		··三大基本操作：左旋、右旋、着色；
		




--------------------
【图】：
	··连通图与非连通图：至少有一条路径连接所有的顶点，就叫连通图，否则是非连通图。
	··网：带权的图。
	··无向完全图：n(n-1)/2条弧;	
	··有向完全图：n(n-1)条弧;
	··连通图：任意两个顶点都是连通的。
	··连通分量：无向图中的极大连通子图。
	··强连通图：有向图中，从a到b和从b到a都存在路径。
	··强连通分量：有向图中，极大强连通子图称为强连通分量。
	··邻接矩阵：二维数组。稠密图。
	··邻接表：2条链表。稀疏图。

	··数据结构：
		class Vertex(){
				char label;
				Vertex(char label){
				this.label=label;
				}
		}
		class Graph(){
				Vertex[] vertexList;

		}


	··深度优先搜索【DFS】通过栈来实现，而广度优先搜索【BFS】通过队列来实现，不同的实现机制导致不同的搜索方式。
		--------------------
		深度优先搜索算法有如下规则：
		　　规则1：如果可能，访问一个邻接的未访问顶点，标记它，并将它放入栈中。
		　　规则2：当不能执行规则 1 时，如果栈不为空，就从栈中弹出一个顶点。
		　　规则3：如果不能执行规则 1 和规则 2 时，就完成了整个搜索过程。
		深度优先搜索要尽可能的远离起始点，而广度优先搜索则要尽可能的靠近起始点，它首先访问起始顶点的所有邻接点，然后再访问较远的区域，这种搜索不能用栈实现，而是用队列实现。

		广度优先搜索算法有如下规则：
		　　规则1：访问下一个未访问的邻接点（如果存在），这个顶点必须是当前顶点的邻接点，标记它，并把它插入到队列中。
		　　规则2：如果已经没有未访问的邻接点而不能执行规则 1 时，那么从队列列头取出一个顶点（如果存在），并使其成为当前顶点。
		　　规则3：如果因为队列为空而不能执行规则 2，则搜索结束。

		两种遍历的比较： 
				1.深度优先搜索法特点： 【堆栈】
				（1）有递归以及非递归两种设计方法。一般的，当搜索深度较小、问题递归方式比较明显时，用递归方法设计好，它可以使得程序结构更简捷易懂。当数据量较大时，由于系统堆栈容量的限制，递归容易产生溢出，用非递归方法设计比较好。

				2.广度优先搜索 ：【队列】
				（1）在产生新的子结点时，深度越小的结点越先得到扩展，即先产生它的子结点。为使算法便于实现，存放结点的数据库一般用队列的结构。 
				（2）无论问题性质如何不同，利用广度优先搜索法解题的基本算法是相同的，但数据库中每一结点内容，产生式规则，根据不同的问题，有不同的内容和结构，就是同一问题也可以有不同的表示方法。

				比较深度优先和广度优先两种搜索法，广度优先搜索法一般无回溯操作，即入栈和出栈的操作，所以运行速度比深度优先搜索算法法要快些. 
				总之，一般情况下，深度优先搜索法占内存少但速度较慢，广度优先搜索算法占内存多但速度较快，在距离和深度成正比的情况下能较快地求出最优解。因此在选择用哪种算法时，要综合考虑。决定取舍。


	··对于图的操作，还有一个最常用的就是找到最小生成树，最小生成树就是用最少的边连接所有顶点。对于给定的一组顶点，可能有很多种最小生成树，但是最小生成树的边的数量E总是比顶点V的数量小1，即：V = E+1。
		这里不用关心边的长度，不是找最短的路径（会在带权图中讲解），而是找最少数量的边，可以基于深度优先搜索和广度优先搜索来实现。
		比如基于深度优先搜索，我们记录走过的边，就可以创建一个最小生成树。因为DFS 访问所有顶点，但只访问一次，它绝对不会两次访问同一个顶点，但她看到某条边将到达一个已访问的顶点，它就不会走这条边，它从来不遍历那些不可能的边，因此，DFS 算法走过整个图的路径必定是最小生成树。


		//基于深度优先搜索找到最小生成树
		public void mst(){
		    vertexList[0].wasVisited = true;
		    theStack.push(0);
		     
		    while(!theStack.isEmpty()){
		        int currentVertex = theStack.peek();
		        int v = getAdjUnvisitedVertex(currentVertex);
		        if(v == -1){
		            theStack.pop();
		        }else{
		            vertexList[v].wasVisited = true;
		            theStack.push(v);
		             
		            displayVertex(currentVertex);
		            displayVertex(v);
		            System.out.print(" ");
		        }
		    }
		     
		    //搜索完毕，初始化，以便于下次搜索
		    for(int i = 0; i < nVerts; i++) {
		        vertexList[i].wasVisited = false;
		    }
		}





--------------------
【散列/哈希表】：
	··哈希表：提供快速插入和查找，基于数组实现。
	··哈希化：直接将关键字作为索引；将单词转换成索引【3种方法有冲突，解决方法有2种】。

	··哈希表也称散列表，也有直接译作哈希表，Hash表是一种根据关键字值（key - value）而直接进行访问的数据结构。
		它基于数组，类似于key-value的存储形式，关键字值通过哈希函数映射为数组的下标来加快查找速度，但是又和数组、链表、树等数据结构不同，在这些数据结构中查找某个关键字，通常要遍历整个数据结构，也就是O(N)的时间级，但是对于哈希表来说，只是O(1)的时间级。
		
		注意，这里有个重要的问题就是如何把关键字转换为数组的下标，这个转换的函数称为哈希函数（也称散列函数），转换的过程称为哈希化。把一个大范围的数字哈希（转化）成一个小范围的数字，这个小范围的数对应着数组的下标。使用哈希函数向数组插入数据后，这个数组就是哈希表。	

	··如果一个关键字哈希化到已占用的数组单元，这种情况称为冲突。
		解决哈希冲突常用的两种方法：
			···开放定址法：当冲突发生时，使用某种探查(亦称探测)技术在散列表中形成一个探查(测)序列。沿此序列逐个单元地查找，直到找到给定的关键字，或者碰到一个开放的地址(即该地址单元为空)为止（若要插入，在探查到开放的地址，则可将待插入的新结点存人该地址单元）。查找时探查到开放的地址则表明表中无待查的关键字，即查找失败。

			···链地址法：将所有关键字为同义词的结点链接在同一个单链表中。若选定的散列表长度为m，则可将散列表定义为一个由m个头指针组成的指针数 组T[0..m-1]。
			凡是散列地址为i的结点，均插入到以T[i]为头指针的单链表中。T中各分量的初值均应为空指针。

			···另外一种方法类似于链地址法，它是在每个数据项中使用子数组，而不是链表。这样的数组称为桶。这个方法显然不如链表有效，因为桶的容量不好选择，如果容量太小，可能会溢出，如果太大，又造成性能浪费，而链表是动态分配的，不存在此问题。所以一般不使用桶。
	
    

   

