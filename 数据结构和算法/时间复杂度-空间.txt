
时间复杂度
--------------------------
·相关概念：

    ··时间频度 
    一个算法执行所耗费的时间，从理论上是不能算出来的，必须上机运行测试才能知道。但我们不可能也没有必要对每个算法都上机测试，只需知道哪个算法花费的时间多，哪个算法花费的时间少就可以了。并且一个算法花费的时间与算法中语句的执行次数成正比例，哪个算法中语句执行次数多，它花费时间就多。一个算法中的语句执行次数称为语句频度或时间频度。记为T(n)。 

    ··时间复杂度 
    在刚才提到的时间频度中，n称为问题的规模，当n不断变化时，时间频度T(n)也会不断变化。但有时我们想知道它变化时呈现什么规律。为此，我们引入时间复杂度概念。 

    一般情况下，算法中基本操作重复执行的次数是问题规模n的某个函数，用T(n)表示，若有某个辅助函数f(n),使得当n趋近于无穷大时，T（n)/f(n)的极限值为不等于零的常数，则称f(n)是T(n)的同数量级函数。记作T(n)=O(f(n)),称O(f(n)) 为算法的渐进时间复杂度，简称时间复杂度。 

    在各种不同算法中，若算法中语句执行次数为一个常数，则时间复杂度为O(1),另外，在时间频度不相同时，时间复杂度有可能相同，如T(n)=n2+3n+4与T(n)=4n2+2n+1它们的频度不同，但时间复杂度相同，都为O(n2)。 

    按数量级递增排列，常见的时间复杂度有： 
    常数阶O(1),对数阶O(log2n),线性阶O(n), 
    线性对数阶O(nlog2n),平方阶O(n2)，立方阶O(n3)，...，
    k次方阶O(nk),指数阶O(2n)。随着问题规模n的不断增大，上述时间复杂度不断增大，算法的执行效率越低。 

    ·空间复杂度 
    与时间复杂度类似，空间复杂度是指算法在计算机内执行时所需存储空间的度量。记作: S(n)=O(f(n)) 
    我们一般所讨论的是除正常占用内存开销外的辅助存储单元规模。

 

·常见算法时间复杂度：

		O(1): 表示算法的运行时间为常量

		O(n): 表示该算法是线性算法

		O(㏒2n): 二分查找算法

		O(n2): 对数组进行排序的各种简单算法，例如直接插入排序的算法。

		O(n3): 做两个n阶矩阵的乘法运算

		O(2n): 求具有n个元素集合的所有子集的算法

		O(n!): 求具有N个元素的全排列的算法

		优<---------------------------<劣

		O(1)<O(㏒2n)<O(n)<O(n2)<O(2n)

	时间复杂度按数量级递增排列依次为：常数阶O(1)、对数阶O(log2n)、线性阶O(n)、线性对数阶O(nlog2n)、平方阶O(n2)、立方阶O(n3)、……k次方阶O(nk)、指数阶O(2n)。




·算法的时间复杂度（计算实例）

    定义：如果一个问题的规模是n，解这一问题的某一算法所需要的时间为T(n)，它是n的某一函数 T(n)称为这一算法的“时间复杂性”。

    当输入量n逐渐加大时，时间复杂性的极限情形称为算法的“渐近时间复杂性”。

    我们常用大O表示法表示时间复杂性，注意它是某一个算法的时间复杂性。大O表示只是说有上界，由定义如果f(n)=O(n)，那显然成立f(n)=O(n^2)，它给你一个上界，但并不是上确界，但人们在表示的时候一般都习惯表示前者。

    此外，一个问题本身也有它的复杂性，如果某个算法的复杂性到达了这个问题复杂性的下界，那就称这样的算法是最佳算法。

    “大O记法”：在这种描述中使用的基本参数是 n，即问题实例的规模，把复杂性或运行时间表达为n的函数。这里的“O”表示量级 (order)，比如说“二分检索是 O(logn)的”,也就是说它需要“通过logn量级的步骤去检索一个规模为n的数组”记法 O ( f(n) )表示当 n增大时，运行时间至多将以正比于 f(n)的速度增长。

    这种渐进估计对算法的理论分析和大致比较是非常有价值的，但在实践中细节也可能造成差异。例如，一个低附加代价的O(n2)算法在n较小的情况下可能比一个高附加代价的 O(nlogn)算法运行得更快。当然，随着n足够大以后，具有较慢上升函数的算法必然工作得更快。

          O(1)
          Temp=i;i=j;j=temp;                    

    以上三条单个语句的频度均为1，该程序段的执行时间是一个与问题规模n无关的常数。算法的时间复杂度为常数阶，记作T(n)=O(1)。如果算法的执行时 间不随着问题规模n的增加而增长，即使算法中有上千条语句，其执行时间也不过是一个较大的常数。此类算法的时间复杂度是O(1)。


          O(n^2)
          2.1. 交换i和j的内容

               sum=0；                 （一次）

               for(i=1;i<=n;i++)       （n次 ）

                  for(j=1;j<=n;j++) （n^2次 ）

                   sum++；       （n^2次 ）

          解：T(n)=2n^2+n+1 =O(n^2)

          2.2.   

              for (i=1;i<n;i++)

              {

                  y=y+1;         ①   

                  for (j=0;j<=(2*n);j++)    

                     x++;        ②      

              }         

          解： 语句1的频度是n-1

                    语句2的频度是(n-1)*(2n+1)=2n^2-n-1

                    f(n)=2n^2-n-1+(n-1)=2n^2-2

                    该程序的时间复杂度T(n)=O(n^2).         


          O(n)                                                
          2.3.

              a=0;

              b=1;                      ①

              for (i=1;i<=n;i++) ②

              {  

                 s=a+b;　　　　③

                 b=a;　　　　　④  

                 a=s;　　　　　⑤

              }

          解： 语句1的频度：2,        1

                  语句2的频度： n,        n

                  语句3的频度： n-1,      n  

                  语句4的频度：n-1,    n

                  语句5的频度：n-1,      n                            

                  T(n)=2+n+3(n-1)=4n-1=O(n).

                                                                                                           

          O(log2n )
          2.4.

               i=1;       ①

              while (i<=n)

                 i=i*2; ②

          解： 语句1的频度是1,  

                    设语句2的频度是f(n),   则：2^f(n)<=n;f(n)<=log2n    

                    取最大值f(n)= log2n,

                    T(n)=O(log2n )


          O(n^3)
          2.5.

              for(i=0;i<n;i++)

              {  

                 for(j=0;j<i;j++)  

                 {

                    for(k=0;k<j;k++)

                       x=x+2;  

                 }

              }

解：当i=m, j=k的时候,内层循环的次数为k当i=m时, j 可以取 0,1,...,m-1 , 所以这里最内循环共进行了0+1+...+m-1=(m-1)m/2次所以,i从0取到n, 则循环共进行了: 0+(1-1)*1/2+...+(n-1)n/2=n(n+1)(n-1)/6所以时间复杂度为O(n^3)。

    我们还应该区分算法的最坏情况的行为和期望行为。如快速排序的最 坏情况运行时间是 O(n^2)，但期望时间是 O(nlogn)。通过每次都仔细 地选择基准值，我们有可能把平方情况 (即O(n^2)情况)的概率减小到几乎等于 0。在实际中，精心实现的快速排序一般都能以 (O(nlogn)时间运行。


下面是一些常用的记法：

  	访问数组中的元素是常数时间操作，或说O(1)操作。一个算法如果能在每个步骤去掉一半数据元素，如二分检索，通常它就取 O(logn)时间。用strcmp比较两个具有n个字符的串需要O(n)时间 。常规的矩阵乘算法是O(n^3)，因为算出每个元素都需要将n对 元素相乘并加到一起，所有元素的个数是n^2。

  	指数时间算法通常来源于需要求出所有可能结果。例如，n个元 素的集合共有2n个子集,所以要求出所有子集的算法将是O(2n)的 。指数算法一般说来是太复杂了，除非n的值非常小，因为，在 这个问题中增加一个元素就导致运行时间加倍。不幸的是，确实有许多问题 (如著名 的“巡回售货员问题” )，到目前为止找到的算法都是指数的。如果我们真的遇到这种情况， 通常应该用寻找近似最佳结果的算法替代之。




·System.getProperty()的使用：

    System.getProperty("user.dir")    //用户的当前工作目录，在linux下与pwd(print working directory) 命令相同

    System.getProperty()    //这个系统属性集合总是包含以下键的值

                              键           相关值的描述

                              java.version Java运行时环境版本 
                              java.vendor Java运行时环境供应商 
                              java.vendor.url Java供应商的URL
                              java.home Java安装目录 
                              java.vm.specification.version Java虚拟机规范版本 
                              java.vm.specification.vendor Java虚拟机规范供应商 
                              java.vm.specification.name Java虚拟机规范名称 
                              java.vm.version Java虚拟机实现版本 
                              java.vm.vendor Java虚拟机实现供应商 
                              java.vm.name Java虚拟机实现名称 
                              java.specification.version Java运行时环境规范版本 
                              java.specification.vendor Java运行时环境规范供应商 
                              java.specification.name Java运行时环境规范名称 
                              java.class.version Java类格式版本号 
                              java.class.path Java类路径 
                              java.library.path 加载库时搜索的路径列表 
                              java.io.tmpdir 默认的临时文件路径 
                              java.compiler 要使用的 JIT 编译器的名称 
                              java.ext.dirs 一个或多个扩展目录的路径 
                              os.name 操作系统的名称 
                              os.arch 操作系统的架构 
                              os.version 操作系统的版本 
                              file.separator 文件分隔符（在 UNIX 系统中是“/”） 
                              path.separator 路径分隔符（在 UNIX 系统中是“:”） 
                              line.separator 行分隔符（在 UNIX 系统中是“/n”） 
                              user.name 用户的账户名称 
                              user.home 用户的主目录 
                              user.dir 用户的当前工作目录 
                              
                              系统属性值中的多个路径是用平台的路径分隔符分隔的。 
                              注意，即使安全管理器不允许执行 getProperties 操作，它可能也会选择允许执行 getProperty(String) 操作。

    　　




空间复杂度：
-----------------------
·空间复杂度为1时，表示这个变量与问题规模n大小无关。
