
时间复杂度
--------------------------
·相关概念：

  ··时间频度：
    一个算法执行所耗费的时间，从理论上是不能算出来的，必须上机运行测试才能知道。但我们不可能也没有必要对每个算法都上机测试，只需知道哪个算法花费的时间多，哪个算法花费的时间少就可以了。并且一个算法花费的时间与算法中语句的执行次数成正比例，哪个算法中语句执行次数多，它花费时间就多。一个算法中的语句执行次数称为语句频度或时间频度。记为T(n)。 

  ··时间复杂度：
    在刚才提到的时间频度中，n称为问题的规模，当n不断变化时，时间频度T(n)也会不断变化。但有时我们想知道它变化时呈现什么规律。为此，我们引入时间复杂度概念。 

    一般情况下，算法中基本操作重复执行的次数是问题规模n的某个函数，用T(n)表示，若有某个辅助函数f(n),使得当n趋近于无穷大时，T（n)/f(n)的极限值为不等于零的常数，则称f(n)是T(n)的同数量级函数。记作T(n)=O(f(n)),称O(f(n)) 为算法的渐进时间复杂度，简称时间复杂度。 

    在各种不同算法中，若算法中语句执行次数为一个常数，则时间复杂度为O(1),另外，在时间频度不相同时，时间复杂度有可能相同，如T(n)=n2+3n+4与T(n)=4n2+2n+1它们的频度不同，但时间复杂度相同，都为O(n2)。 

    按数量级递增排列，常见的时间复杂度有： 
    常数阶O(1),对数阶O(log2n),线性阶O(n), 
    线性对数阶O(nlog2n),平方阶O(n2)，立方阶O(n3)，...，
    k次方阶O(nk),指数阶O(2n)。随着问题规模n的不断增大，上述时间复杂度不断增大，算法的执行效率越低。 


 


·常见算法时间复杂度：

	O(1): 表示算法的运行时间为常量

	O(n): 表示该算法是线性算法

	O(㏒2n): 二分查找算法

	O(n2): 对数组进行排序的各种简单算法，例如直接插入排序的算法。

	O(n3): 做两个n阶矩阵的乘法运算

	O(2n): 求具有n个元素集合的所有子集的算法

	O(n!): 求具有N个元素的全排列的算法

	优<---------------------------<劣

	O(1)<O(㏒2n)<O(n)<O(n2)<O(2n)

	时间复杂度按数量级递增排列依次为：常数阶O(1)、对数阶O(log2n)、线性阶O(n)、线性对数阶O(nlog2n)、平方阶O(n2)、立方阶O(n3)、……k次方阶O(nk)、指数阶O(2n)。





·算法的时间复杂度（计算实例）

  定义：如果一个问题的规模是n，解这一问题的某一算法所需要的时间为T(n)，它是n的某一函数 T(n)称为这一算法的“时间复杂性”。

  当输入量n逐渐加大时，时间复杂性的极限情形称为算法的“渐近时间复杂性”。

  我们常用大O表示法表示时间复杂性，注意它是某一个算法的时间复杂性。大O表示只是说有上界，由定义如果f(n)=O(n)，那显然成立f(n)=O(n^2)，它给你一个上界，但并不是上确界，但人们在表示的时候一般都习惯表示前者。

  此外，一个问题本身也有它的复杂性，如果某个算法的复杂性到达了这个问题复杂性的下界，那就称这样的算法是最佳算法。

  “大O记法”：在这种描述中使用的基本参数是 n，即问题实例的规模，把复杂性或运行时间表达为n的函数。这里的“O”表示量级 (order)，比如说“二分检索是 O(logn)的”,也就是说它需要“通过logn量级的步骤去检索一个规模为n的数组”记法 O ( f(n) )表示当 n增大时，运行时间至多将以正比于 f(n)的速度增长。

  这种渐进估计对算法的理论分析和大致比较是非常有价值的，但在实践中细节也可能造成差异。例如，一个低附加代价的O(n2)算法在n较小的情况下可能比一个高附加代价的 O(nlogn)算法运行得更快。当然，随着n足够大以后，具有较慢上升函数的算法必然工作得更快。

        O(1)
        Temp=i;i=j;j=temp;                    

  以上三条单个语句的频度均为1，该程序段的执行时间是一个与问题规模n无关的常数。算法的时间复杂度为常数阶，记作T(n)=O(1)。如果算法的执行时 间不随着问题规模n的增加而增长，即使算法中有上千条语句，其执行时间也不过是一个较大的常数。此类算法的时间复杂度是O(1)。


          O(n^2)
          2.1. 交换i和j的内容

               sum=0；                 （一次）

               for(i=1;i<=n;i++)       （n次 ）

                  for(j=1;j<=n;j++) （n^2次 ）

                   sum++；       （n^2次 ）

          解：T(n)=2n^2+n+1 =O(n^2)

          2.2.   

              for (i=1;i<n;i++)

              {

                  y=y+1;         ①   

                  for (j=0;j<=(2*n);j++)    

                     x++;        ②      

              }         

          解： 语句1的频度是n-1

                    语句2的频度是(n-1)*(2n+1)=2n^2-n-1

                    f(n)=2n^2-n-1+(n-1)=2n^2-2

                    该程序的时间复杂度T(n)=O(n^2).         


          O(n)                                                
          2.3.

              a=0;

              b=1;                      ①

              for (i=1;i<=n;i++) ②

              {  

                 s=a+b;　　　　③

                 b=a;　　　　　④  

                 a=s;　　　　　⑤

              }

          解： 语句1的频度：2,        1

                  语句2的频度： n,        n

                  语句3的频度： n-1,      n  

                  语句4的频度：n-1,    n

                  语句5的频度：n-1,      n                            

                  T(n)=2+n+3(n-1)=4n-1=O(n).

                                                                                                           

          O(log2n )
          2.4.

               i=1;       ①

              while (i<=n)

                 i=i*2; ②

          解： 语句1的频度是1,  

                    设语句2的频度是f(n),   则：2^f(n)<=n;f(n)<=log2n    

                    取最大值f(n)= log2n,

                    T(n)=O(log2n )


          O(n^3)
          2.5.

              for(i=0;i<n;i++)

              {  

                 for(j=0;j<i;j++)  

                 {

                    for(k=0;k<j;k++)

                       x=x+2;  

                 }

              }

  解：当i=m, j=k的时候,内层循环的次数为k当i=m时, j 可以取 0,1,...,m-1 , 所以这里最内循环共进行了0+1+...+m-1=(m-1)m/2次所以,i从0取到n, 则循环共进行了: 0+(1-1)*1/2+...+(n-1)n/2=n(n+1)(n-1)/6所以时间复杂度为O(n^3)。
    我们还应该区分算法的最坏情况的行为和期望行为。如快速排序的最 坏情况运行时间是 O(n^2)，但期望时间是 O(nlogn)。通过每次都仔细 地选择基准值，我们有可能把平方情况 (即O(n^2)情况)的概率减小到几乎等于 0。在实际中，精心实现的快速排序一般都能以 (O(nlogn)时间运行。


  下面是一些常用的记法：

  	访问数组中的元素是常数时间操作，或说O(1)操作。一个算法如果能在每个步骤去掉一半数据元素，如二分检索，通常它就取 O(logn)时间。用strcmp比较两个具有n个字符的串需要O(n)时间 。常规的矩阵乘算法是O(n^3)，因为算出每个元素都需要将n对 元素相乘并加到一起，所有元素的个数是n^2。

  	指数时间算法通常来源于需要求出所有可能结果。例如，n个元素的集合共有2n个子集,所以要求出所有子集的算法将是O(2n)的。指数算法一般说来是太复杂了，除非n的值非常小，因为，在这个问题中增加一个元素就导致运行时间加倍。不幸的是，确实有许多问题 (如著名 的“巡回售货员问题” )，到目前为止找到的算法都是指数的。如果我们真的遇到这种情况， 通常应该用寻找近似最佳结果的算法替代之。






    　　




空间复杂度：
-----------------------
·空间复杂度：
  与时间复杂度类似，空间复杂度是指算法在计算机内执行时所需存储空间的度量。记作: S(n)=O(f(n)) 
  我们一般所讨论的是除正常占用内存开销外的辅助存储单元规模。









总结：
---------------------
·简单来说，时间复杂度指的是语句执行次数，空间复杂度指的是算法所占的存储空间。

  一般情况下，随着n的增大，T(n)增长最慢的算法为最优算法。

  1.对于简单的输入输出语句或赋值语句(无循环语句)，近似认为需要 O(1)。一般来说，只要算法中不存在循环语句，其时间复杂度就是 O(1)。

  2.对于顺序结构，需要依次执行一系列语句所用时间可采用 "求和法则"。

  3.对于判断条件语句来说，一般是求它的最差时间复杂度。

  4.对于循环语句来说，只考虑循环体中语句的执行次数。当有若干个循环语句，则复杂度由最深层的循环内的基本语句的频度f(n)决定的。

  5.对数时间复杂度：当每次操作都能将所需要检测的元素减少一半时(即每次操作，未检测元素减少一半)，这样的时间复杂度为 O(logn)。

  6.如果一个算法的执行次数是 T(n)，那么只保留最高次项，同时忽略最高项的系数后得到函数 f(n)，此时算法的时间复杂度就是 O(f(n))。为了方便描述，下文称此为 大O推导法。推导方法：1代替常数；只保留最高阶；最高阶不是1时去掉最高阶的系数。
  
  7.时间复杂度分析的基本策略是：从内向外分析，从最深层开始分析。如果遇到  函数调用，要深入函数进行分析。

  8.O(1) 常数阶 < O(logn) 对数阶 < O(n) 线性阶 < O(nlogn) < O(n^2) 平方阶 < O(n^3) < { O(2^n) < O(n!) < O(n^n) }      
    最后三项用大括号把他们括起来是想要告诉大家，如果日后大家设计的算法推导出的“大O阶”是大括号中的这几位，那么趁早放弃这个算法，在去研究新的算法出来吧。因为大括号中的这几位即便是在 n 的规模比较小的情况下仍然要耗费大量的时间，算法的时间复杂度大的离谱，基本上就是“不可用状态”。

  9.空间复杂度为1时，表示这个变量与问题规模n大小无关。