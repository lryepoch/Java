
时间复杂度
--------------------------
·相关概念：

  ··时间频度：
    一个算法执行所耗费的时间，从理论上是不能算出来的，必须上机运行测试才能知道。但我们不可能也没有必要对每个算法都上机测试，只需知道哪个算法花费的时间多，哪个算法花费的时间少就可以了。并且一个算法花费的时间与算法中语句的执行次数成正比例，哪个算法中语句执行次数多，它花费时间就多。一个算法中的语句执行次数称为语句频度或时间频度。记为T(n)。 

  ··时间复杂度：
    在刚才提到的时间频度中，n称为问题规模，当n不断变化时，时间频度T(n)也会不断变化。但有时我们想知道它变化时呈现什么规律。为此，我们引入时间复杂度概念。 

    一般情况下，算法中基本操作重复执行的次数是问题规模n的某个函数，用T(n)表示，若有某个辅助函数f(n),使得当n趋近于无穷大时，T（n)/f(n)的极限值为不等于零的常数，则称f(n)是T(n)的同数量级函数。记作T(n)=O(f(n)),称O(f(n)) 为算法的渐进时间复杂度，简称时间复杂度。 

    在各种不同算法中，若算法中语句执行次数为一个常数，则时间复杂度为O(1),另外，在时间频度不相同时，时间复杂度有可能相同，如T(n)=n2+3n+4与T(n)=4n2+2n+1它们的频度不同，但时间复杂度相同，都为O(n2)。     


    幂运算：指数个底数相乘；
    对数：a^x=N；x叫做以a为底N的对数，记作x=logaN




·常见算法时间复杂度：

	常数阶O(1): 表示算法的运行时间为常量

	对数阶O(log2n): 二分查找算法

  线性阶O(n): 表示该算法是线性算法

  线性对数阶O(nlog2n)：

	平方阶O(n2): 对数组进行排序的各种简单算法，例如直接插入排序的算法。

	立方阶O(n3): 做两个n阶矩阵的乘法运算

  k次方阶O(nk):

	指数阶O(2n): 求具有n个元素集合的所有子集的算法

	O(n!): 求具有N个元素的全排列的算法

	优<---------------------------<劣

	O(1)<O(㏒2n)<O(n)<O(n2)<O(2n)

	时间复杂度按数量级递增排列依次为：常数阶O(1)、对数阶O(log2n)、线性阶O(n)、线性对数阶O(nlog2n)、平方阶O(n2)、立方阶O(n3)、……k次方阶O(nk)、指数阶O(2n)。
  随着问题规模n的不断增大，上述时间复杂度不断增大，算法的执行效率越低。 
  

  ------------------
  因为渐进时间复杂度使用大写O来表示，所以也称大O表示法。例如: O(f(n))。

  ··O(1)
  1.Temp=i;i=j;j=temp;                    

  以上三条单个语句的频度均为1，该程序段的执行时间是一个与问题规模n无关的常数。算法的时间复杂度为常数阶，记作T(n)=O(1)。如果算法的执行时 间不随着问题规模n的增加而增长，即使算法中有上千条语句，其执行时间也不过是一个较大的常数。此类算法的时间复杂度是O(1)。


  ··O(n)                                                
  2.
      a=0;
      b=1;               ①
      for (i=1;i<=n;i++) ②
      {  
         s=a+b;　　　　③
         b=a;　　　　　④  
         a=s;　　　　　⑤
      }

  解： 语句1的频度：2,        1

          语句2的频度： n,        n

          语句3的频度： n-1,      n  

          语句4的频度：n-1,    n

          语句5的频度：n-1,      n                            

          T(n)=2+n+3(n-1)=4n-1=O(n).
                                                                                       

  ··O(log2n )
  3.
      i=1;       ①
      while (i<=n)

         i=i*2; ②

  解： 语句1的频度是1,  

            设语句2的频度是f(n),   则：2^f(n)<=n;f(n)<=log2n    

            取最大值f(n)= log2n,

            T(n)=O(log2n )
  

  ··O(n^2)
  4.1.交换i和j的内容

       sum=0；                 （一次）

       for(i=1;i<=n;i++)       （n次 ）

          for(j=1;j<=n;j++) （n^2次 ）

           sum++；       （n^2次 ）

  解：T(n)=2n^2+n+1 =O(n^2)

  4.2.   
      for (i=1;i<n;i++)
      {
          y=y+1;         ①   
          for (j=0;j<=(2*n);j++)    
             x++;        ②      
      }         
  解： 语句1的频度是n-1

            语句2的频度是(n-1)*(2n+1)=2n^2-n-1

            f(n)=2n^2-n-1+(n-1)=2n^2-2

            该程序的时间复杂度T(n)=O(n^2).       


  ··O(n^3)
  5.
    for(i=0;i<n;i++)

    {  

       for(j=0;j<i;j++)  

       {

          for(k=0;k<j;k++)

             x=x+2;  

       }

    }
  解：当i=m, j=k的时候,内层循环的次数为k当i=m时, j 可以取 0,1,...,m-1 , 所以这里最内循环共进行了0+1+...+m-1=(m-1)m/2次所以,i从0取到n, 则循环共进行了: 0+(1-1)*1/2+...+(n-1)n/2=n(n+1)(n-1)/6所以时间复杂度为O(n^3)。








空间复杂度：
-----------------------
·空间复杂度：
  与时间复杂度类似，空间复杂度是指算法在计算机内执行时所需存储空间的度量。空间复杂度是对算法运行时所占用的临时存储空间的度量，用大O标识为S(n)= O(f(n))； 
  我们一般所讨论的是除正常占用内存开销外的辅助存储单元规模；

  常见空间复杂度从低到高是：O(1)<O(n)<O(n^2)

  如何分析空间复杂度:
    O(1)：
    public static void intFun(int n) { 
      var intValue = n; 
      //...
    }
    当算法的存储空间大小固定，和输入的规模没有直接的关系时，空间复杂度就记作O(1),就像上边这个方法，不管你是输入10，还是100，它占用的内存都是4字节。

    O(n)：
    public static void arrayFun(int n) { 
      var array = new int[n]; 
      //...
    }
    当算法分配的空间是一个集合或者数组时，并且它的大小和输入规模n成正比时，此时空间复杂度记为O(n)。
    
    O(n^2)：
    public static void matrixFun(int n) { 
      var matrix = new int[n][n]; 
      //...
    }
    当算法分配的空间是一个二维数组，并且它的第一维度和第二维度的大小都和输入规模n成正比时，此时空间复杂度记为O(n^2) 。








总结：
---------------------
·简单来说，时间复杂度指的是语句执行次数，空间复杂度指的是算法所占的存储空间。

  一般情况下，随着n的增大，T(n)增长最慢的算法为最优算法。

  1.对于简单的输入输出语句或赋值语句(无循环语句)，近似认为需要 O(1)。一般来说，只要算法中不存在循环语句，其时间复杂度就是 O(1)。

  2.对于顺序结构，需要依次执行一系列语句所用时间可采用 "求和法则"。

  3.对于判断条件语句来说，一般是求它的最差时间复杂度。

  4.对于循环语句来说，只考虑循环体中语句的执行次数。当有若干个循环语句，则复杂度由最深层的循环内的基本语句的频度f(n)决定的。

  5.对数时间复杂度：当每次操作都能将所需要检测的元素减少一半时(即每次操作，未检测元素减少一半)，这样的时间复杂度为 O(logn)。

  6.如果一个算法的执行次数是 T(n)，那么只保留最高次项，同时忽略最高项的系数后得到函数 f(n)，此时算法的时间复杂度就是 O(f(n))。为了方便描述，下文称此为 大O推导法。推导方法：1代替常数；只保留最高阶；最高阶不是1时去掉最高阶的系数。
  
  7.时间复杂度分析的基本策略是：从内向外分析，从最深层开始分析。如果遇到  函数调用，要深入函数进行分析。

  8.O(1) 常数阶 < O(logn) 对数阶 < O(n) 线性阶 < O(nlogn) < O(n^2) 平方阶 < O(n^3) < { O(2^n) < O(n!) < O(n^n) }      
    最后三项用大括号把他们括起来是想要告诉大家，如果日后大家设计的算法推导出的“大O阶”是大括号中的这几位，那么趁早放弃这个算法，在去研究新的算法出来吧。因为大括号中的这几位即便是在 n 的规模比较小的情况下仍然要耗费大量的时间，算法的时间复杂度大的离谱，基本上就是“不可用状态”。

  9.空间复杂度为1时，表示这个变量与问题规模n大小无关。