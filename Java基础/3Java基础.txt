
·jdk里的jre与外面的jre有什么不同？
  ··为什么Sun要让JDK安装两套相同的JRE？
    JDK里的工具有些是用Java所编写，因此要使用JDK所附的工具来开发Java程序，也必须要附一套JRE才行，（如javac.exe、jar.exe等）。
    javac.exe与输入 java -cp c:/jdk/lib/tools.jar com.sun.tools.javac.Main 是一样的，可以认为javac.exe只是一个包装器（Wrapper），目的是简写指令。
    另外一套JRE就是专门用来运行开发好的Java程序用的。

  ··公用jre，就是你觉得没用的那个jre主要是为开发者开发好的java程序提供执行的平台。
    假设jdk与公用jre各安装至C:\Program Files\Java\jdk1.6.0和C:\Program Files\Java\jre1.6.0，你会看到，在jdk1.6.0目录下也有一个jre目录，只是jdk本身所附的jre，是在你开发java程序时做测试之用。

    它与公用jre的主要差别在于jdk本身所附的jre比公用jre多了个server的vm执行选项，通过对比查看C:\Program Files\Java\jdk1.6.0\jre\bin和C:\Program Files\Java\jre1.6.0\bin就可以了解。

    server与client选项的差别在于所使用的vm不同，执行java程序时默认的是client VM。若使用server VM，会花比较长的启动时间及消耗较多的内存，为的是启动程序后可以获得较好的执行性能。



·区分Java中的关键字和Java标识符：
  ··关键字：
    1.Java 语言中有一些具有特殊用途的词被称为关键字。关键字对Java的编译器有着特殊的意义，在程序中应用时一定要慎重哦！！
    最常用的就有基本数据类型，try……catch……
    2.Java关键字是区分大小写的哦！所以void是关键字，但Void就不是了~~
      这个关键字常见的坑：
      true、false、null都不是关键字；
      goto、const是保留的关键字；


  ··标识符就是用于给 Java 程序中类、变量、方法等命名的符号。

    使用标识符时，需要遵守几条规则：
     1.标识符可以由字母、数字、下划线（_）、美元符（$）组成，但不能包含@、%、空格等其它特殊字符，不能以数字开头。譬如：123name就是不合法滴；
     2.标识符不能是Java关键字和保留字（Java预留的关键字，以后的升级版本中有可能作为关键字），但可以包含关键字和保留字。如：不可以使用void作为标识符，但是Myvoid可以；
     3.标识符是严格区分大小写的。所以涅，一定要分清楚imooc和IMooc是两个不同的标识符哦！
     4.标识符的命名最好能反映出其作用，做到见名知意。




·Java内存模型：
  ··Java线程之间的通信由Java内存模型（简称为JMM）控制，JMM决定一个线程对共享变量的写入何时对另一个线程可见。

  从抽象的角度来看，JMM定义了线程和主内存之间的抽象关系：
  线程之间的共享变量存储在主内存（main memory）中，每个线程都有一个私有的本地内存（local memory），本地内存中存储了该线程以读写共享变量的副本。
  本地内存是JMM的一个抽象概念，并不真实存在。它涵盖了缓存，写缓冲区，寄存器以及其他的硬件和编译器优化。volatile变量的写-读可以实现线程之间的通信。

  从内存语义的角度来说，volatile与监视器锁有相同的效果：volatile写和监视器的释放有相同的内存语义；volatile读与监视器的获取有相同的内存语义。

  ··同一个类的对象使用不同的内存段，但静态成员共享相同的内存空间。




·Math类中提供了三个与取整有关的方法：ceil,floor,round,这些方法的作用于它们的英文名称的含义相对应；

  floor: 求小于参数的最大整数。返回double类型-----n. 地板，地面
           例如：Math.floor(-4.2) = -5.0
  -----------------------------------------------------------
  ceil:   求大于参数的最小整数。返回double类型-----vt. 装天花板；
           例如：Math.ceil(5.6) = 6.0
  -----------------------------------------------------------
  round: 对小数进行四舍五入后的结果。返回int类型
           例如：Math.round(-4.6) = -5




·关于构造方法：

  ··构造方法也是类的方法，可以在创建对象时为成员变量赋值；
  ··构造方法可以进行重载，但是参数列表必须不相同，不以返回值和访问级别进行区分；
  ··构造方法没有返回值；
  ··构造方法一定要与定义为public的类同名；
  ··由于构造器的名字必须与类名相同，而匿名类没有类名，所以匿名类不能有构造器。
  ··如果Child是class，且只有一个有参数的构造函数，那么必然会调用Parent中相同参数的构造函数。错的！因为可以调用父类无参的构造函数，子类的有参构造函数和是否调用父类的有参数的构造函数无必然联系。

  ··其实，普通的类方法是可以和类名同名的，和构造方法唯一的区分就是，构造方法没有返回值。
  ··不显示提供构造方法时，Java才提供一个默认构造方法，当我们显示的提供一个无参或带参的构造方法时，Java都不会再提供构造方法了。java的构造函数在创建对象时，就会自动调用它。
  ··构造函数不能被继承，构造方法只能被显式或隐式的调用。

  ··问题： java中子类继承父类时是否继承构造函数呢？
  ﻿﻿
            java继承中对构造函数是不继承的。

            以下是例子：

             public class FatherClass {
             public FatherClass() {
                   System.out.println(100);
             }

             public FatherClass(int age) {
                  System.out.println(age);
             }

            }

             

            public class SonClass extends FatherClass{

                    public SonClass() {
                     }
                    public SonClass(int c) {
                             System.out.println(1234);
                    }
               
             public static void main(String[] args) {

              FatherClass f = new FatherClass(28);
              SonClass s = new SonClass(66);
             
             }
            }

            编译后执行结果如下是什么呢？
            
            分析：
            1. FatherClass f = new FatherClass(28);这句没有必要解释

            2.SonClass s = new SonClass(66);执行这句时，调用

             public SonClass(int c) {
                             System.out.println(1234);
                    }
            

            在这个构造函数中，等价于

             public SonClass(int c) {

                            super();//必须是第1行，否则不能编译
                             System.out.println(1234);
                    }

            所以结果是    100
                                     1234

            3.如果子类构造函数是这样写的

            public SonClass(int c) {

                            super(22);//必须是第1行，否则不能编译

                           //显示调用了super后，系统就不再调用super();
                             System.out.println(1234);
                    }

            执行结果是   22
                                     1234

            总结1：构造函数不能继承，只是调用而已。

            如果父类没有无参构造函数

            创建子类时，不能编译，除非在构造函数代码体中第一行，必须是第一行显示调用父类有参构造函数

            如下：

            SonClass (){

                super(777);//显示调用父类有参构造函数

                System.out.println(66);

            }
            
            如果不显示调用父类有参构造函数，系统会默认调用父类无参构造函数super();

            但是父类中没有无参构造函数，那它不是不能调用了。所以编译就无法通过了。

            总结2：创建有参构造函数后，系统就不再有默认无参构造函数。

            如果没有任何构造函数，系统会默认有一个无参构造函数。
            
            
            
·值传递和引用传递：Java语言是一种强类型语言。
                  通俗点就是，在Java中存储的数据都是有类型的，而且必须在编译时就确定其类型。

    Java语言中只有按值传递。
    但是java方法参数中有两种类型：基本数据类型（Primitive types）和对象引用（Object reference）。
    基本数据类型变量存的是数据本身，而引用类型变量存的是保存数据的空间地址。
    基本数据类型是值传递（call by value），引用数据类型是引用传递（call by reference）。
    有人以为当传递Object时是Call by reference。 其实还是传递的这个reference的副本。

    ··结论：1.值传递不可以改变原变量的内容和地址；原因是java方法的形参传递都是传递原变量的副本，在方法中改变的是副本的值，而不适合原变量的。
          2.引用传递不可以改变原变量的地址，但可以改变原变量的内容；原因是当副本的引用改变时，原变量的引用并没有发生变化，当副本改变内容时，由于副本引用指向的是原变量的地址空间，所以，原变量的内容发生变化。

    ··Java中的四类八种基本数据类型：
        第一类：整数类型  byte short int long
              byte的取值范围是-128—127。报出异常： cannot convert from int to byte.
              int的取值范围为： -2^31—2^31-1，即-2147483648——2147483647；
              没有final修饰的变量相加后会被自动提升为int型。

        第二类：浮点型  float double
              long和float，正常定义需要加l和f，但是long和float属于基本类型，会进行转化，所以不会报出异常。
              Float正确复制方式是Float f=1.0f,若不加f会被识别成double型,double无法向float隐式转换.
              float占4个字节为什么比long占8个字节大呢，因为底层的实现方式不同。

        第三类：逻辑型    boolean(它只有两个值可取true false)
              boolean类型不能和任何类型进行转换，会报出类型异常错误。

        第四类：字符型  char
        除此之外都是引用类型，包括类、数组、接口。String是一种常见的引用数据类型，用来表示字符串。

        基本类型和String=""是传值，其他类型都是传引用，当然，也可以认为java只有传值，因为一个是拷贝了栈中的值，一个是拷贝了引用的地址值。

    ··表达式的数据类型自动提升, 关于类型的自动提升，注意下面的规则。
      ①所有的byte,short，char型的值将被提升为int型；
      ②如果有一个操作数是long型，计算结果是long型；
      ③如果有一个操作数是float型，计算结果是float型；
      ④如果有一个操作数是double型，计算结果是double型；




·原码、反码和补码：

      10原码：0000000000000000,0000000000001010；
      -10： 1111111111111111,1111111111110101  变为负数，计算机用补码存储
      -10反码：10000000000000000,0000000000001010
      -10补码：10000000000000000,0000000000001011，等于 -11
      故程序结果-6

      0X是16进制

      1、Java中用补码形式表示
      2、第一位正负位，1表示负，0表示正。
      3、原码：一个数的二进制表示。
                       3的原码00000011   -3的 原码 10000011
      4、反码：负数原码按位取反（符号位不变）。正数原码本身。
                      3的反码00000011   -3的反码11111100
      5、补码：正数是原码本身。负数反码加1。
                       3的补码是00000011  -3的补码是11111101
      -------------------------------------------------------------------------------
      int占4个字节，32位
      byte占1个字节，8位
      所以int强转byte时会截断前24位
      ---------------------------------------------------------------------------
      在内存中表示形式（ 注意java中是以补码表示一个数，所以表示形式是补码，不是原码！ ）：
      int a = 3         00000000  00000000  00000000 00000011 （强转byte时前面24个0被截断）
      byte b = 3      00000011
      int a = -3       11111111  11111111   11111111   11111101 （强转byte时前面24个1被截断）
      byte b = -3     11111101
      ----------------------------------------------------------------------------
      已知负数的补码，求负数：
      补码-1=反码，反码按位取反=该负数绝对值
      已知负数，求负数的补码，2种方法：
      1、负数原码除了符号位，按位取反（不含符号位），加1。
      2、负数绝对值的补码（也就是原码），按位取反（含符号位），加1
      -------------------------------------------------------------------------------
      例子：
      java int 128转为byte，值：
      128为正数，补码为10000000（前面24个0省略），变成byte，只剩下10000000（byte为1个字节），因为开头是1，所以为负数。即1个负数的补码是10000000。反码是01111111，原码是1000000，是128。因为是负数，所以是-128。



·关于static：

    ··java为什么要使用静态变量或静态方法：
      ···Java类中的静态变量在程序运行期间，其内存空间对所有该类的对象实例而言是共享的，有些时候可以认为是全局变量。因此在某些时候为了节省系统内存开销、共   享资  源，可以将类中的一些变量声明为静态变量!
      ···静态还有一个好处,可以代替包,有些时候不想用一个包,来封装一个类做一个公共的数据使用的时候,就可以通过静态属性来完成!
          工具类中的方法基本上都是静态的，直接用类名调用，不用实例化对象，方便。

    ··static变量不能使用this!!!!!!!!!!!，static方法中没有this这么一说。

    ··在类方法中不能有this关键字，直接调用类方法即可。在类方法中可以通过创建实例对象调用类的实例方法。

    静态成员属于整个类，当系统第一次使用该类时，就会为其分配内存空间直到该类被卸载才会进行资源回收！~~
    静态方法中可以直接调用同类中的静态成员，但不能直接调用非静态成员。
    静态初始化块只在类加载时执行，且只会执行一次，同时静态初始化块只能给静态变量赋值，不能初始化普通的成员变量。
    静态内部类可以访问外围类的静态数据，包括私有数据，但不能访问非静态数据；非静态内部类可以直接访问外围类的数据，包括私有数据。



·equals()和hashcode()区别：

      ··都不是final方法，所以可以override。
      ··equals（）判断2个对象是否相等；
      ··hashcode（）计算对象的哈希码；
      ··设计一个类当需要重写equals时，必须重写hashcode方法；

      ··hashcode()介绍：
        ···public native int hashCode();
        ···配合基于散列的集合【hashset、hashmap、hashtable】一起运行；
        ···集合中会有一个table保存存进去的对象的hashcode值。如果table中没有该hashcode值，它就可以直接存进去，不用再比较；如果存在，就用equals方法与新元素比较，相同则不存了，不同则散列到其他地址。
        ···hashcode方法的存在是为了减少equals方法调用次数，从而提高效率。
        ···hashcode返回的并非都是对象的存储地址，只是有所关联；默认情况下，hashcode方法是将对象的存储地址进行映射；

        ···不能根据hashcode值判断2个对象是否相等，但可以根据hashcode值判断2个对象不等；
            equals（）得到的结果是true，则两个对象的hashcode值必定相等；
            equals（）得到的结果是false，则两个对象的hashcode值不一定不等；
            两个对象的hashcode值不等，equals（）得到的结果一定是false；
            两个对象的hashcode值相等，equals（）得到的结果未知；



·equals和==区别：
                 基本类型          引用类型
  ==               值               对象地址
  equals          不能作用          对象内容




·Java编码：
  Java默认使用Unioncode编码，即不论什么语言都是一个字符占两个字节；
  Java的class文件编码为UTF-8，而虚拟机JVM编码为UTF-16；UTF-8编码下，一个中文占3个字节，一个英文占1个字节；
  Java中的char默认采用Unicode编码，所以Java中char占2个字节；

  1(byte)字节=8(bit)位，ResourceBundle能够依据Local的不同，选择性的读取与Local对应后缀的properties文件，以达到国际化的目的。

  ··Java语言中，中文字符所占的字节数取决于字符的编码方式：
    采用ISO8859-1编码方式时，一个中文字符与一个英文字符一样只占1个字节；
    采用GB2312或GBK编码方式时，一个中文字符占2个字节；
    采用UTF-8编码方式时，一个中文字符会占3个字节。

  ··常见字符的ASCII码值如下：
    空格的ASCII码值为32；
    数字0到9的ASCII码值分别为48到57；
    大写字母“A”到“Z”的ASCII码值分别为65到90；
    小写字母“a”到“z”的ASCII码值分别为97到到122。




·数组：
  ··写一下个人理解的数组声明为什么这么写？
    1.为什么左边不用标大小，而右边需要标大小？ 
    首先数组一个对象，它不属于任何类，由jvm在运行期间在堆中创建并继承object，同时添加length属性。由于数组对象所占的内存在堆上，所以在声明时应明确告诉jvm自己所占的大小，方便分配，又因为数组对象的引用在栈中，所以声明时左边就无需标大小，之所以写成2个括号，就是为了表明这个引用指向堆中的二维数组。
    
    2.为什么右边数组可以只声明几行，无需声明每行的大小？ 
    大概jvm在运行期间会根据行数分配对应的可扩展空间，方便每一行进行扩充。其实又可以按c语言那样理解，行其实又是一种引用，行首地址又代表一个一维数组。

  ··Java中数组是对象，不是基本数据类型（原生类），大小不可变且连续存储，因为是对象所以存在堆中。
  ··数组类是在运行的过程中创建的 
  ··Java中数组内容存储在连续的堆内存中，数组名（引用） 存储在栈内存中指向堆内存中的内容。

  ··在java 中，声明一个数组时，不能直接限定数组长度，只有在创建实例化对象时，才能对给定数组长度。定义一个变量时，仅仅定义了一个变量，这个引用变量还未指向任何有效的内存 。

  ··java中的数组自带length属性，例如：假设有个二维数组a[][]；  a.length就是行数，a[0].length就是列数啦；

  ··二维数组：在定义二维数组时也可以只指定行的个数，然后再为每一行分别指定列的个数。如果每行的列数不同，则创建的是不规则的二维数组。

  ··真数组： 数组元素在内存中是一个接着一个线性存放的，通过第一个元素就能访问随后的元素，避免了数据覆盖的可能性，和数据类型覆盖并没有关系。


  ··使用Arrays类操作Java中的数组：
    Arrays类是Java中提供的一个工具类，在java.util包中。该类中包含了一些方法用来直接操作数组，比如可直接实现数组的排序、搜索等。
    Arrays中常用的方法：
      1、排序
      语法：Arrays.sort(数组名);
      可以使用sort( )方法实现对数组的排序，只要将数组名放在sort( )方法的括号中，就可以完成对该数组的排序（按升序排列）。

      2、将数组转换为字符串
      语法：Arrays.toString(数组名);
      可以使用 toString( )方法将一个数组转换成字符串，该方法按顺序把多个数组元素连接在一起，多个元素之间使用逗号和空格隔开。

      Arrays.asList()方法返回的列表是Arrays.ArrayList类型的，并不是java.util.ArrayList；SimpleDateFormat是线程不安全的。



·关于泛型：

  泛型只在编译的时候保证数据类型的正确性，和运行时性能无关。
  ··只看尖括号里边的！！明确点和范围两个概念
  ··如果尖括号里的是一个类，那么尖括号里的就是一个点，比如List<A>,List<B>,List<Object>
  ··如果尖括号里面带有问号，那么代表一个范围，<? extends A> 代表小于等于A的范围，<? super A>代表大于等于A的范围，<?>代表全部范围
  ··尖括号里的所有点之间互相赋值都是错，除非是俩相同的点
  ··尖括号小范围赋值给大范围，对，大范围赋值给小范围，错。如果某点包含在某个范围里，那么可以赋值，否则，不能赋值
  ··List<?>和List 是相等的，都代表最大范围
  ----------------------------------------------------------------------------------
  ··补充：List既是点也是范围，当表示范围时，表示最大范围

    下面贴代码：
    public static void main(String[] args) {
            List<A> a;
            List list;
            list = a;   //A对，因为List就是List<?>，代表最大的范围，A只是其中的一个点，肯定被包含在内
            List<B> b;
            a = b;      //B错，点之间不能相互赋值
            List<?> qm;
            List<Object> o;
            qm = o;     //C对，List<?>代表最大的范围，List<Object>只是一个点，肯定被包含在内
            List<D> d;
            List<? extends B> downB;
            downB = d;  //D对，List<? extends B>代表小于等于B的范围，List<D>是一个点，在其中
            List<?extends A> downA;
            a = downA;  //E错，范围不能赋值给点
            a = o;      //F错，List<Object>只是一个点
            downA = downB;  //G对，小于等于A的范围包含小于等于B的范围，因为B本来就比A小，B时A的子类嘛
        }

       泛型值存在于java的编译期，编译后生成字节码文件泛型是被擦除的。




·反射：
	··通过反射机制，可以在程序运行时动态访问java对象的属性、方法、构造方法；

	··应用场景：
					1.开发通用框架；
					2.动态代理；
					3.注解；
					4.可扩展功能；

 	··Java的反射机制主要由以下来实现：
														    Class类；一个类
														    Constructor类；类的构造方法
														    Field类；类的属性
														    Method类；类的方法

	··通过反射创建对象：与传统的通过new来获取对象的方式不同，反射机制会先拿到“类对象”,然后通过类对象获取“构造器对象”，再通过构造器对象创建一个对象；

  	     eg：//使用反射的方式创建对象
  	        String className = "charactor.Hero";	包名+类名

  	        //类对象
  	        Class pClass=Class.forName(className);

  	        //构造器
  	        Constructor c= pClass.getConstructor();

  	        //通过构造器实例化
  	        Hero h2= (Hero) c.newInstance();

	··Class对象的生成方式如下：

	    1.类名.class     		 说明：JVM将使用类装载器, 将类装入内存(前提是:类还没有装入内存), 不做类的初始化工作.返回Class的对象

	    2.Class.forName("类名字符串")       注：类名字符串是包名+类名   		说明：装入类,并做类的静态初始化，返回Class的对象

        实质：实际上java的每个类被编译成.class文件的时候，jvm会自动为这个类生成一个类对象，这个对象保存了这个类的所有信息（成员变量，方法，构造器等），以后这个类要想实例化，那么都要以这个class对象为蓝图（或模版）来创建这个类的实例。
        eg：class<?> c=Class.forName("com.pojo.User"); 
            c就是User的类对象，而 User u=new User();这个u就是以c为模版创建的，其实就相当于u=c.newInstance()。

	    3.实例对象.getClass()     说明：对类进行静态初始化、非静态初始化；返回引用运行时真正所指的对象(因为:子对象的引用可能会赋给父对象的引用变量中)

  ··根据类的反射获取该类字段：
    ···getFields()：只获取该类的所有public字段，包括父类中的public字段；
    ···getDeclaredFields()：获取该类所有的字段，不包括父类中的字段；

  ··同样类似的还有getConstructors()和getDeclaredConstructors()、getMethods()和getDeclaredMethods()；





·关于Object：

    ··Object默认的基本方法中，
      没有copy()，没有hasNext()，这个方法是迭代器中的；
      含有如下方法：getClass(), hashCode(), equals(), clone(), toString(), notify(), notifyAll(), wait(), finalize()；    源代码：https://www.nowcoder.com/test/question/done?tid=16664302&qid=14830#summary

    ··Object对象类的方法：
      1．clone方法
      保护方法，实现对象的浅复制，只有实现了Cloneable接口才可以调用该方法，否则抛出CloneNotSupportedException异常。

      2．getClass方法
      final方法，获得运行时类型。
      得到父类名字用getClass.getSuperclass();

        返回：包名+类名 
            super.getClass().getName():当前类
            this.getClass().getSuperclass().getName()：父类

      3．toString方法
      该方法用得比较多，一般子类都有覆盖。
        ···System.out的println()方法只能在控制台上输出字符串，而Apple类实例是一个在内存中的对象，当用这种方法输出对象时，实际上输出的是Object类中的toString()方法返回值
        ···toString()方法是Object类里的一个实例方法，所有的Java类都是Object类的子类，所以所有Java对象都有toString()方法
        ···toString()方法是一个“自我描述”的方法，当输出某实例对象时，可以通过重写自定义等方式为对象实现输出自我描述的信息
        ···Object类的toString()方法默认返回该对象实现类的“类名+@+hashcode”值（如上结果中看到的那样），这个返回值不能实现自我描述功能，所以需要重写Object类的toString()方法来实现。

      4．finalize方法
      该方法用于释放资源。因为无法确定该方法什么时候被调用，很少使用。

      5．equals方法
      该方法是非常重要的一个方法。一般equals和==是不一样的，但是在Object中两者是一样的。子类一般都要重写这个方法。

      6．hashCode方法
      该方法用于哈希查找，重写了equals方法一般都要重写hashCode方法。这个方法在一些具有哈希功能的Collection中用到。
      一般必须满足obj1.equals(obj2)==true。可以推出obj1.hash-Code()==obj2.hashCode()，但是hashCode相等不一定就满足equals。不过为了提高效率，应该尽量使上面两个条件接近等价。

      7．wait方法
      wait方法就是使当前线程等待该对象的锁，当前线程必须是该对象的拥有者，也就是具有该对象的锁。wait()方法一直等待，直到获得锁或者被中断。wait(long timeout)设定一个超时间隔，如果在规定时间内没有获得锁就返回。
      调用该方法后当前线程进入睡眠状态，直到以下事件发生。
        （1）其他线程调用了该对象的notify方法。
        （2）其他线程调用了该对象的notifyAll方法。
        （3）其他线程调用了interrupt中断该线程。
        （4）时间间隔到了。
      此时该线程就可以被调度了，如果是被中断的话就抛出一个InterruptedException异常。

      8．notify方法
      该方法唤醒在该对象上等待的某个线程。

      9．notifyAll方法
      该方法唤醒在该对象上等待的所有线程。
      这种类型的题一般考察点有两个：
        ···Object中没有hasNext（） 方式，这个方法是迭代器中的
        ···Object没有copy方法，但是有clone()方法， 用于创建并返回该对象的一个副本

    ··所有类都是object的子类，但是你用一个类A继承了object，在用一个类B继承A，object类提供的方法B类里也是可以使用的。




·AOP 和 OOP的区别：
  ··面向方面编程 AOP 偏重业务处理过程的某个步骤或阶段，强调降低模块之间的耦合度，使代码拥有更好的移植性。AOP是面向业务中的动词领域。
  ··面向对象编程 (oop) 则是对业务分析中抽取的实体进行方法和属性的封装。OOP面向名词领域。

  AOP 的一个很重要的特点是源代码无关性，也就是说如果我们的系统中引用了AOP组件，即使我们把该组件去掉，系统代码也应该能够编译通过。要实现这一点，可以使用动态proxy模式。



·在Applet中：
  init(): 初始化；
  start() 激活；
  stop(): 当Applet被覆盖时，可用stop()方法停止线程， 典型作用是挂起一个线程；
  destroy() ：终止Applet,释放Applet的所有资源



·一条进程的栈区、堆区、数据区和代码区在内存中的映射：
  ··栈区：主要用来存放局部变量, 传递参数, 存放函数的返回地址。.esp 始终指向栈顶, 栈中的数据越多, esp的值越小。

  ··堆区：用于存放动态分配的对象, 当你使用 malloc和new 等进行分配时,所得到的空间就在堆中。动态分配得到的内存区域附带有分配信息, 所以你　 能够 free和delete它们。

  ··数据区：全局，静态和常量是分配在数据区中的，数据区包括bss（未初始化数据区）和初始化数据区。

  ··注意：
    1)堆向高内存地址生长；
    2)栈向低内存地址生长；
    3)堆和栈相向而生，堆和栈之间有个临界点，称为stkbrk。
