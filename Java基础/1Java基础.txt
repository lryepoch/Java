
·Java命名格式：
    包名：一律采用小写。

    类名：首字母大写 、其余组成词依次首字母大写。

    方法名：首字母小写、其余组成词首字母大写。

    属性（变量名）：
    个人理解 分两种情况：1、变量名由多单词组成时，第一个单词的首字母小写，其后单词的首字母大写，俗称骆驼式命名法（也称驼峰命名法），如 myAge；
                       2、变量命名时，尽量简短且能清楚的表达变量的作用，做到见名知意。如：定义变量名 stuName 保存“学生姓名”信息；

       a：全局变量：大写规范。

       b：局部变量：小写规范。

       c：属性、常量：大写规范。



·Java中的逻辑运算符?
  
  位运算主要包括按位与(&)、按位或(|)、按位异或(^)、取反(~)、左移(<<)、右移(>>)这几种，其中除了取反(~)以外，其他的都是二目运算符，即要求运算符左右两侧均有一个运算量。

  &&：逻辑与，短路与
  !：逻辑非
  ||：逻辑或，短路或
  ^：逻辑异或

  简述逻辑操作(&,|,^)与条件操作(&&,||)的区别？

  答：区别主要有两点：a.条件操作只能操作布尔型的,而逻辑操作不仅可以操作布尔型,而且可以操作数值型；
  					  b.逻辑操作不会产生短路。

  <<(向左位移)：针对二进制，转换成二进制后向左移动3位，后面用0补齐；
                public static void main(String[] args) {
                         System.out.println("2<<3运算的结果是 :"+(2<<3));
                         //打印的结果是:   2<<3运算的结果是 :16
                     }

  >>(向右位移)：针对二进制，转换成二进制后向右移动3位，右移后左边的空位被填充为符号位；
                public static void main(String[] args) {
                         System.out.println("2>>3运算的结果是 :"+(2>>3));
                         //打印的结果是:   2>>3运算的结果是 :0
                     }

  >>>(无符号右移)：无符号右移，忽略符号位，左边的空位都以0补齐；
      10进制转二进制的时候，因为二进制数一般分8位、 16位、32位以及64位表示一个十进制数，所以在转换过程中，最高位会补零；
      在计算机中负数采用二进制的补码表示，10进制转为二进制得到的是原码。


  >>>与>>唯一的不同是它无论原来的最左边是什么数，统统都用0填充。
      eg：byte是8位的，-1表示为byte型是11111111(补码表示法），b>>>4就是无符号右移4位，即00001111，这样结果就是15。

  没有<<<：因为<<后右边总是补0。


·抽象类和接口：
	··修饰符的使用：
		···抽象类除了抽象方法在jdk1.8以后改成默认default外，其他的与普通类无区别。 抽象类可以实现接口。

			JDK 1.8以前，抽象类的方法默认访问权限为protected
			JDK 1.8时，抽象类的方法默认访问权限变为default

			抽象类不仅可以被继承，还可以直接拿来使用的，当然，这个使用是拿来声明，而不是实例化，因为抽象类不能实例化，但可以声明使用。就像接口一样。可以动态绑定地实现多态，如下例子，AbstractMap就是抽象类，它可以这样使用。
			        AbstractMap<String, Integer> am = new HashMap<String, Integer>();  
		              am.put("young", 23);
		              am.put("strongyoung", 26);
		              Iterator<String> itr = am.keySet().iterator();
		              while(itr.hasNext()){                   //hasNext（）
		                  String key = itr.next();
		                  System.out.println(key + " : " + am.get(key));
		              }


		···接口所有方法全是抽象方法只能 public abstract修饰 （默认public abstract修饰 ），属性默认public static final修饰。

			JDK 1.8以前，接口中的方法必须是public的
			JDK 1.8时，接口中的方法可以是public的，也可以是default的
			JDK 1.9时，接口中的方法可以是private的


	··区别：
			1、设计目的：接口体现的一种规范，类似与整个系统的总纲，制订了系统各模块应该遵循的标准，因此接口不应该经常改变，一旦改变对整个系统是辐射性的。
			            抽象类作为多个子类的共同父类，体现的是一种模板式设计，可以当作系统实现过程中的中间产品，已经实现了系统部分功能。

	        2、使用不同：（1）接口只能包含抽象方法，抽象类可以包含普通方法。
	                   （2）接口里不能定义静态方法，抽象类可以。
	                   （3）接口只能定义静态常量属性不能定义普通属性，抽象类可以。
	                   （4）接口不包含构造器，抽象类可以（不是用于创建对象而是让子类完成初始化）。
	                   （5）接口里不能包含初始化块，抽象类完全可以。
	                   （6）接口多继承，抽象类单继承（只能有一个直接父类）。




·内部类：

	··对于外部类来说，只有两种修饰，public和默认（default）。因为外部类放在包中只有两种可能：包可见和包不可见。

	··对于内部类来说，可以有所有的修饰，因为内部类放在外部类中，与成员变量的地位一致，所以有四种可能。

		1.为什么使用内部类?
		使用内部类最吸引人的原因是：每个内部类都能独立地继承一个（接口的）实现，所以无论外围类是否已经继承了某个（接口的）实现，对于内部类都没有影响。

		使用内部类最大的优点就在于它能够非常好的解决多重继承的问题,使用内部类还能够为我们带来如下特性:
			>内部类可以用多个实例，每个实例都有自己的状态信息，并且与其他外围对象的信息相互独立 。
			>在单个外围类中，可以让多个内部类以不同的方式实现同一个接口，或者继承同一个类。
			>创建内部类对象的时刻并不依赖于外围类对象的创建。
			>内部类并没有令人迷惑的“is-a”关系，他就是一个独立的实体。
			>内部类提供了更好的封装，除了该外围类，其他类都不能访问。
			>定义内部类的好处是外部类可以访问内部类的所有方法和属性，包括私有方法和私有属性。


		2.内部类分类:

		(一).成员内部类:
			public class Outer{
			        private int age = 99;
			        String name = "Coco";
			        public class Inner{
			            String name = "Jayden";
			            public void show(){
			                System.out.println(Outer.this.name);		访问外部类的成员变量
			                System.out.println(name);
			                System.out.println(age);
			            }
			        }
			        public Inner getInnerClass(){
			            return new Inner();
			        }
			        public static void main(String[] args){
			            Outer o = new Outer();
			            Inner in = o.new Inner();
			            in.show();
			        }
			    }
				1.Inner 类定义在 Outer 类的内部，相当于 Outer 类的一个成员变量的位置，Inner 类可以使用任意访问控制符，如 public 、 protected 、 private 等
				2.Inner 类中定义的 show() 方法可以直接访问 Outer 类中的数据，而不受访问控制符的影响，如直接访问 Outer 类中的私有属性age。

				3.定义了成员内部类后，必须使用外部类对象来创建内部类对象，而不能直接去 new 一个内部类对象，即：内部类 对象名 = 外部类对象.new 内部类( );
				4.编译上面的程序后，会发现产生了两个 .class 文件: Outer.class,Outer$Inner.class{}

				5.成员内部类中不能存在任何 static 的变量和方法,可以定义常量:
					(1).因为非静态内部类是要依赖于外部类的实例,而静态变量和方法是不依赖于对象的,仅与类相关；简而言之:在加载静态域时,根本没有外部类,所以在非静态内部类中不能定义静态域或方法,编译不通过;非静态内部类的作用域是实例级别；
					(2).常量是在编译期就确定的,放到所谓的常量池了；

				★★友情提示:
				1.外部类是不能直接使用内部类的成员和方法的，可先创建内部类的对象，然后通过内部类的对象来访问其成员变量和方法;
				2.如果外部类和内部类具有相同的成员变量或方法，内部类默认访问自己的成员变量或方法，如果要访问外部类的成员变量，
				可以使用 this 关键字,如:Outer.this.name


		(二).静态内部类: 是 static 修饰的内部类：
				
				静态内部类才可以声明静态方法；静态方法不可以使用非静态变量；

				1.静态内部类不能直接访问外部类的非静态成员，但可以通过 new 外部类().成员 的方式访问 ；

				2.如果外部类的静态成员与内部类的成员名称相同，可通过“类名.静态成员”访问外部类的静态成员；
				如果外部类的静态成员与内部类的成员名称不相同，则可通过“成员名”直接调用外部类的静态成员；

				3.创建静态内部类的对象时，不需要外部类的对象，可以直接创建 内部类 对象名 = new 内部类()；

				public class Outer{
				            private int age = 99;
				            static String name = "Coco";
				            public static class Inner{
				                String name = "Jayden";
				                public void show(){
				                    System.out.println(Outer.name);			访问外部类的静态成员
				                    System.out.println(name);                  
				                }
				            }
				            public static void main(String[] args){
				                Inner i = new Inner();			可以直接创建 内部类 对象名 = new 内部类()；
				                i.show();
				            }
				        }

					内部类其实和类的属性没什么区别：
						public class Enclosingone {
						    //非静态内部类
						    public class InsideOne {}
						    //静态内部类
						    public static class InsideTwo{}
						}
						 
						class Mytest02{
						    public static void main(String args []){
						        Enclosingone.InsideOne obj1 = new Enclosingone().new InsideOne();//非静态内部类对象
						        Enclosingone.InsideTwo obj2 = new Enclosingone.InsideTwo();//静态内部类对象
						    }
						}


		(三).方法内部类：其作用域仅限于方法内，方法外部无法访问该内部类
			(1).局部内部类就像是方法里面的一个局部变量一样，是不能有 public、protected、private 以及 static 修饰符的

			(2).只能访问方法中定义的 final 类型的局部变量,因为:
			当方法被调用运行完毕之后，局部变量就已消亡了。但内部类对象可能还存在，直到没有被引用时才会消亡。此时就会出现一种情况，就是内部类要访问一个不存在的局部变量；	==>使用final修饰符不仅会保持对象的引用不会改变,而且编译器还会持续维护这个对象在回调方法中的生命周期。
			局部内部类并不是直接调用方法传进来的参数，而是内部类将传进来的参数通过自己的构造器备份到了自己的内部，自己内部的方法调用的实际是自己的属性而不是外部类方法的参数；防止被篡改数据,而导致内部类得到的值不一致。

	         /*
			使用的形参为何要为 final???
			在内部类中的属性和外部方法的参数两者从外表上看是同一个东西，但实际上却不是，所以他们两者是可以任意变化的，也就是说在内部类中我对属性的改变并不会影响到外部的形参，而然这从程序员的角度来看这是不可行的，毕竟站在程序的角度来看这两个根本就是同一个，如果内部类该变了，而外部方法的形参却没有改变这是难以理解和不可接受的，所以为了保持参数的一致性，就规定使用 final 来避免形参的不改变；
	         */

		        public class Outer{
		            public void Show(){
		                final int a = 25;
		                int b = 13;
		                class Inner{
		                    int c = 2;
		                    public void print(){
		                        System.out.println("访问外部类:" + a);
		                        System.out.println("访问内部类:" + c);
		                    }
		                }
		                Inner i = new Inner();
		                i.print();
		            }
		            public static void main(String[] args){
		                Outer o = new Outer();
		                o.show();
		            }
		        }    
			(3).注意:在JDK8版本之中,方法内部类中调用方法中的局部变量,可以不需要修饰为 final,匿名内部类也是一样的，主要是JDK8之后增加了 Effectively final 功能
			http://docs.oracle.com/javase/tutorial/java/javaOO/localclasses.html
			反编译jdk8编译之后的class文件,发现内部类引用外部的局部变量都是 final 修饰的


		(四).匿名内部类:
				(1).匿名内部类是直接使用 new 来生成一个对象的引用;
				(2).对于匿名内部类的使用它是存在一个缺陷的，就是它仅能被使用一次，创建匿名内部类时它会立即创建一个该类的实例，该类的定义会立即消失，所以匿名内部类是不能够被重复使用;
				(3).使用匿名内部类时，我们必须是继承一个类或者实现一个接口，但是两者不可兼得，同时也只能继承一个类或者实现一个接口;
				(4).匿名内部类中是不能定义构造函数的,  匿名内部类中不能存在任何的     静态成员变量和    静态方法;
				(5).匿名内部类不能是抽象的,它必须要实现继承的类或者实现的接口的所有抽象方法；
				(6).匿名内部类初始化：使用构造代码块！利用构造代码块能够达到为匿名内部类创建一个构造器的效果；

				匿名内部类用法与局部内部类不一致，首先从定义上就不一样，匿名类用在任何允许存在表达式的地方，而局部内部类用于在任何允许出现局部变量的地方出现。还有更重要的是匿名类只能使用一次，而局部类则可以在自己的定义域内多次使用。成员内部类位于外部类内部，可以直接调用外部类的所有方法（静态方法和非静态方法）

				匿名内部类是什么？
				关于 “Java 内部类 ” 和 "Java 继承、多态与类的复用" 的更详细的阐述，请查看我的两篇博文 “http://blog.csdn.net/justloveyou_/article/details/53245561” 和 
				“http://blog.csdn.net/justloveyou_/article/details/52798666”。 

		  public class OuterClass {
		            public InnerClass getInnerClass(final int num，String str2){
		                return new InnerClass(){
				                    int number = num + 3;
				                    public int getNumber(){
				                        return number;
				                    }
		                    };        /* 注意：分号不能省 */
		            }
		            public static void main(String[] args) {
		                OuterClass out = new OuterClass();
		                InnerClass inner = out.getInnerClass(2, "chenssy");
		                System.out.println(inner.getNumber());
		            }
		        }
		        interface InnerClass {			//接口
		            int getNumber();				//接口方法
             }         

		所谓的匿名内部类就是一个没有显式的名字的内部类，在实际开发中，此种内部类用的是非常多的。
		本质：匿名内部类会隐式的继承一个类或者实现一个接口，或者说，匿名内部类是一个继承了该类或者实现了该接口的子类匿名对象。
		格式：
				new 类名/接口/抽象类(){
					//实现的是它的实现类
				}

		public class Outer{
			public void method(){
				new inner(){
					public void info(){
						sout("helloworld");
					}
				}.info();
			}
			public static void main(String[] args){
				Outer outer = new Outer();
				outer.method();
			}
		}

		interface inner{
			public void info();
		}

		总结：通过程序看出，实际上我们的inner是一个接口，本身接口是不能直接new的，但是呢却又发现我们在new的时候，inner这个接口后面带了一对花括号，那么这个就表示实际上我现在new的是这个接口的实现类。但是发现，这个实现类是没有名字的。



·面向对象的五大基本原则： 
	··单一职责原则：一个类，最好只做一件事，只有一个引起它的变化。单一职责原则可以看做是低耦合、高内聚在面向对象原则上的引申，将职责定义为引起变化的原因，以提高内聚性来减少引起变化的原因。 
	··开放封闭原则（Open-Closed principle）：软件实体应该是可扩展的，而不可修改的。也就是，对扩展开放，对修改封闭的。 
	··里氏替换原则：子类必须能够替换其基类。这一思想体现为对继承机制的约束规范，只有子类能够替换基类时，才能保证系统在运行期内识别子类，这是保证继承复用的基础。 
	··依赖倒置原则：依赖于抽象。具体而言就是高层模块不依赖于底层模块，二者都同依赖于抽象；抽象不依赖于具体，具体依赖于抽象。 
	··接口隔离原则（Interface-Segregation Principle）：使用多个小的专门的接口，而不要使用一个大的总接口。



·this和super：

	this：
		1.this代表当前对象；
				this.属性：操作当前对象的属性；
				this.方法：调用当前对象的方法；
		2.封装对象的属性的时候，经常会使用this；

	super：
		1.在对象的内部使用，可以代表父类对象；
		2.访问父类属性：super.age；
		  访问父类方法：super.eat()；

		3.访问构造方法：super（……）；

	this()和super()为构造方法，作用是在JVM堆中构建出一个对象，因此避免多次创建对象，同一个方法内只能调用一次this()或super()。
	为了避免操作对象时对象还未构建成功，需要this()和super()的调用在第一行实现【以此来创建对象】，防止异常。
	this和super不可能同时出现在一个构造函数里。
	this是对重载的构造函数调用，super是对父类的构造函数调用。

	注意：
		1.在子类的构造过程当中，必须调用其父类的构造方法。
		2.如果子类构造方法中没有显示调用父类的构造方法，则系统默认调用父类无参的构造方法；
		3.如果显示的调用构造方法，必须在子类的构造方法的第一行；
		4.如果子类构造方法中既没有显示调用父类的构造方法，而父类又没有无参的构造方法，则编译出错；
		


·两种多态:重载和重写区别：
	静态联编是指编译时多态，动态联编是指运行时多态。
	在重载中，运用的是静态多分派，即根据静态类型确定对象，因此不是根据new的类型确定调用的方法;
	在覆盖中，运用的是动态单分配，是根据new的类型确定对象，从而确定调用的方法。


	··重载是Java多态性（在一个类中）的一种表现方式，要注意以下几点：
	    1.参数列表不同。包括参数个数、参数类型、参数顺序等的不同；
	    2.不能通过方法的访问权限、返回值类型和抛出的异常类型来判断重载；
	    3.对于继承来说，如果父类方法的访问权限为private，那么就不能在子类对其重载；如果子类也定义了一个同名的函数，只是一个新方法，并不是重载方法；
	    4.构造方法也可以重载。

	··重写又称覆盖，方法的重写（override）有两同两小一大原则：
		1.方法名相同，参数类型相同；
		2.子类返回类型小于等于父类方法返回类型，
		3.子类抛出异常小于等于父类方法抛出异常，
		4.子类访问权限大于等于父类方法访问权限。

		方法重写的注意事项：
			构造方法不能被重写，不要问为什么？因为构造方法名必须和类名相同；
			private修饰的成员方法不能被重写；
			static修饰的方法不能被重写；
			final修饰的方法不能被重写；
			当子类重写了父类中的方法后，子类对象调用该方法时，调用的是子类重写后的方法。


	一个类中，可以有多个main方法，这是重载，但是public static void main(String[] args)的方法只能有一个。
    一个文件中，可以有多个public class，即，外部类为public，还可以有public的内部类。
      public class Main {
               public class Inner{

          }
      }
    类中，可以有main方法，也可以没有main方法，而有一个main()方法的时候，也可以是任意访问权限。因为这个类不一定要执行，可以只是辅助类。



·final、finally、finalize的区别：

	··关于final：
	        final可以修饰类、方法、变量，分别表示：该类不可继承、该方法不能重写、该变量是常量；
	        final修饰的变量，他的类型不可再改变，即便进行了相关的运算也不会改变。这里是指引用变量不能变，引用变量所指向的对象中的内容还是可以改变的。
			被final修饰的变量不会自动转型。
			对于引用类型，被final修饰的变量不可更改其引用地址（当重新new时），但是可以更改其内部属性（通过setter方法）。
	        final成员变量必须在声明的时候初始化或者在构造器中初始化，否则就会报编译错误。
	        本地变量必须在声明时赋值。
	        在匿名类中所有变量都必须是final变量。


	··关于finally：
		···finally语句在try或catch中的return语句执行之后返回之前执行，且finally里的修改语句不能影响try或catch中return已经确定的返回值。若finally里也有return语句则覆盖try或catch中的return语句直接返回。

		···详细执行过程如下：
			如果try有返回值，就把返回值保存到局部变量中；
			执行jsr指令跳到finally语句里执行；
			执行完finally语句后，返回之前保存在局部变量表里的值。
			如果try，finally语句里均有return，忽略try的return，而使用finally的return.

			使用try时，catch和finally必须存在一个。
			finally语句总是要执行的，当finally语句中也有return时，会覆盖try/catch语句块的return，所以一般不要在finally中加return语句。

		···谁说finally块必须执行？不服来辩：try-catch-finally块中，finally块在以下几种情况将不会执行。
			1.finally块中发生了异常。
			2.程序所在线程死亡。
			3.在前面的代码中用了System.exit（）；
			4.关闭了CPU


	··finalize方法：
		Java技术允许使用finalize()方法在垃圾收集器将对象从内存中清除出去之前做必要的清理工作。
		这个方法是由垃圾收集器在确定这个对象没有被引用时对这个对象调用的。
		它是在 Object 类中定义的，因此所有的类都继承了它。子类覆盖 finalize() 方法以整理系统资源或者执行其他清理工作。
		finalize()方法是在垃圾收集器删除对象之前对这个对象调用的。
		注意：finalize()不一定被jvm调用，只有当垃圾回收器要清除垃圾时才被调用。

		深入理解java虚拟机中说到：当对象不可达后，仍需要两次标记才会被回收，首先垃圾收集器会先执行对象的finalize方法，但不保证会执行完毕（死循环或执行很缓慢的情况会被强行终止），此为第一次标记。第二次检查时，如果对象仍然不可达，才会执行回收。



·访问控制符：
	··public：可以被所有其他类所访问
		1.在一个文件中,有且只能有一个public类,该类与文件同名
		2.在一个文件中,可以不存在public类
		3.在一个文件中,可以不存在与文件同名的类(前提是此文件中没有public类)

	··protected：自身、子类及同一个包中类可以访问；
	··default：同一包中的类可以访问，声明时没有加修饰符，认为是friendly。default不能修饰变量；
	··private：只能被自己访问和修改；


·成员变量和局部变量的区别：
		··成员变量是独立于方法外的变量，局部变量是类的方法中的变量
			1.成员变量：包括实例变量和类变量，用static修饰的是类变量，不用static修饰的是实例变量，所有类的成员变量可以通过this来引用。
			2.局部变量：包括形参，方法局部变量，代码块局部变量，存在于方法的参数列表和方法定义中以及代码块中。

		··成员变量可以被public，protect，private，static等修饰符修饰，而局部变量不能被访问控制修饰符及static修饰；两者都可以定义成final型。

		··成员变量存储在堆，局部变量存储在栈。成员变量的作用域在整个类内部都是可见的，所有成员方法都可以使用它。如果访问权限允许，还可以在类的外部使用成员变量。局部变量的作用域仅限于定义它的方法，在该方法的外部无法访问它。

		··类的成员变量，如果是实例成员变量，它和对象的生存期相同。而静态成员变量的生存期是整个程序运行期。局部变量的生存周期与方法的执行期相同。当方法执行到定义局部变量的语句时，局部变量被创建；执行到它所在的作用域的最后一条语句时，局部变量被销毁。

		··成员变量在类加载或实例被创建时，系统自动分配内存空间，并在分配空间后自动为成员变量指定初始化值，初始化值为默认值，基本类型的默认值为0，复合类型的默认值为null（被final修饰且没有static的必须显式赋值）。局部变量在定义后必须经过显式初始化后才能使用，系统不会为局部变量执行初始化。

		··局部变量可以和成员变量同名，且在使用时，局部变量具有更高的优先级，直接使用同名访问，访问的是局部变量，如需要访问成员变量可以用this。



·父类和子类的关系：
	··如果子类构造器没有显示地调用超类的构造器，则将自动地调用超类默认（没有参数）的构造器。如果超类没有不带参数的构造器，并且在子类的构造器中没有显示地调用超类的其他构造器，则Java编译器将报告错误。使用super调用构造器的语句必须是子类构造器的第一条语句。

	··调用构造方法时，调用父类的构造方法就用super，调用本类的构造方法就用this。

	··在一个子类被创建的时候，首先会在内存中创建一个父类对象，然后在父类对象外部放上子类独有的属性，两者合起来形成一个子类的对象。所以所谓的继承使子类拥有父类所有的属性和方法其实可以这样理解，子类对象确实拥有父类对象中所有的属性和方法，但是父类对象中的私有属性和方法，子类是无法访问到的，只是拥有，但不能使用。就像有些东西你可能拥有，但是你并不能使用。所以子类对象是绝对大于父类对象的，所谓的子类对象只能继承父类非私有的属性及方法的说法是错误的。可以继承，只是无法访问到而已。？？？？？？？？？？？？？

	··子类构造函数调用父类构造函数用super；子类重写父类方法后，若想调用父类中被重写的方法，用super；未被重写的方法可以直接调用。
		子类也可以new一个父类对象，然后调用父类方法，并不一定要使用super方法。

	··JAVA子类重写继承的方法时,不可以降低方法的访问权限，子类继承父类的访问修饰符要比父类的更大，也就是更加开放，假如我父类是protected修饰的，其子类只能是protected或者public，绝对不能是friendly(默认的访问范围)或者private，当然使用private就不是继承了。还要注意的是，继承当中子类抛出的异常必须是父类抛出的异常的子异常，或者子类抛出的异常要比父类抛出的异常要少。



·在继承中代码的执行顺序为：静态>非静态，父类>子类,（同类下）非静态>构造
                          1.父类静态对象，父类静态代码块
                          2.子类静态对象，子类静态代码块
                          3.父类非静态对象，父类非静态代码块
                          4.父类构造函数
                          5.子类非静态对象，子类非静态代码块
                          6.子类构造函数

		并不是静态块最先初始化,而是静态域，而静态域中包含静态变量、静态块和静态方法,其中需要初始化的是静态变量和静态块。而他们两个的初始化顺序是靠他们俩的位置决定的!

		静态块：用static申明，JVM加载类时执行，仅执行一次
		构造块：类中直接用{}定义，每一次创建对象时执行
		执行顺序优先级：静态块>main()>构造块>构造方法



·String/StringBuilder/StringBuffer区别：
		首先，主要区别是运算速度和线程安全。
		1.运算速度：StringBuilder>StringBuffer>String;
		(Java中对String对象进行的操作实际上是一个不断创建新的对象并且将旧的对象回收的一个过程，所以执行速度很慢。而StringBuilder和StringBuffer的
			对象是变量，对变量进行操作就是直接对该对象进行更改，而不进行创建和回收的操作，所以速度要比String快很多。)

		2.StringBuilder线程不安全，StringBuffer线程安全。
		如果一个StringBuffer对象在字符串缓冲区被多个线程使用时，StringBuffer中很多方法可以带有synchronized关键字，所以可以保证线程是安全的，但
		StringBuilder的方法则没有该关键字，所以不能保证线程安全，有可能会出现一些错误的操作。所以如果要进行的操作是多线程的，那么就要使用StringBuffer，
		但是在单线程的情况下，还是建议使用速度比较快的StringBuilder。

		3. 总结一下
		　　String：适用于少量的字符串操作的情况；
		　　StringBuilder：适用于单线程下在字符缓冲区进行大量操作的情况；
		　　StringBuffer：适用多线程下在字符缓冲区进行大量操作的情况；


·关于String类：
		··它是final类型的，不能继承和修改这个类。str=“tesk ok”，其实是隐含的让Java生成一个新的String对象，那么就与原来的“Hello”没有任何关
		系，当函数结束，str作用结束，所以输出的还是“Hello”。 char ch[] 是传递引用，修改了原内容。对于图片"Java只有值传递"中的解答，有要注意的点：
		1.Java只有值传递，所谓的引用传递其实是对象地址的值传递。
		2.String = "test OK" 并不是在栈中开辟空间，而是在堆中的常量池中开辟的。

		··putchar只能输出一个字符，puts只能输出一个串。多型就是数据元素的类型不确定。
			字符串常量:以双引号引起来的数据，如"he123" "a"。
			字符常量:以单引号引起的一个字符，如'a' '\n'。
			字符串的子串，就是字符串中的某一个连续片段。截取一个字符串长度需要一个起始位置和结束位置。n(n+1）/2   + 1 （+1包括空串）

		··空字符串和null的区别：null代表堆内存中根本没有这个东西，而空字符串也是字符串，是有内存空间的。

		··String s=null;没有给s开辟任何空间，当执行length()方法时候，因为没有具体指向的内存空间，所以报出NullPointerException。出现异常主要是因为执行了s.length()这句话.

		··String(byte[] bytes, String charsetName)
          通过使用指定的 charset 解码指定的 byte 数组，构造一个新的String。
          byte[]	getBytes(String charsetName)
          使用指定的字符集将此String编码为 byte 序列，并将结果存储到一个新的 byte 数组中。

        ··String x="fmn";  “fmn”是在常量池里的不可变对象。
			x.toUpperCase();   在堆中new一个"FMN"对象，但无任何引用指向它。
			String y=x.replace('f','F'); 在堆中 new一个"Fmn"对象，y指向它。
			y=y+"wxy"; 在堆中重新new一个"Fmnwxy"对象， 修改y指向，现在y指向它。

		··只有在String类中，equals（）方法返回的才是对象的内容的比较。

		··String str1="hello";    这样创建字符串是存在于常量池中
			String str2=new String("hello");    str2存在于堆中

			==是验证两个对象是否是一个（内存地址是否相同）
			用+拼接字符串时会创建一个新对象再返回。

		··char[] ch = new char[3];//默认空格
			int[] i = new int[2];//默认0
			String[] strings = new String[2];//默认null

		··String s = "hello";
			String t = "hello";
			char[] c = {'h','e','1','1','o'};
			System.out.println(s.equals (t)); //true  s和t指向内存常量区的同一个字符串;
			System.out.println(t.equals (c));//false 一个返回字符串，一个返回对象;
			System.out.println(s==t);// true  s和t指向内存常量区的同一个字符串;
			System.out.println(t.equals (new String ("hello")));//true equal用于比较两个对象的值是否相同,和内存地址无关

		··String str1 = "hello";这里的str1指的是方法区的字符串常量池中的“hello”，编译时期就知道的； String str2 = "he" + new String("llo");这里的str2必须在运行时才知道str2是什么，所以它是指向的是堆里定义的字符串“hello”，所以这两个引用是不一样的。
		如果用str1.equal(str2)，那么返回的是True；因为两个字符串的内容一样。




·java向上转型和向下转型【包括类和接口的转型】https://jingyan.baidu.com/article/eae07827bcbbab1fec54853e.html

	··向上转型：指子类对象转换为父类对象。
		1.父类 对象= new 子类，无需强转，丢弃子类的方法。
		2.当调用对象的方法时，如果子类有覆盖方法，就听从子类的方法。
		3.如果调用父类没有的方法，编译会出错。要想调用的话需要先通过向下转型，SON son=(SON)base强制转换，然后用son.methodB()调用就可以了。
		

	··向下转型：	父类引用的对象转换为子类类型。
		1.子类 = （子类）父类对象，要强转。
		2.对象调用子类覆盖的方法，听子类的。
		3.当调用子类没有的方法，则听从父类的方法。

		如果 父类 对象= new 父类； 子类 =（子类）父类；这种情况，编译没有错，运行的时候会提示ClassCastException（类转换异常）错误，
		如果 父类 对象= new 子类；子类 =（子类）父类；这种情况，编译和运行都没有错。



·Java中成员变量的隐藏：

	··Java文档中对隐藏域的定义：

			在一个类中，子类中的成员变量如果和父类中的成员变量同名，那么即使他们类型不一样，只要名字一样。父类中的成员变量都会被隐藏。在子类中，父类的成员变量不能被简单的用引用来访问。而是，必须从父类的引用获得父类被隐藏的成员变量，一般来说，我们不推荐隐藏成员变量，因为这样会使代码变得难以阅读。

			其实，简单来说，就是子类不会去重写覆盖父类的成员变量，所以成员变量的访问不能像方法一样使用多态去访问。

	··如何访问被隐藏的成员变量？

		其实，通过前面的例子，和刚刚关于成员变量的介绍，其实你已经知道了如何访问被隐藏的成员变量。 就是使用父类的引用来访问成员变量，如Super c2 = new Sub(); System.out.println(" c2.s : " + c2.s);。或者使用System.out.println(((Super)c1).s);。




·关于null
  null是关键字，NULL不是关键字，java区分大小写。
  null表示没有地址；null可以赋值给引用变量，不能将null赋给基本类型变量。

  ··null是代表不确定的对象
   
            Java中，null是一个关键字，用来标识一个不确定的对象。因此可以将null赋给引用类型变量，但不可以将null赋给基本类型变量。
             
            比如：int a = null;是错误的。Ojbect o = null是正确的。
             
            Java中，变量的适用都遵循一个原则，先定义，并且初始化后，才可以使用。我们不能int a后，不给a指定值，就去打印a的值。这条对对于引用类型变量也是适用的。
             
            有时候，我们定义一个引用类型变量，在刚开始的时候，无法给出一个确定的值，但是不指定值，程序可能会在try语句块中初始化值。这时候，我们下面使用变量的时候就会报错。这时候，可以先给变量指定一个null值，问题就解决了。例如：
             
                    Connection conn = null;
                    try {
                        conn = DriverManager.getConnection("url", "user", "password");
                    } catch (SQLException e) {
                        e.printStackTrace();
                    }
             
                    String catalog = conn.getCatalog();
             
            如果刚开始的时候不指定conn = null，则最后一句就会报错。
   
  ··null本身不是对象，也不是Objcet的实例
   
          null本身虽然能代表一个不确定的对象，但就null本身来说，它不是对象，也不知道什么类型，也不是java.lang.Object的实例。
          可以做一个简单的例子：
           
                  //null是对象吗? 属于Object类型吗?
                  if (null instanceof java.lang.Object) {
                      System.out.println("null属于java.lang.Object类型");
                  } else {
                      System.out.println("null不属于java.lang.Object类型");
                  }
           
          结果会输出：null不属于java.lang.Object类型
   
  ··Java默认给变量赋值
   
          在定义变量的时候，如果定义后没有给变量赋值，则Java在运行时会自动给变量赋值。赋值原则是整数类型int、byte、short、long的自动赋值为0，带小数点的float、double自动赋值为0.0，boolean的自动赋值为false，其他各供引用类型变量自动赋值为null。
          这个具体可以通过调试来看。
   
  ··容器类型与null
   
          List：允许重复元素，可以加入任意多个null。
          Set：不允许重复元素，最多可以加入一个null。
          Map：Map的key最多可以加入一个null，value字段没有限制。
          数组：基本类型数组，定义后，如果不给定初始值，则java运行时会自动给定值。引用类型数组，不给定初始值，则所有的元素值为null。
   
  ··null的其他作用
   
      1.判断一个引用类型数据是否null。 用==来判断。
      2.释放内存，让一个非null的引用类型变量指向null。这样这个对象就不再被任何对象应用了。等待JVM垃圾回收机制去回收。

      3.Arrays.asList()
        将一个数组转化为一个List对象，这个方法会返回一个ArrayList类型的对象， 这个ArrayList类并非java.util.ArrayList类，而是Arrays类的静态内部类！用这个对象对列表进行添加删除更新操作，就会报UnsupportedOperationException异常。




·Java装箱和拆箱：
  装箱：值类型转换为引用类型；
  拆箱：引用类型转换为值类型。

  ··Java中基本类型和包装类之间的转换:
    自动装箱：Integer a=b;
    手动装箱：Integer a = new Integer(b);
    自动拆箱：int a=b;
    手动拆箱：int a=b.intValue();

  ··无论如何，Integer与new Integer不会相等。不会经历拆箱过程， 
  ··两个都是非new出来的Integer，如果数在-128到127之间，则是true，否则为false（Java缓存类型）
  java在编译Integer i2 = 128的时候,被翻译成-> Integer i2 = Integer.valueOf(128);而valueOf()函数会对-128到127之间的数进行缓存 
  ··两个都是new出来的,都为false 
  ··int和integer(无论new否)比，都为true，因为会把Integer自动拆箱为int再去比。
    
  ··包装类的“==”运算在不遇到算术运算的情况下不会自动拆箱，包装类的equals()方法不处理数据转型。




·Java的缓存机制：

	··基本型和基本型封装型进行“==”运算符的比较，基本型封装型将会自动拆箱变为基本型后再进行比较，因此Integer(0)会自动拆箱为int类型再进行比较，显然返回true；

	        int a = 220;
	        Integer b = 220;
	        System.out.println(a==b);//true

	··两个Integer类型进行“==”比较， 如果其值在-128至127  ，那么返回true，否则返回false, 这跟Integer.valueOf()的缓冲对象有关，这里不进行赘述。

	        Integer c=3;
	        Integer h=3;
	        Integer e=321;
	        Integer f=321;
	        System.out.println(c==h);//true
	        System.out.println(e==f);//false

	··两个Integer型的封装型进行equals()比较，首先equals()会比较类型，如果类型相同，则继续比较值，如果值也相同，返回true。

	        Integer a=1;
	        Integer b=2;
	        Integer c=3;
	        System.out.println(c.equals(a+b));//true

	··基本型封装类型调用equals(参数),但是参数是基本类型，这时候，先会进行自动装箱，基本型转换为其封装类型，再进行3中的比较。  

	        int i=1;
	        int j = 2;
	        Integer c=3;
	        System.out.println(c.equals(i+j));//true

	··Java封装类缓存
	        ···基本类型、对象引用都在栈中；而对象本身在堆中。
	            == ：基本数据类型比较的是值，对象比较的是地址；
	            	 基本数据类型与封装类比较会自动拆箱，所以比较的还是值;
	            	 两个封装类比较的是地址；    
	            equals： 比较值；
	        
	        ···Integer a = 1000  它的内部就是这样的：   Integer i = Integer.valueOf(1000);
	            而valueOf方法内部会去取缓存（默认范围 [-128, 127]） ，不会创建新对象。




·Java中基本类型和字符串之间的转换：
	在程序开发中，我们经常需要在基本数据类型和字符串之间进行转换。

	··基本类型转换为字符串有三种方法：
		1. 使用包装类的 toString() 方法；String str=Integer.toString(c);
		2. 使用String类的 valueOf() 方法；String str=String.valueOf(c);
		3. 用一个空字符串加上基本类型，得到的就是基本类型数据对应的字符串；String str=c+"";

	··字符串转换成基本类型有两种方法：
		1. 调用包装类的 parseXxx 静态方法；int c=Integer.parseInt(str);
		2. 调用包装类的 valueOf() 方法转换为基本类型的包装类，会自动拆箱；int c=Integer.valueOf(str);