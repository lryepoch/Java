
--if(flag=true){}中，只是一个赋值语句=======》隐含条件为if((flag=true)==true){}

--除8种基本类型引用boolean 、byte、char 、short 、int 、float、double 、long外所引用都是复合数据引用，比如类、接口和数组。

--javac.exe是编译.java文件
      java.exe是执行编译好的.class文件
      javadoc.exe是生成Java说明文档
      jdb.exe是Java调试器
      javaprof.exe是剖析工具

--Java编译后生成字节码文件即.class文件，然后JVM将字节码文件翻译成机器码文件由CPU执行。
      语言跨平台是编译后的文件跨平台，而不是源程序跨平台。Java源代码首先经过编译器生成字节码，即class文件，该class文件与平台无关，而class文件经过解释执行之后翻译成最终的机器码，这是平台相关的。

--能够对对象进行传输的貌似只有ObjectOutputStream和ObjectInputStream这些以Object开头的流对象。
      D项继承Seriallizable接口是经常见到的，这毋庸置疑。
      transient：修饰的变量在对象串化的时侯并不会将所赋值的值保存到传中，串化的对象从磁盘读取出来仍然是null。
      这值得说下Volatile这个修饰符，它是针对多线程情况下出现的。当线程读取它修饰的变量时，都会强迫从主存中重新读取。


--count是静态变量，为所有对象所共享，因此不管a.increment()还是b.increment()都会使count持续增加。

--存根类是一个类，它实现了一个接口，它的作用是：如果一个接口有很多方法，如果要实现这个接口，就要实现所有的方法。但是一个类从业务来说，可能只需要其中一两个方法。如果直接去实现这个接口，除了实现所需的方法，还要实现其他所有的无关方法。而如果通过继承存根类就实现接口，就免去了这种麻烦。就是适配器模式，继承该类则不需要实现一个接口全部方法。

--instance是java的二元运算符，用来判断他左边的对象是否为右面类（接口，抽象类，父类）的实例


--switch语句后的控制表达式只能是short、char、int、long整数类型和枚举类型，不能是float，double和boolean类型。String类型是java7开始支持。 

--for（；；）和while（true）区别：
从寓意上来看，两种写法都是无限循环；
从效率上看，while(true)每次循环要判断循环条件,for(;;)循环没有判断，理论上节省机器指令。
对比之下，for (；；)指令少，不占用寄存器，而且没有判断跳转，比while (1)好。也就是说两者在在宏观上完全一样的逻辑，但是底层完全不一样，for相对于来说更加简洁明了。
对于早期的C语言，两种写法性能会不一样。for语句编译器会优化成一条汇编指令，而while判断则编译器会生成好几条汇编指令。

--动态语言的定义：动态编程语言   是   高级程序设计语言   的一个类别，在计算机科学领域已被广泛应用。它是一类   在 运行时可以改变其结构的语言：
例如新的函数、对象、甚至代码可以被引进，已有的函数可以被删除或是其他结构上的变化。动态语言目前非常具有活力。众所周知的   ECMAScript   
（   JavaScript   ）便是一个动态语言，除此之外如PHP、Ruby、Python等也都属于动态语言，而C、C++等语言则不属于动态语言。

--复制的效率System.arraycopy>clone>Arrays.copyOf>for循环，这个有兴趣自己测试一下就知道了。这里面在System类源码中给出了arraycopy的
方法，是native方法，也就是本地方法，肯定是最快的。而Arrays.copyOf(注意是Arrays类，不是Array)的实现，在源码中是调用System.copyOf的，多
了一个步骤，肯定就不是最快的。前面几个说System.copyOf的不要看，System类底层根本没有这个方法，自己看看源码就全知道了。

--混合赋值运算符的使用：
  <<表示左移位
  >>为带符号右移，右移后左边的空位被填充为符号位
  >>>为不带符号右移，右移后左边的空位被填充为0
  没有<<< 因为<<后右边总是补0


--System是java.lang中的类，out为System中的一个静态成员，out是java.io.PrintStream类的对象，而println()是java.io.PrintStream类的方法，所以可以调用类.静态成员.println()方法。


--native修饰方法，native修饰的方法简单来说就是：一个Java方法调用了一个非Java代码的接口。定义navtive方法时，并不提供实现体，因为其实现体是用非Java语言在外面实现的。native可以和任何修饰符连用，abstract除外。因为native暗示这个方法时有实现体的，而abstract却显式指明了这个方法没有实现体。


--构造方法每次都是构造出新的对象，不存在多个线程同时读写同一对象中的属性的问题，所以不需要同步 。
如果父类中的某个方法使用了 synchronized关键字，而子类中也覆盖了这个方法，默认情况下子类中的这个方法并不是同步的，必须显示的在子类的这个方法中加上 synchronized关键字才可。当然，也可以在子类中调用父类中相应的方法，这样虽然子类中的方法并不是同步的，但子类调用了父类中的同步方法，也就相当子类方法也同步了。
详见：http://blog.csdn.net/welcome000yy/article/details/8941644

--A，CopyOnWriteArrayList适用于写少读多的并发场景
B，ReadWriteLock即为读写锁，他要求写与写之间互斥，读与写之间互斥， 读与读之间可以并发执行。在读多写少的情况下可以提高效率
C，ConcurrentHashMap是同步的HashMap，读写都加锁
D，volatile只保证多线程操作的可见性，不保证原子性


--一个.java文件中定义多个类：
注意一下几点：
(1) public权限类只能有一个（也可以一个都没有，但最多只有一个）；
(2)这个.java文件名只能是public 权限的类的类名；
(3)倘若这个文件中没有public 类，则它的.java文件的名字是随便的一个类名；
(4)当用javac命令生成编译这个.java 文件的时候，则会针对每一个类生成一个.class文件；
(5)如果类中有内部类，会产生类名$内部类名.class，如果有匿名类则会产生 类名$1.class.。所以类编译不一定会产生1个class文件。

--java采用局部优先的思想。局部变量可以和成员变量相同，使用标识符调用时，优先使用局部变量，使用成员变量就用this调用。


--关于文件：
    A.文件分为文本文件和二进制文件，计算机只认识二进制，所以实际上都是二进制的不同解释方式。文本文件是以不同编码格式显示的字符，例如Ascii、Unicode等，window中文本文件的后缀名有".txt",".log",各种编程语言的源码文件等；二进制文件就是用文本文档打开是看不懂乱码，只要能用文本打开的文件都可以算是文本文件，只是显示的结果不是你想要的，二进制文件只有用特殊的应用才能读懂的文件，例如".png",".bmp"等，计算机中大部分的文件还是二进制文件。
    B.File类是对文件整体或者文件属性操作的类，例如创建文件、删除文件、查看文件是否存在等功能，不能操作文件内容；文件内容是用IO流操作的。
    C.当输入过程中意外到达文件或流的末尾时，抛出EOFException异常,正常情况下读取到文件末尾时，返回一个特殊值表示文件读取完成，例如read()返回-1表示文件读取完成。
    D.不论是文本文件还是二进制文件，在计算机中都是以二进制形式存储的，所以都当做二进制文件读取。

--A，Thread可以被继承，用于创建新的线程
B，Number类可以被继承，Integer，Float，Double等都继承自Number类
C，Double类的声明为public final class Double extends Numberimplements Comparable<Double>
D，Math类的声明为public final class Math extends Object
E，ClassLoader可以被继承，用户可以自定义类加载器


--通过继承，子类可以拥有所有父类对其可见的方法和域
A.私有方法只能在本类中可见，故不能继承，A错误
B.缺省访问修饰符只在本包中可见，在外包中不可见，B错误
C.保护修饰符凡是继承自该类的子类都能访问，当然可被继承覆盖；C正确
D.static修饰的成员属于类成员，父类字段或方法只能被子类同名字段或方法遮蔽，不能被继承覆盖，D错误


--Arrays.asList()方法返回的列表是Arrays.ArrayList类型的，并不是java.util.ArrayList；SimpleDateFormat是线程不安全的。

--java是类C语言，从C++改进而来，去掉了指针和多继承，采用自动垃圾回收等。

--原来接口可以继承接口 而且可以多继承 Java中不允许多继承是指类不能多继承 类可以多实现接口。

--remove()方法调用的是remove(int index)，而不是remove(Object o)，因此删除的是index索引处的元素；

--在 jdk1.8版本下不能修饰interface的修饰符有哪些，private和protected是不能的，争议在于static，1.8版本支持static修饰接口的方法。

--说明一点，字段是指成员变量和成员常量，所以不能用abstract 修饰。

--java.util.*，只能读取其目录下的类，不能读取其子目录下的类。因为其根目录和子目录下可能有同名类，若都能读取，则会混淆。

--"c:\\my\\1.txt" "c:/my/1.txt" 都是正确的答案；
可以这么记:"\"这个符号在中英文环境下是不一样的显示；而"/"在中英文环境下是相同的显示。所以前者需要转义。

--关于栈和堆：https://www.nowcoder.com/test/question/done?tid=16634523&qid=112827

--Stack是栈， queue是队列；
    栈是后进先出，对列是先进先出；
    栈是出入从同一个位置；
    对列是入从结构的一端进入，从另一端出队；
    栈就像一个盒子，你把物体依次放入后，能先拿出来的只能是上面最后放进去的，下层的想要拿出需要将上层的先拿出，也就是先出栈；
    对列是一个胡同，人们都进入胡同了，只有最前面的人从胡同出口出去，后面的人只有等前面的人走完后才能依次通过。

--java导包只可以导到当前层的类，不可以再导入包里面的包中的类。
--多个类时构造函数不一定与公共类同名，因为每个类都可以有构造函数，函数名同所属类。
--JVM是Java Virtual Machine（Java 虚拟机 ）的缩写，JVM是一种用于计算设备的规范，它是一个虚构出来的计算机，是通过在实际的计算机上仿真模拟各种计算机功能来实现的。
简单来看，虚拟机本质就是一个进程。模拟平台操作的一个进程。


--这个题考查两个知识点。
----Java中，赋值是有返回值的 ，赋什么值，就返回什么值。比如这题，x=y，返回y的值，所以括号里的值是1。
----Java跟C的区别，C中赋值后会与0进行比较，如果大于0，就认为是true；而Java不会与0比较，而是直接把赋值后的结果放入括号。

--正解:一个文件中可以有多个类，如果没有public类，则可以与任意类名相同，如果有public类则文件名必须与此类名相同，因为一个文件中只能有一个public类。如果文件中只有一个类，则文件名必须与类名相同.

--B继承A  new B会
1.把A的静态的执行完 执行B的静态的
2.再执行A的初始化代码块，构造函数
3.再执行B的初始化代码块，构造函数

--管道实际上是一种固定大小的缓冲区，管道对于管道两端的进程而言，就是一个文件，但它不是普通的文件，它不属于某种文件系统，而是自立门户，单独构成一种文件系统，并且只存在于内存中。它类似于通信中半双工信道的进程通信机制，一个管道可以实现双向 的数据传输，而同一个时刻只能最多有一个方向的传输，不能两个方向同时进行。管道的容 量大小通常为内存上的一页，它的大小并不是受磁盘容量大小的限制。当管道满时，进程在 写管道会被阻塞，而当管道空时，进程读管道会被阻塞

A.正确，因为管道为空，读操作会被阻塞；管道满了，写操作会被阻塞
B.可以有多个进程对其读；也可以有多个进程写，只不过不能同时写。并且题目没有说“同时”，B不对
C.匿名管道只能单向；命名管道可以双向；所以C过于绝对
D.管道是内存中的，所以D不对

不能在同一个线程当中既写入又读取，这样会造成死锁，因为管道会有阻塞的时候(当管道当中没有数据，进行读操作时，读操作的线程会阻塞，直到有线程来写数据；当管道当中满数据，进行写操作时，写操作的线程阻塞，直到有线程来读数据)

--Java虽然是单继承，但是继承具有传递性.

--双引号关闭，所以是字符串常量而不是字符常量。

--getDeclaredMethods () 
                    返回   Method   对象的一个数组，这些对象反映此   Class   对象表示的类或接口声明的所有方法， 包括公共、保护、默认（包）访问和私有方法，但不包括继承的方法。

--Java中对字段属性是静态绑定，方法成员是动态绑定，这里错在：在子类中试图访问父类的private字段，所以编译不通过，将private去掉就可访问，不是动态绑定的问题，它本来就属于静态绑定。

--.这个关键字常见的坑：
true、false、null都不是关键字
goto、const、是保留的关键字

--不同的服务器之间，哪种通信方式是不可行的（管道）？
管道( pipe )：管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有亲缘关系的进程间使用。进程的亲缘关系通常是指父子进程关系。管道通信类似于通信中半双工信道的进程通信机制，一个管道可以实现双向的数据传输，而同一个时刻只能最多有一个方向的传输，不能两个方向同时进行。
消息队列
高速缓存数据库
套接字 都可以。

--java.lang包是java语言的核心包，lang是language的缩写。java.lang包定义了一些基本的类型，包括Integer,String之类的，是java程序必备的包，有解释器自动引入，无需手动导入.

--其实private方法是可以继承的，只是不能调用


--同步是害怕在操作过程的时候被其他线程也进行读取操作，一旦是原子性的操作就不会发生这种情况。因为一步到位的操作，其他线程不可能在中间干涉。另外三项都有读取、操作两个步骤，而X=1则是原子性操作。

--运算符优先级：单目>算数运算符>移位>比较>按位>逻辑>三目>赋值。


--json对象要求属性必须加双引号。11.反射和序列化同样会调用构造方法。不过这个构造方法不能有参数。

--java中的异常通常分为编译时异常和运行异常。编译时异常需要我们手动的进行捕捉处理，也就是我们用try....catch块进行捕捉处理。对于运行时异常只有在编译器在编译运行时才会出现，这些不需要我们手动进行处理。

--Java一个源程序只能有一个public类存在，且类名与文件名相同。Java程序是从main方法开始执行的，public为类加载器提供入口，然后找到public类中的main方法开始执行。如果存在多个public类，程序将不知道该从哪里执行。注意，内部类可以是public的，因为内部类是作为外部类的成员存在的。

--Collection是java.util下的接口，它是各种集合结构的父接口。Collections是java.util下的类，它包含有各种有关集合操作的静态方法。


--Thread.sleep() 和 Object.wait(),都可以抛出 InterruptedException。这个异常是不能忽略的,因为它是一个检查异常(checked exception)。

--实际上，xsd本身就是XML本身。它的目的是验证另一个XML文档的结构。对于任何XML，xsd并不是必需的，但它确保XML可以用于某些特定目的。XML只包含适当格式和结构的数据。


--Java中没用指针，而是用对象的引用来代替指针。当使用new这个单词时，就是为对象开辟空间。
      如果我们希望完成对象的拷贝，使用一个简单的赋值语句是无法完成的。要达到这一目的可以通过实现 Cloneable 接口并重写 clone方法来完成。如果我们希望判断两个对象引用是否一致时可以覆盖继承自 Object 类的 equals 方法来实现。

--关于java中把类名作为数据类型的处理：
其实类名不是作为数据类型，只能说将这个类的对象作为返回值。意思就是说，这个方法的返回值不是普通的数据类型，而是一个类对象。这样做可以避免一个方法要返回N多的数据，比如说，你要同一个方法中得到name和age，但是java又不能返回多个值，除了可以使用一个字符串或者字符串数组存放外，我们可以定义一个Student对象，对象中包含name和age属性，这样就可以用这个对象把属性封装起来以及方法，一起返回。

--https://blog.csdn.net/l1028386804/article/details/51097928/

--\\ 表示 \
    \123 表示 S
    \t 是制表符
    都占用一位

--串又称为字符串，是一种特殊的线性表，其特殊性体现在数据元素是一个字符，也就是说串是一种内容受限的线性表。（栈和队列是操作受限的线性表）。

--所谓树的带权路径长度，就是树中所有的叶结点的权值乘上其到根结点的路径长度。
    哈夫曼树的画法：https://www.nowcoder.com/test/question/done?tid=19976137&qid=1001#summary


--时间戳：
  什么是Unix时间戳(Unix timestamp)： Unix时间戳(Unix timestamp)，或称Unix时间(Unix time)、POSIX时间(POSIX time)，是一种时间表示方式，定义为从格林威治时间1970年01月01日00时00分00秒起至现在的总秒数。Unix时间戳不仅被使用在Unix系统、类Unix系统中，也在许多其他操作系统中被广泛采用。

  获取现在的Unix时间戳(Unix timestamp)？     Java  time
                                                                        MySQL SELECT unix_timestamp(now())

  实现Unix时间戳(Unix timestamp) → 普通时间？      Java  String date = new java.text.SimpleDateFormat("dd/MM/yyyy HH:mm:ss").format(new java.util.Date(Unix timestamp * 1000))
                                                                                    MySQL from_unixtime(Unix timestamp)

  实现普通时间 → Unix时间戳(Unix timestamp)？     Java  long epoch = new java.text.SimpleDateFormat("dd/MM/yyyy HH:mm:ss").parse("01/01/1970 01:00:00");
                                                                                  MySQL SELECT unix_timestamp(time)       时间格式: YYYY-MM-DD HH:MM:SS 或 YYMMDD 或 YYYYMMDD




--在命令提示框运行一个Java程序：
  1.编辑。写好一个xxx.java文件；
  2.编译。javac xxx.java；生成xxx.class文件；
  3.运行xxx.class。java xxx；不用加后缀；







--自增和自减运算符只能用于操作变量，不能直接用于操作数值或常量！例如 5++ 、 8-- 等写法都是错误滴！

--在实际开发中，变量名不建议使用中文，容易产生安全隐患，譬如后期跨平台操作时出现乱码等等。

--注意哦：
1、  > 、 < 、 >= 、 <= 只支持左右两边操作数是数值类型;
2、  == 、 != 两边的操作数既可以是数值类型，也可以是引用类型.

--Java中的逻辑运算符?
  &&-逻辑与，短路与
  !-逻辑非
  ||-逻辑或，短路或
  ^-逻辑异或

  位运算主要包括按位与(&)、按位或(|)、按位异或(^)、取反(~)、左移(<<)、右移(>>)这几种，其中除了取反(~)以外，其他的都是二目运算符，即要求运算符左右两侧均有一个运算量。

  <<(向左位移) 针对二进制，转换成二进制后向左移动3位，后面用0补齐

  public static void main(String[] args) {
           System.out.println("2<<3运算的结果是 :"+(2<<3));
           //打印的结果是:   2<<3运算的结果是 :16
       }

  >>(向右位移) 针对二进制，转换成二进制后向右移动3位，

  public static void main(String[] args) {
           System.out.println("2>>3运算的结果是 :"+(2>>3));
           //打印的结果是:   2>>3运算的结果是 :0
       }

  >>>(无符号右移)  无符号右移，忽略符号位，空位都以0补齐；

  10进制转二进制的时候，因为二进制数一般分8位、 16位、32位以及64位 表示一个十进制数，所以在转换过程中，最高位会补零。

  在计算机中负数采用二进制的补码表示，10进制转为二进制得到的是源码，将源码按位取反得到的是反码，反码加1得到补码。

  二进制的最高位是符号位，0表示正，1表示负。

  >>>与>>唯一的不同是它无论原来的最左边是什么数，统统都用0填充。
  ——比如，byte是8位的，-1表示为byte型是11111111(补码表示法）
  b>>>4就是无符号右移4位，即00001111，这样结果就是15。


--条件运算符（ ? : ）也称为 “三元运算符”。
    语法形式：布尔表达式 ？ 表达式1 ：表达式2
    运算过程：如果布尔表达式的值为 true ，则返回 表达式1 的值，否则返回 表达式2 的值。


--如何在Java中使用注释
在编写程序时，经常需要添加一些注释，用以描述某段代码的作用。
一般来说，对于一份规范的程序源代码而言，注释应该占到源代码的 1/3 以上。因此，注释是程序源代码的重要组成部分，一定要加以重视哦！
Java 中注释有三种类型：单行注释//、多行注释/*    */、文档注释/**    */


--通过强制类型转换将 75.8 赋值给 int 型变量后，结果为 75，数值上并未进行四舍五入，而是直接将小数位截断。明白了吧，强制类型转换可能会造成数据的丢失哦.
    如何转换？
    小数如何转换成二进制？


--在 Java 中，我们可以使用 break 语句退出指定的循环，直接执行循环后面的代码。continue 的作用是跳过循环体中剩余的语句执行下一次循环。


--函数返回 return ; return 1; return NULL; return 0; 区分

    return 0;     一般0代表的是正常结束
    return -1;    -1代表非正常结束
    return ;       void 返回是空，void返回值可以什么也不写，可以写return；
    return NULL;   如果数据类型是指针类型，那我们一般成功的时候返回相应的地址，失败的时候返回NULL。
     
    关于NULL，我这就简单记成 描述地址时用NULL‘清零’，描述数据时 用 0 清零。

    










