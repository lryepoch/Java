
·抽象类和接口区别：
		1、抽象类不能被实例化，实例化的工作应该交由它的子类来完成，它只需要有一个引用即可。
		2、抽象方法必须由子类来进行重写。
		3、只要包含一个抽象方法的类，该类必须要定义成抽象类，不管是否还包含有其他方法。
		4、抽象类中可以包含具体的方法，当然也可以不包含抽象方法。
		5、abstract不能与final并列修饰同一个类。
		6、abstract 不能与private、static、final或native并列修饰同一个方法。

		抽象类可以有构造方法，只是不能直接创建抽象类的实例对象而已，即不能new。在继承了抽象类的子类中通过super(参数列表)调用抽象类中的构造方法；
		字符串和数字相加，直接把数字当成字符串，这是Java的装箱机制，最终相当于字符串的连接；	
		AbstractXX的多半是抽象类，而不是接口，接口不需要强调抽象，他不可能不抽象；
		抽象方法只可以被public 和 protected修饰；
		抽象类中可以有静态方法，接口中也可以有。

		在接口里面的变量默认都是public static final 的，它们是公共的,静态的,最终的常量.相当于全局常量，可以直接省略修饰符。实现类可以直接访问接口中的变量。
		接口中方法不能有方法体，同时方法的访问修饰符不能是 private 和 protected。方法默认是public abstract 的。

		扩展：
		1、接口中可以有非抽象的方法，比如default方法（Java 1.8）。
		2、接口中可以有带方法体的方法。（Java 1.8）
		3、接口中的方法默认是public的。

		接口，比抽象类还要抽象的类。
				接口中每一个方法也是隐式抽象的,接口中的方法会被隐式的指定为 public abstract （只能是 public abstract，其他修饰符都会报错）。
				接口中可以含有变量，但是接口中的变量会被隐式的指定为  public static final   变量（并且只能是 public，用 private 修饰会报编译错误。）
				接口中的方法是不能在接口中实现的，只能由实现接口的类来实现接口中的方法。
				
				注：
				接口是隐式抽象的，当声明一个接口的时候，不必使用abstract关键字。
				接口中每一个方法也是隐式抽象的，声明时同样不需要abstract关键字。
				接口中的方法都是公有的。public。

		abstract可以修饰方法和类，不能修饰属性。抽象方法没有方法体，即没有大括号{}
				1.抽象类中的成员属性都是public static final类型的；
				2.抽象的成员方法都是public abstract的。
				3.抽象类中可以存在非抽象方法。

		1、接口是一种约束和规范，是一种更加更高级的抽象类，抽象类的方法必须是公开的，因为要给人继承和使用啊，不用public，别人怎么看得到，所以
		在接口实现时，定义的方法修饰符必须是public；因此子类在实现接口重写方法时的修饰符必须是public。
		2、另外再扩展一下，接口中没有变量（既然是约束和规范，怎么能够定义一个大家都可以改的东西呢？），只能是常量，接口中定义常量默认的修饰符
		为public static final。

		接口（interface）可以说成是抽象类的一种特例，接口中的所有方法都必须是抽象的。接口中的方法定义默认为public abstract类型，接口中的成员变量类型默认为public static final。
		下面比较一下两者的语法区别：
		1.抽象类可以有构造方法，接口中不能有构造方法。
		2.抽象类中可以有普通成员变量，接口中没有普通成员变量
		3.抽象类中可以包含非抽象的普通方法，接口中的所有方法必须都是抽象的，不能有非抽象的普通方法。
		4. 抽象类中的抽象方法的访问类型可以是public，protected和（默认类型,虽然
		eclipse下不报错，但应该也不行），但接口中的抽象方法只能是public类型的，并且默认即为public abstract类型。
		5. 抽象类中可以包含静态方法，接口中不能包含静态方法
		6. 抽象类和接口中都可以包含静态成员变量，抽象类中的静态成员变量的访问类型可以任意，但接口中定义的变量只能是public static final类型，并且默认即为public static final类型。

		12.
			1、抽象类和方法都不能被实例化
			2、抽象类可以实现接口
			3、抽象类方法默认访问权限都是default
			4、接口就是访问的，默认访问权限都是public

		18.抽象类和接口都可以被声明，只是不能被实现，抽象类是通过子类对象来实现方法，而接口是通过实现类来执行方法。

		21.考察点：抽象类和接口
		相同点：都不能被实例化,位于继承树的顶端，都包含抽象方法
		不同点：1、设计目的：接口体现的一种规范，类似与整个系统的总纲，制订了系统各模块应该遵循的标准，因此接口不应该经常改变，一旦改变对整个系统是辐射性的。
		               抽象类作为多个子类的共同父类，体现的是一种模板式设计，可以当作系统实现过程中的中间产品，已经实现了系统部分功能。
		            2、使用不同：（1）接口只能包含抽象方法，抽象类可以包含普通方法。
		                                   （2）接口里不能定义静态方法，抽象类可以。
		                                   （3）接口只能定义静态常量属性不能定义普通属性，抽象类可以。
		                                   （4）接口不包含构造器，抽象类可以（不是用于创建对象而是让子类完成初始化）。
		                                   （5）接口里不能包含初始化块，抽象类完全可以。
		                                   （6）接口多继承，抽象类但继承（只能有一个直接父类）。
		总结：接口所有方法全是抽象方法只能 public abstract修饰 （默认public abstract修饰 ），属性默认public static final修饰。
		             抽象类除了包含抽象方法外与普通类无区别。 

		23.java1.8实测，抽象类中的抽象方法和非抽象方法在不加修饰符的情况下，都是默认的default。以前抽象类或者抽象方法默认是protected，jdk1.8以后改成默认default了

		关于抽象类
		JDK 1.8以前，抽象类的方法默认访问权限为protected
		JDK 1.8时，抽象类的方法默认访问权限变为default

		关于接口
		JDK 1.8以前，接口中的方法必须是public的
		JDK 1.8时，接口中的方法可以是public的，也可以是default的
		JDK 1.9时，接口中的方法可以是private的


		27.抽象类不仅可以被继承，还可以直接拿来使用的，当然，这个使用是拿来声明，而不是实例化，因为抽象类不能实例化，但可以声明使用。就像接口一样。可以动态绑定地实现多态，如下例子，AbstractMap就是抽象类，它可以这样使用。
		        AbstractMap<String, Integer> am = new HashMap<String, Integer>();  
		                                                          am.put("young", 23);
		                                                          am.put("strongyoung", 26);
		                                                          Iterator<String> itr = am.keySet().iterator();
		                                                          while(itr.hasNext()){                   //hasNext（）
		                                                              String key = itr.next();
		                                                              System.out.println(key + " : " + am.get(key));
		                                                          }


·内部类：

	对于外部类来说，只有两种修饰，public和默认（default），因为外部类放在包中，只有两种可能，包可见和包不可见。
	对于内部类来说，可以有所有的修饰，因为内部类放在外部类中，与成员变量的地位一致，所以有四种可能。

			1.为什么使用内部类?
					使用内部类最吸引人的原因是：每个内部类都能独立地继承一个（接口的）实现，所以无论外围类是否已经继承了某个（接口的）实现，对于内部类都没有影响。
					使用内部类最大的优点就在于它能够非常好的解决多重继承的问题,使用内部类还能够为我们带来如下特性:
							(1)、内部类可以用多个实例，每个实例都有自己的状态信息，并且与其他外围对象的信息相互独立 。
							(2)、在单个外围类中，可以让多个内部类以不同的方式实现同一个接口，或者继承同一个类。
							(3)、创建内部类对象的时刻并不依赖于外围类对象的创建。
							(4)、内部类并没有令人迷惑的“is-a”关系，他就是一个独立的实体。
							(5)、内部类提供了更好的封装，除了该外围类，其他类都不能访问。

			2.内部类分类:

			(一).成员内部类:
			public class Outer{
			        private int age = 99;
			        String name = "Coco";
			        public class Inner{
			            String name = "Jayden";
			            public void show(){
			                System.out.println(Outer.this.name);		访问外部类的成员变量
			                System.out.println(name);
			                System.out.println(age);
			            }
			        }
			        public Inner getInnerClass(){
			            return new Inner();
			        }
			        public static void main(String[] args){
			            Outer o = new Outer();
			            Inner in = o.new Inner();
			            in.show();
			        }
			    }
					1.Inner 类定义在 Outer 类的内部，相当于 Outer 类的一个成员变量的位置，Inner 类可以使用任意访问控制符，如 public 、 protected 、 private 等
					2.Inner 类中定义的 show() 方法可以直接访问 Outer 类中的数据，而不受访问控制符的影响，如直接访问 Outer 类中的私有属性age。

					3.定义了成员内部类后，必须使用外部类对象来创建内部类对象，而不能直接去 new 一个内部类对象，即：内部类 对象名 = 外部类对象.new 内部类( );
					4.编译上面的程序后，会发现产生了两个 .class 文件: Outer.class,Outer$Inner.class{}

					5.成员内部类中不能存在任何 static 的变量和方法,可以定义常量:
						(1).因为非静态内部类是要依赖于外部类的实例,而静态变量和方法是不依赖于对象的,仅与类相关；简而言之:在加载静态域时,根本没有外部类,所以在非静态内部类中不能定义静态域或方法,编译不通过;非静态内部类的作用域是实例级别；
						(2).常量是在编译期就确定的,放到所谓的常量池了；

					★★友情提示:
					1.外部类是不能直接使用内部类的成员和方法的，可先创建内部类的对象，然后通过内部类的对象来访问其成员变量和方法;
					2.如果外部类和内部类具有相同的成员变量或方法，内部类默认访问自己的成员变量或方法，如果要访问外部类的成员变量，
					可以使用 this 关键字,如:Outer.this.name


			(二).静态内部类: 是 static 修饰的内部类：
					
					静态内部类才可以声明静态方法；静态方法不可以使用非静态变量；

					1.静态内部类不能直接访问外部类的非静态成员，但可以通过 new 外部类().成员 的方式访问 ；

					2.如果外部类的静态成员与内部类的成员名称相同，可通过“类名.静态成员”访问外部类的静态成员；
					如果外部类的静态成员与内部类的成员名称不相同，则可通过“成员名”直接调用外部类的静态成员；

					3.创建静态内部类的对象时，不需要外部类的对象，可以直接创建 内部类 对象名 = new 内部类()；

					public class Outer{
					            private int age = 99;
					            static String name = "Coco";
					            public static class Inner{
					                String name = "Jayden";
					                public void show(){
					                    System.out.println(Outer.name);			访问外部类的静态成员
					                    System.out.println(name);                  
					                }
					            }
					            public static void main(String[] args){
					                Inner i = new Inner();			可以直接创建 内部类 对象名 = new 内部类()；
					                i.show();
					            }
					        }

						内部类其实和类的属性没什么区别：
							public class Enclosingone {
							    //非静态内部类
							    public class InsideOne {}
							    //静态内部类
							    public static class InsideTwo{}
							}
							 
							class Mytest02{
							    public static void main(String args []){
							        Enclosingone.InsideOne obj1 = new Enclosingone().new InsideOne();//非静态内部类对象
							        Enclosingone.InsideTwo obj2 = new Enclosingone.InsideTwo();//静态内部类对象
							    }
							}


			(三).方法内部类：其作用域仅限于方法内，方法外部无法访问该内部类
					(1).局部内部类就像是方法里面的一个局部变量一样，是不能有 public、protected、private 以及 static 修饰符的

					(2).只能访问方法中定义的 final 类型的局部变量,因为:
					当方法被调用运行完毕之后，局部变量就已消亡了。但内部类对象可能还存在，直到没有被引用时才会消亡。此时就会出现一种情况，就是内部类要访问一个不存在的局部变量；	==>使用final修饰符不仅会保持对象的引用不会改变,而且编译器还会持续维护这个对象在回调方法中的生命周期。
					局部内部类并不是直接调用方法传进来的参数，而是内部类将传进来的参数通过自己的构造器备份到了自己的内部，自己内部的方法调用的实际是自己的属性而不是外部类方法的参数；防止被篡改数据,而导致内部类得到的值不一致。

			         /*
			        使用的形参为何要为 final???
			         在内部类中的属性和外部方法的参数两者从外表上看是同一个东西，但实际上却不是，所以他们两者是可以任意变化的，也就是说在内部类中我对属性的改变并不会影响到         外部的形参，而然这从程序员的角度来看这是不可行的，毕竟站在程序的角度来看这两个根本就是同一个，如果内部类该变了，而外部方法的形参却没有改变这是难以理解和不可接受的，所以为了保持参数的一致性，就规定使用 final 来避免形参的不改变；
			         */

			        public class Outer{
			            public void Show(){
			                final int a = 25;
			                int b = 13;
			                class Inner{
			                    int c = 2;
			                    public void print(){
			                        System.out.println("访问外部类:" + a);
			                        System.out.println("访问内部类:" + c);
			                    }
			                }
			                Inner i = new Inner();
			                i.print();
			            }
			            public static void main(String[] args){
			                Outer o = new Outer();
			                o.show();
			            }
			        }    
				(3).注意:在JDK8版本之中,方法内部类中调用方法中的局部变量,可以不需要修饰为 final,匿名内部类也是一样的，主要是JDK8之后增加了 Effectively final 功能
				http://docs.oracle.com/javase/tutorial/java/javaOO/localclasses.html
				反编译jdk8编译之后的class文件,发现内部类引用外部的局部变量都是 final 修饰的

			(四).匿名内部类:
					(1).匿名内部类是直接使用 new 来生成一个对象的引用;
					(2).对于匿名内部类的使用它是存在一个缺陷的，就是它仅能被使用一次，创建匿名内部类时它会立即创建一个该类的实例，该类的定义会立即消失，所以匿名内部类是不能够被重复使用;
					(3).使用匿名内部类时，我们必须是继承一个类或者实现一个接口，但是两者不可兼得，同时也只能继承一个类或者实现一个接口;
					(4).匿名内部类中是不能定义构造函数的,  匿名内部类中不能存在任何的     静态成员变量和    静态方法;
					(5).匿名内部类不能是抽象的,它必须要实现继承的类或者实现的接口的所有抽象方法；
					(6).匿名内部类初始化：使用构造代码块！利用构造代码块能够达到为匿名内部类创建一个构造器的效果；

					匿名内部类用法与局部内部类不一致，首先从定义上就不一样，匿名类用在任何允许存在表达式的地方，而局部内部类用于在任何允许出现局部变量的地方出现。还有更重要的是匿名类只能使用一次，而局部类则可以在自己的定义域内多次使用。成员内部类位于外部类内部，可以直接调用外部类的所有方法（静态方法和非静态方法）

					匿名内部类是什么？
					关于 “Java 内部类 ” 和 "Java 继承、多态与类的复用" 的更详细的阐述，请查看我的两篇博文 “http://blog.csdn.net/justloveyou_/article/details/53245561” 和 
					“http://blog.csdn.net/justloveyou_/article/details/52798666”。 

			  public class OuterClass {
			            public InnerClass getInnerClass(final int num，String str2){
			                return new InnerClass(){
					                    int number = num + 3;
					                    public int getNumber(){
					                        return number;
					                    }
			                    };        /* 注意：分号不能省 */
			            }
			            public static void main(String[] args) {
			                OuterClass out = new OuterClass();
			                InnerClass inner = out.getInnerClass(2, "chenssy");
			                System.out.println(inner.getNumber());
			            }
			        }
			        interface InnerClass {			//接口
			            int getNumber();				//接口方法
             }         

			所谓的匿名内部类就是一个没有显式的名字的内部类，在实际开发中，此种内部类用的是非常多的。
			本质：匿名内部类会隐式的继承一个类或者实现一个接口，或者说，匿名内部类是一个继承了该类或者实现了该接口的子类匿名对象。
			格式：
					new 类名/接口/抽象类(){
						//实现的是它的实现类
					}

			public class Outer{
				public void method(){
					new inner(){
						public void info(){
							sout("helloworld");
						}
					}.info();
				}
				public static void main(String[] args){
					Outer outer = new Outer();
					outer.method();
				}
			}

			interface inner{
				public void info();
			}

			总结：通过程序看出，实际上我们的inner是一个接口，本身接口是不能直接new的，但是呢却又发现我们在new的时候，inner这个接口后面带了一对花括号，那么这个就表示实际上我现在new的是这个接口的实现类。但是发现，这个实现类是没有名字的。



--关于内部类的几个问题：
		1.可以把局部内部类当做一个局部变量，所以它是不需要加任何修饰符的，局部内部类前不能用修饰符public和private,protected。
		2.内部类指位于类内部但不包括位于块、构造器、方法内，且有名称的类，修饰符有public,private,protected访问控制符，也可以用static,final关键字修饰，public和private比较简单，一个表示所有可以被所有类访问，一个表示只能被自身访问，protected修饰的成员类可以被同一个包中的类和子类访问。而default修饰的成员类只能被同一个包中的类访问。
		3.局部内部类指位于块、构造器、方法内的有名称类，最多只能有final修饰。

		定义内部类的好处是外部类可以访问内部类的所有方法和属性，包括私有方法和私有属性。

　  ①、静态变量能存在于普通方法中吗？

　　能。很明显，普通方法必须通过对象来调用，静态变量都可以直接通过类名来调用了，更不用说通过对象来调用，所以是可以存在于普通方法中的。

　　②、静态方法能存在普通变量吗？

　　不能。因为静态方法可以直接通过类名来直接调用，不用创建对象，而普通变量是必须通过对象来调用的。那么将普通变量放在静态方法中，在直接通过类来调用静态方法时就会报错。所以不能。

　　③、静态代码块能放在方法体中吗？

　　不能。首先我们要明确静态代码块是在类加载的时候自动运行的。

　　普通方法需要我们创建对象，然后手工去调用方法，所静态代码块不能声明在普通方法中。

　　那么对于用static修饰的静态方法呢？同样也是不能的。因为静态方法同样也需要我们手工通过类名来调用，而不是直接在类加载的时候就运行了。

　　也就是说静态代码块能够自动执行，而不管是普通方法还是静态方法都是需要手工执行的。

　　④、静态导包会比普通导包消耗更多的性能？

　　不会。静态导包实际上在编译期间都会被编译器进行处理，将其转换成普通按需导包的形式，所以在程序运行期间是不影响性能的。

　　⑤、static可以用来修饰局部变量吗？

　　不能。不管是在普通方法还是在静态方法中，static 关键字都不能用来修饰局部变量，这是Java的规定。稍微想想也能明白，局部变量的声明周期是随着方法的结束而结束的，因为static 修饰的变量是全局的，不与对象有关的，如果用 static 修饰局部变量容易造成理解上的冲突，所以Java规定 static 关键字不能用来修饰局部变量。




--this和super区别：

	this()和super()为构造方法，作用是在JVM堆中构建出一个对象。因此避免多次创建对象，同一个方法内只能调用一次this()或super()。
	同时为了避免操作对象时对象还未构建成功，需要this()和super()的调用在第一行实现【以此来创建对象】，防止异常。this和super不可
	能同时出现在一个构造函数里。而且this是对重载的构造函数调用，super是对父类的构造函数调用。

	this：
	1、this代表当前对象；
			this.属性：操作当前对象的属性；
			this.方法：调用当前对象的方法；

	2、封装对象的属性的时候，经常会使用this；

	super：
	在对象的内部使用，可以代表父类对象；
	访问父类属性：super.age；
	访问父类方法：super.eat（）；

	访问构造方法：super（……）；

	注意：
	1、在子类的构造过程当中，必须调用其父类的构造方法。
	2、如果子类构造方法中没有显示调用父类的构造方法，则系统默认调用父类无参的构造方法；
	3、如果显示的调用构造方法，必须在子类的构造方法的第一行；
	4、如果子类构造方法中既没有显示调用父类的构造方法，而父类又没有无参的构造方法，则编译出错；
	


--重载和重写区别：

	重载是Java多态性（在一个类中）的一种表现方式，要注意以下几点：
    1.参数列表不同。包括参数个数、参数类型、参数顺序等的不同；
    2.不能通过方法的访问权限、返回值类型和抛出的异常类型来判断重载；
    3.对于继承来说，如果父类方法的访问权限为private，那么就不能在子类对其重载；如果子类也定义了一个同名的函数，只是一个新方法，并不是重载方法；
    4.构造方法也可以重载。

	重写又称覆盖，方法的重写（override）有两同两小一大原则：
		方法名相同，参数类型相同；
		子类返回类型小于等于父类方法返回类型，
		子类抛出异常小于等于父类方法抛出异常，
		子类访问权限大于等于父类方法访问权限。

		方法重写的注意事项：
			构造方法不能被重写，不要问为什么？因为构造方法名必须和类名相同；
			private修饰的成员方法不能被重写；
			static修饰的方法不能被重写；
			final修饰的方法不能被重写；
			当子类重写了父类中的方法后，子类对象调用该方法时，调用的是子类重写后的方法。

	重载（overload）和重写（override）的区别： 
	重载就是同一个类中，有多个方法名相同，但参数列表不同（包括参数个数和参数类型），与返回值无关，与权限修饰符也无关。调用重载的方法时通过传递给它们不同的参数个数和参数类型来决定具体使用哪个方法，这叫多态。 

	重写就是子类重写基类的方法，方法名，参数列表和返回值都必须相同，否则就不是重写而是重载。权限修饰符不能小于被重写方法的修饰符。重写方法不能抛出新的异常或者是比被重写方法声明更加宽泛的检查型异常。

	java多态有两种情况：重载和覆盖（重写）	，静态联编是指编译时多态，动态联编是指运行时多态。
		在覆盖中，运用的是动态单分配，是根据new的类型确定对象，从而确定调用的方法；
		在重载中，运用的是静态多分派，即根据静态类型确定对象，因此不是根据new的类型确定调用的方法。


	一个类中，可以有多个main方法，这是重载，但是public static void main(String[] args)的方法只能有一个。
      一个文件中，可以有多个public class，即，外部类为public，还可以有public的内部类。
      public class Main {
               public class Inner{

          }
      }
    类中，可以有main方法，也可以没有main方法，而有一个main()方法的时候，也可以是任意访问权限。因为这个类不一定要执行，可以只是辅助类。



-final、finally、finalize的区别：
--关于finally：

	当程序执行到try{}语句中的return方法时，它会干这么一件事，将要返回的结果存储到一个临时栈中，然后程序不会立即返回，而是去执行finally{}中的程序， 在执行`a = 2`		时，程序仅仅是覆盖了a的值，但不会去更新临时栈中的那个要返回的值。执行完之后，就会通知主程序“finally的程序执行完毕，可以请求返回了”，这时，就会将临时栈中		的值取出来返回。这下应该清楚了，要返回的值是保存至临时栈中的那个。

	finally语句在try或catch中的return语句执行之后返回之前执行，且finally里的修改语句不能影响try或catch中return已经确定的返回值。若finally里也有return语句则覆盖try或catch中的return语句直接返回。

	谁说finally块必须执行？不服来辩：
	try-catch-finally块中，finally块在以下几种情况将不会执行。
	（1）finally块中发生了异常。
	（2）程序所在线程死亡。
	（3）在前面的代码中用了System.exit（）；
	（4）关闭了CPU

	A：选项存在疑问，一般情况下不管try{}catch(){}语句块如何结束，finally保证其所包含的语句块最终被执行，但是存在特殊情况：1.try语句没有被执行到，如在try语句之前就返回了；2.在try块中有System.exit(0)），此时finally中的语句块是不会执行的；
	B：System.exit(0)。表示将整个虚拟机里的内容都释放，JVM停止工作，此时程序正常退出；

	--如果try语句里有return，返回的是try语句块中变量值。 
		详细执行过程如下：
		如果有返回值，就把返回值保存到局部变量中；
		执行jsr指令跳到finally语句里执行；
		执行完finally语句后，返回之前保存在局部变量表里的值。
		如果try，finally语句里均有return，忽略try的return，而使用finally的return.
	--使用try时，catch和finally必须存在一个。
	--finally语句总是要执行的，当finally语句中也有return时，会覆盖try/catch语句块的return，所以一般不要在finally中加return语句。。。。。PS：return的两个作用：返回数据、结束方法运行.

--关于final：
        final可以修饰类、方法、变量，分别表示：该类不可继承、该方法不能重写、该变量是常量；final修饰的变量，他的类型不可再改变，即便进行了相关的运算也不会改变。
        使用 final 关键字修饰一个变量时，是指引用变量不能变，引用变量所指向的对象中的内容还是可以改变的。

        关于final的重要知识点;
        1）final关键字可以用于成员变量、本地变量、方法以及类。
        2）final成员变量必须在声明的时候初始化或者在构造器中初始化，否则就会报编译错误。
        3）你不能够对final变量再次赋值。
        4）本地变量必须在声明时赋值。
        5）在匿名类中所有变量都必须是final变量。
        7）没有在声明时初始化final变量的称为空白final变量(blank final variable)，它们必须在构造器中初始化，或者调用this()初始化。不这么做的话，编译器会报错“final变量(变量名)需要进行初始化”。
        8）final修饰的类为终态类，不能被继承，而抽象类是必须被继承的才有其意义的，因此，final是不能用来修饰抽象类的。
        9）static final 可以表达在一起来修饰方法，表示是该方法是静态的不可重写的方法

		被final修饰的变量不会自动转型。

		对于引用类型，被 final 修饰的变量不可更改其引用地址（当重新new时），但是可以更改其内部属性（通过setter方法）。
        
--finalize方法：
	Java技术允许使用finalize()方法在垃圾收集器将对象从内存中清除出去之前做必要的清理工作。这个方法是由垃圾收集器在确定这个对象没有被引用时对这个对象调用的。它是在 Object 类中定义的，因此所有的类都继承了它。子类覆盖 finalize() 方法以整理系统资源或者执行其他清理工作。finalize()方法是在垃圾收集器删除对象之前对这个对象调用的。注意：finalize不一定被jvm调用，只有当垃圾回收器要清除垃圾时才被调用。

	深入理解java虚拟机中说到：
      当对象不可达后，仍需要两次标记才会被回收，首先垃圾收集器会先执行对象的finalize方法，但不保证会执行完毕（死循环或执行很缓慢的情况会被强行终止），
      此为第一次标记。第二次检查时，如果对象仍然不可达，才会执行回收。
      Java技术允许使用finalize()方法在垃圾收集器将对象从内存中清除出去之前做必要的清理工作。这个方法是由垃圾收集器在确定这个对象没有被引用时对这个对象调用的。它是在 Object 类中定义的，因此所有的类都继承了它。子类覆盖 finalize() 方法以整理系统资源或者执行其他清理工作。
      finalize() 方法是在垃圾收集器删除对象之前对这个对象调用的。注意：finalize不一定被jvm调用，只有当垃圾回收器要清除垃圾时才被调用。



--成员变量和局部变量的区别：
		1、成员变量是独立于方法外的变量，局部变量是类的方法中的变量
				1）、成员变量：包括实例变量和类变量，用static修饰的是类变量，不用static修饰的是实例变量，所有类的成员变量可以通过this来引用。
				2）、局部变量：包括形参，方法局部变量，代码块局部变量，存在于方法的参数列表和方法定义中以及代码块中。

		2、成员变量可以被public，protect，private，static等修饰符修饰，而局部变量不能被   访问控制修饰符及 static修饰；两者都可以定义成final型。

		3、成员变量存储在堆，局部变量存储在栈。局部变量的作用域仅限于定义它的方法，在该方法的外部无法访问它。成员变量的作用域在整个类
		内部都是可见的，所有成员方法都可以使用它。如果访问权限允许，还可以在类的外部使用成员变量。

		4、局部变量的生存周期与方法的执行期相同。当方法执行到定义局部变量的语句时，局部变量被创建；执行到它所在的作用域的最后一条语句
		时，局部变量被销毁。类的成员变量，如果是实例成员变量，它和对象的生存期相同。而静态成员变量的生存期是整个程序运行期。

		5、成员变量在类加载或实例被创建时，系统自动分配内存空间，并在分配空间后自动为成员变量指定初始化值，初始化值为默认值，基本类型的默认值为0，复合类型的默认值为null。（被final修饰且没有static的必须显式赋值），局部变量在定义后必须经过显式初始化后才能使用，系统	不会为局部变量执行初始化。

		6、局部变量可以和成员变量同名，且在使用时，局部变量具有更高的优先级，直接使用同名访问，访问的是局部变量，如需要访问成员变量可以用this；变量名访问本例中i为成员变量，有默认的初始值，如果定义在方法内部，就没有初始值。


--Math类中提供了三个与取整有关的方法：ceil,floor,round,这些方法的作用于它们的英文名称的含义相对应；

		floor: 求小于参数的最大整数。返回double类型-----n. 地板，地面
		         例如：Math.floor(-4.2) = -5.0
		-----------------------------------------------------------
		ceil:   求大于参数的最小整数。返回double类型-----vt. 装天花板；
		         例如：Math.ceil(5.6) = 6.0
		-----------------------------------------------------------
		round: 对小数进行四舍五入后的结果。返回int类型
		         例如：Math.round(-4.6) = -5


--访问控制符：
	public：可以被所有其他类所访问，
	private：只能被自己访问和修改，
	protected：自身、子类及同一个包中类可以访问，
	default：同一包中的类可以访问，声明时没有加修饰符，认为是friendly。default不能修饰变量。

	1.在一个文件中,有且只能有一个public类,该类与文件同名
	2.在一个文件中,可以不存在public类
	3.在一个文件中,可以不存在与文件同名的类(前提是此文件中没有public类)


--父类和子类的关系：
		--如果子类构造器没有显示地调用超类的构造器，则将自动地调用超类默认（没有参数）的构造器。如果超类没有不带参数的构造器，并且在子类的构造器中没有显示地调用超类的其他构造器，则Java编译器将报告错误。使用super调用构造器的语句必须是子类构造器的第一条语句。
		--调用构造方法时，调用父类的构造方法就用super，调用本类的构造方法就用this。
		--在一个子类被创建的时候，首先会在内存中创建一个父类对象，然后在父类对象外部放上子类独有的属性，两者合起来形成一个子类的对象。所以所谓的继承使子类拥有父类所有的属性和方法其实可以这样理解，子类对象确实拥有父类对象中所有的属性和方法，但是父类对象中的私有属性和方法，子类是无法访问到的，只是拥有，但不能使用。就像有些东西你可能拥有，但是你并不能使用。所以子类对象是绝对大于父类对象的，所谓的子类对象只能继承父类非私有的属性及方法的说法是错误的。可以继承，只是无法访问到而已。？？？？？？？？？？？？？

		--子类构造函数调用父类构造函数用super；子类重写父类方法后，若想调用父类中被重写的方法，用super；未被重写的方法可以直接调用。
			子类也可以new一个父类对象，然后调用父类方法，并不一定要使用super方法。另外，子类调用父类的构造方法时，super语句必须是子类构造方法的第一句。

		--JAVA子类重写继承的方法时,不可以降低方法的访问权限，子类继承父类的访问修饰符要比父类的更大，也就是更加开放，假如我父类是protected修饰的，其子类只能是protected或者public，绝对不能是friendly(默认的访问范围)或者private，当然使用private就不是继承了。还要注意的是，继承当中子类抛出的异常必须是父类抛出的异常的子异常，或者子类抛出的异常要比父类抛出的异常要少。



--在继承中代码的执行顺序为：静态>非静态，父类>子类,（同类下）非静态>构造
                          1.父类静态对象，父类静态代码块
                          2.子类静态对象，子类静态代码块
                          3.父类非静态对象，父类非静态代码块
                          4.父类构造函数
                          5.子类非静态对象，子类非静态代码块
                          6.子类构造函数

		并不是静态块最先初始化,而是静态域.(BM：啊!多么痛的领悟!)
		而静态域中包含静态变量、静态块和静态方法,其中需要初始化的是静态变量和静态块.而他们两个的初始化顺序是靠他们俩的位置决定的!

		静态块：用static申明，JVM加载类时执行，仅执行一次
		构造块：类中直接用{}定义，每一次创建对象时执行
		执行顺序优先级：静态块>main()>构造块>构造方法

	一个类时的执行顺序：静态代码块-》主程序-》非静态代码块-》构造函数-》一般方法。
    加入了子类以后，执行顺序有了新的变化，我们可以总结一下。首先第一部分执行的是父类的静态代码块-》子类的静态代码块-》主程序。这一部分都是执行一次，与建立多少对象没有关系。第二部分new了一个父类对象，并调用了方法。执行了它的非静态代码块-》构造函数-》一般方法。第三部分new了一个子类的对象，并调用了方法。执行顺序为父类的非静态代码块-》父类的无参构造函数，然后是子类的非静态代码块-》子类构造函数-》子类的方法。


--面向对象的五大基本原则： 
		单一职责原则：一个类，最好只做一件事，只有一个引起它的变化。单一职责原则可以看做是低耦合、高内聚在面向对象原则上的引申，将职责定义为引起变化的原因，以提高内聚性来减少引起变化的原因。 
		开放封闭原则（Open-Closed principle）：软件实体应该是可扩展的，而不可修改的。也就是，对扩展开放，对修改封闭的。 
		里氏替换原则：子类必须能够替换其基类。这一思想体现为对继承机制的约束规范，只有子类能够替换基类时，才能保证系统在运行期内识别子类，这是保证继承复用的基础。 
		依赖倒置原则：依赖于抽象。具体而言就是高层模块不依赖于底层模块，二者都同依赖于抽象；抽象不依赖于具体，具体依赖于抽象。 
		接口隔离原则（Interface-Segregation Principle）：使用多个小的专门的接口，而不要使用一个大的总接口。




--String/StringBuilder/StringBuffer区别：
		首先，主要区别是运算速度和线程安全。
		1.运算速度：StringBuilder>StringBuffer>String;
		(Java中对String对象进行的操作实际上是一个不断创建新的对象并且将旧的对象回收的一个过程，所以执行速度很慢。而StringBuilder和StringBuffer的
			对象是变量，对变量进行操作就是直接对该对象进行更改，而不进行创建和回收的操作，所以速度要比String快很多。)

		2.StringBuilder线程不安全，StringBuffer线程安全。
		如果一个StringBuffer对象在字符串缓冲区被多个线程使用时，StringBuffer中很多方法可以带有synchronized关键字，所以可以保证线程是安全的，但
		StringBuilder的方法则没有该关键字，所以不能保证线程安全，有可能会出现一些错误的操作。所以如果要进行的操作是多线程的，那么就要使用StringBuffer，
		但是在单线程的情况下，还是建议使用速度比较快的StringBuilder。

		3. 总结一下
		　　String：适用于少量的字符串操作的情况；
		　　StringBuilder：适用于单线程下在字符缓冲区进行大量操作的情况；
		　　StringBuffer：适用多线程下在字符缓冲区进行大量操作的情况；

--关于String类
		--它是final类型的，不能继承和修改这个类。str=“tesk ok”，其实是隐含的让Java生成一个新的String对象，那么就与原来的“Hello”没有任何关
		系，当函数结束，str作用结束，所以输出的还是“Hello”。 char ch[] 是传递引用，修改了原内容。对于图片"Java只有值传递"中的解答，有要注意的点：
		1.Java只有值传递，所谓的引用传递其实是对象地址的值传递。2.String = "test OK" 并不是在栈中开辟空间，而是在堆中的常量池中开辟的。

		--putchar只能输出一个字符，puts只能输出一个串。多型就是数据元素的类型不确定。
			字符串常量:以双引号引起来的数据，如"he123" "a"。字符常量:以单引号引起的一个字符，如'a' '\n'。
			字符串的子串，就是字符串中的某一个连续片段。截取一个字符串长度需要一个起始位置和结束位置。n(n+1）/2   + 1 （+1包括空串）

		--空字符串和null的区别：null代表堆内存中根本没有这个东西，而空字符串也是字符串，是有内存空间的。
		--String s=null;没有给s开辟任何空间，当执行length()方法时候，因为没有具体指向的内存空间，所以报出NullPointerException没有指向的错误。出现异常主要是因为执行了s.length()这句话.

		--String(byte[] bytes, String charsetName)
          通过使用指定的 charset 解码指定的 byte 数组，构造一个新的String。
          byte[]	getBytes(String charsetName)
          使用指定的字符集将此String编码为 byte 序列，并将结果存储到一个新的 byte 数组中。

        --String x="fmn";  “fmn”是在常量池里的不可变对象。
			x.toUpperCase();   在堆中new一个"FMN"对象，但无任何引用指向它。
			String y=x.replace('f','F'); 在堆中 new一个"Fmn"对象，y指向它。
			y=y+"wxy"; 在堆中 重新new一个"Fmnwxy"对象， 修改y指向，现在y指向它。

		--只有在String类中，equals（）方法返回的才是对象的内容的比较。

		--String str1="hello";    这样创建字符串是存在于常量池中
			String str2=new String("hello");    str2存在于堆中，
			==是验证两个对象是否是一个（内存地址是否相同）
			用+拼接字符串时会创建一个新对象再返回。

		--14.char[] ch = new char[3];//默认空格
			int [] Int = new int[2];//默认0
			String[] strings = new String[2];//默认null

			15.String s = "hello";
			String t = "hello";
			char c [ ] = {'h','e','1','1','o'};
			System.out.println(s.equals (t)); //true  s和t指向内存常量区的同一个字符串  ;
			System.out.println(t.equals (c));//false 一个返回字符串，一个返回对象 ;
			System.out.println(s==t);// true  s和t指向内存常量区的同一个字符串 ;
			System.out.println(t.equals (new String ("hello")));//true equal用于比较两个对象的值是否相同,和内存地址无关

		--String str1 = "hello";这里的str1指的是方法区的字符串常量池中的“hello”，编译时期就知道的； String str2 = "he" + new String("llo");这里的str2必须在运行时才知道str2是什么，所以它是指向的是堆里定义的字符串“hello”，所以这两个引用是不一样的。
		如果用str1.equal(str2)，那么返回的是True；因为两个字符串的内容一样。




--java向上转型和向下转型【包括类和接口的转型】https://jingyan.baidu.com/article/eae07827bcbbab1fec54853e.html

	---向上转型：指子类对象转换为父类对象。
		1.父类 对象= new 子类，无需强转，丢弃子类的方法。
		2.当调用对象的方法时，如果子类有覆盖方法，就听从子类的方法。
		3.如果调用父类没有的方法，编译会出错。要想调用的话需要先通过向下转型，SON son=(SON)base强制转换，然后用son.methodB()调用就可以了。
		

	---向下转型：	父类引用的对象转换为子类类型。
		1.子类 = （子类）父类对象，要强转。
		2.对象调用子类覆盖的方法，听子类的。
		3.当调用子类没有的方法，则听从父类的方法。

		如果 父类 对象= new 父类； 子类 =（子类）父类；这种情况，编译没有错，运行的时候会提示ClassCastException（类转换异常） 错误，
		如果 父类 对象= new 子类；子类 =（子类）父类；这种情况，编译和运行都没有错。



--Java中成员变量的隐藏：

	---Java文档中对隐藏域的定义：

			在一个类中，子类中的成员变量如果和父类中的成员变量同名，那么即使他们类型不一样，只要名字一样。父类中的成员变量都会被隐藏。在子类中，父类的成员变量不能被简单的用引用来访问。而是，必须从父类的引用获得父类被隐藏的成员变量，一般来说，我们不推荐隐藏成员变量，因为这样会使代码变得难以阅读。

			其实，简单来说，就是子类不会去重写覆盖父类的成员变量，所以成员变量的访问不能像方法一样使用多态去访问。

	---如何访问被隐藏的成员变量？

		其实，通过前面的例子，和刚刚关于成员变量的介绍，其实你已经知道了如何访问被隐藏的成员变量。 就是使用父类的引用来访问成员变量，如Super c2 = new Sub(); System.out.println(" c2.s : " + c2.s);。或者使用System.out.println(((Super)c1).s);。





--关于null
  null是关键字，NULL不是关键字，java区分大小写。
  null表示没有地址；null可以赋值给引用变量，不能将null赋给基本类型变量，例如int、double、float、boolean。

  --一、null是代表不确定的对象
   
            Java中，null是一个关键字，用来标识一个不确定的对象。因此可以将null赋给引用类型变量，但不可以将null赋给基本类型变量。
             
            比如：int a = null;是错误的。Ojbect o = null是正确的。
             
            Java中，变量的适用都遵循一个原则，先定义，并且初始化后，才可以使用。我们不能int a后，不给a指定值，就去打印a的值。这条对对于引用类型变量也是适用的。
             
            有时候，我们定义一个引用类型变量，在刚开始的时候，无法给出一个确定的值，但是不指定值，程序可能会在try语句块中初始化值。这时候，我们下面使用变量的时候就会报错。这时候，可以先给变量指定一个null值，问题就解决了。例如：
             
                    Connection conn = null;
                    try {
                        conn = DriverManager.getConnection("url", "user", "password");
                    } catch (SQLException e) {
                        e.printStackTrace();
                    }
             
                    String catalog = conn.getCatalog();
             
            如果刚开始的时候不指定conn = null，则最后一句就会报错。
   
  二、null本身不是对象，也不是Objcet的实例
   
          null本身虽然能代表一个不确定的对象，但就null本身来说，它不是对象，也不知道什么类型，也不是java.lang.Object的实例。
          可以做一个简单的例子：
           
                  //null是对象吗? 属于Object类型吗?
                  if (null instanceof java.lang.Object) {
                      System.out.println("null属于java.lang.Object类型");
                  } else {
                      System.out.println("null不属于java.lang.Object类型");
                  }
           
          结果会输出：null不属于java.lang.Object类型
   
  三、Java默认给变量赋值
   
          在定义变量的时候，如果定义后没有给变量赋值，则Java在运行时会自动给变量赋值。赋值原则是整数类型int、byte、short、long的自动赋值为0，带小数点的float、double自动赋值为0.0，boolean的自动赋值为false，其他各供引用类型变量自动赋值为null。
          这个具体可以通过调试来看。
   
  四、容器类型与null
   
          List：允许重复元素，可以加入任意多个null。
          Set：不允许重复元素，最多可以加入一个null。
          Map：Map的key最多可以加入一个null，value字段没有限制。
          数组：基本类型数组，定义后，如果不给定初始值，则java运行时会自动给定值。引用类型数组，不给定初始值，则所有的元素值为null。
   
  五、null的其他作用
   
          1、判断一个引用类型数据是否null。 用==来判断。
          2、释放内存，让一个非null的引用类型变量指向null。这样这个对象就不再被任何对象应用了。等待JVM垃圾回收机制去回收。


        3.Arrays.asList()
            将一个数组转化为一个List对象，这个方法会返回一个ArrayList类型的对象， 这个ArrayList类并非java.util.ArrayList类，而是Arrays类的静态内部类！用这个对象对列表进行添加删除更新操作，就会报UnsupportedOperationException异常。



--普及下时间复杂度

一、时间复杂度  
（1）时间频度 
一个算法执行所耗费的时间，从理论上是不能算出来的，必须上机运行测试才能知道。但我们不可能也没有必要对每个算法都上机测试，只需知道哪个算法花费的时间多，哪个算法花费的时间少就可以了。并且一个算法花费的时间与算法中语句的执行次数成正比例，哪个算法中语句执行次数多，它花费时间就多。一个算法中的语句执行次数称为语句频度或时间频度。记为T(n)。 

（2）时间复杂度 
在刚才提到的时间频度中，n称为问题的规模，当n不断变化时，时间频度T(n)也会不断变化。但有时我们想知道它变化时呈现什么规律。为此，我们引入时间复杂度概念。 

一般情况下，算法中基本操作重复执行的次数是问题规模n的某个函数，用T(n)表示，若有某个辅助函数f(n),使得当n趋近于无穷大时，T（n)/f(n)的极限值为不等于零的常数，则称f(n)是T(n)的同数量级函数。记作T(n)=O(f(n)),称O(f(n)) 为算法的渐进时间复杂度，简称时间复杂度。 

在各种不同算法中，若算法中语句执行次数为一个常数，则时间复杂度为O(1),另外，在时间频度不相同时，时间复杂度有可能相同，如T(n)=n2+3n+4与T(n)=4n2+2n+1它们的频度不同，但时间复杂度相同，都为O(n2)。 

按数量级递增排列，常见的时间复杂度有： 

常数阶O(1),对数阶O(log2n),线性阶O(n), 

线性对数阶O(nlog2n),平方阶O(n2)，立方阶O(n3),...， 

k次方阶O(nk),指数阶O(2n)。随着问题规模n的不断增大，上述时间复杂度不断增大，算法的执行效率越低。 

2、空间复杂度 
与时间复杂度类似，空间复杂度是指算法在计算机内执行时所需存储空间的度量。记作: 

S(n)=O(f(n)) 

我们一般所讨论的是除正常占用内存开销外的辅助存储单元规模

 
   二、常见算法时间复杂度：

O(1): 表示算法的运行时间为常量

O(n): 表示该算法是线性算法

O(㏒2n): 二分查找算法

O(n2): 对数组进行排序的各种简单算法，例如直接插入排序的算法。

O(n3): 做两个n阶矩阵的乘法运算

O(2n): 求具有n个元素集合的所有子集的算法

O(n!): 求具有N个元素的全排列的算法

优<---------------------------<劣

O(1)<O(㏒2n)<O(n)<O(n2)<O(2n)

时间复杂度按数量级递增排列依次为：常数阶O(1)、对数阶O(log2n)、线性阶O(n)、线性对数阶O(nlog2n)、平方阶O(n2)、立方阶O(n3)、……k次方阶O(nk)、指数阶O(2n)。

三、算法的时间复杂度（计算实例）

定义：如果一个问题的规模是n，解这一问题的某一算法所需要的时间为T(n)，它是n的某一函数 T(n)称为这一算法的“时间复杂性”。

当输入量n逐渐加大时，时间复杂性的极限情形称为算法的“渐近时间复杂性”。

我们常用大O表示法表示时间复杂性，注意它是某一个算法的时间复杂性。大O表示只是说有上界，由定义如果f(n)=O(n)，那显然成立f(n)=O(n^2)，它给你一个上界，但并不是上确界，但人们在表示的时候一般都习惯表示前者。

此外，一个问题本身也有它的复杂性，如果某个算法的复杂性到达了这个问题复杂性的下界，那就称这样的算法是最佳算法。

“大O记法”：在这种描述中使用的基本参数是 n，即问题实例的规模，把复杂性或运行时间表达为n的函数。这里的“O”表示量级 (order)，比如说“二分检索是 O(logn)的”,也就是说它需要“通过logn量级的步骤去检索一个规模为n的数组”记法 O ( f(n) )表示当 n增大时，运行时间至多将以正比于 f(n)的速度增长。

这种渐进估计对算法的理论分析和大致比较是非常有价值的，但在实践中细节也可能造成差异。例如，一个低附加代价的O(n2)算法在n较小的情况下可能比一个高附加代价的 O(nlogn)算法运行得更快。当然，随着n足够大以后，具有较慢上升函数的算法必然工作得更快。

O(1)

Temp=i;i=j;j=temp;                    

以上三条单个语句的频度均为1，该程序段的执行时间是一个与问题规模n无关的常数。算法的时间复杂度为常数阶，记作T(n)=O(1)。如果算法的执行时 间不随着问题规模n的增加而增长，即使算法中有上千条语句，其执行时间也不过是一个较大的常数。此类算法的时间复杂度是O(1)。


O(n^2)

2.1. 交换i和j的内容

     sum=0；                 （一次）

     for(i=1;i<=n;i++)       （n次 ）

        for(j=1;j<=n;j++) （n^2次 ）

         sum++；       （n^2次 ）

解：T(n)=2n^2+n+1 =O(n^2)

2.2.   

    for (i=1;i<n;i++)

    {

        y=y+1;         ①   

        for (j=0;j<=(2*n);j++)    

           x++;        ②      

    }         

解： 语句1的频度是n-1

          语句2的频度是(n-1)*(2n+1)=2n^2-n-1

          f(n)=2n^2-n-1+(n-1)=2n^2-2

          该程序的时间复杂度T(n)=O(n^2).         


O(n)                                                

2.3.

    a=0;

    b=1;                      ①

    for (i=1;i<=n;i++) ②

    {  

       s=a+b;　　　　③

       b=a;　　　　　④  

       a=s;　　　　　⑤

    }

解： 语句1的频度：2,        1

        语句2的频度： n,        n

        语句3的频度： n-1,      n  

        语句4的频度：n-1,    n

        语句5的频度：n-1,      n                            

        T(n)=2+n+3(n-1)=4n-1=O(n).

                                                                                                 

O(log2n )

2.4.

     i=1;       ①

    while (i<=n)

       i=i*2; ②

解： 语句1的频度是1,  

          设语句2的频度是f(n),   则：2^f(n)<=n;f(n)<=log2n    

          取最大值f(n)= log2n,

          T(n)=O(log2n )

O(n^3)

2.5.

    for(i=0;i<n;i++)

    {  

       for(j=0;j<i;j++)  

       {

          for(k=0;k<j;k++)

             x=x+2;  

       }

    }

解：当i=m, j=k的时候,内层循环的次数为k当i=m时, j 可以取 0,1,...,m-1 , 所以这里最内循环共进行了0+1+...+m-1=(m-1)m/2次所以,i从0取到n, 则循环共进行了: 0+(1-1)*1/2+...+(n-1)n/2=n(n+1)(n-1)/6所以时间复杂度为O(n^3).

我们还应该区分算法的最坏情况的行为和期望行为。如快速排序的最 坏情况运行时间是 O(n^2)，但期望时间是 O(nlogn)。通过每次都仔细 地选择基准值，我们有可能把平方情况 (即O(n^2)情况)的概率减小到几乎等于 0。在实际中，精心实现的快速排序一般都能以 (O(nlogn)时间运行。

下面是一些常用的记法：

访问数组中的元素是常数时间操作，或说O(1)操作。一个算法如果能在每个步骤去掉一半数据元素，如二分检索，通常它就取 O(logn)时间。用strcmp比较两个具有n个字符的串需要O(n)时间 。常规的矩阵乘算法是O(n^3)，因为算出每个元素都需要将n对 元素相乘并加到一起，所有元素的个数是n^2。

指数时间算法通常来源于需要求出所有可能结果。例如，n个元 素的集合共有2n个子集,所以要求出所有子集的算法将是O(2n)的 。指数算法一般说来是太复杂了，除非n的值非常小，因为，在 这个问题中增加一个元素就导致运行时间加倍。不幸的是，确实有许多问题 (如著名 的“巡回售货员问题” )，到目前为止找到的算法都是指数的。如果我们真的遇到这种情况， 通常应该用寻找近似最佳结果的算法替代之。



--Java的缓存机制：

	---1、基本型和基本型封装型进行“==”运算符的比较，基本型封装型将会自动拆箱变为基本型后再进行比较，因此Integer(0)会自动拆箱为int类型再进行比较，显然返回true；

	         int a = 220;

	         Integer b = 220;

	        System.out.println(a==b);//true
	---2、两个Integer类型进行“==”比较， 如果其值在-128至127  ，那么返回true，否则返回false, 这跟Integer.valueOf()的缓冲对象有关，这里不进行赘述。

	        Integer c=3;
	        Integer h=3;
	        Integer e=321;
	        Integer f=321;
	        System.out.println(c==h);//true
	        System.out.println(e==f);//false
	---3、两个基本型的封装型进行equals()比较，首先equals()会比较类型，如果类型相同，则继续比较值，如果值也相同，返回true。

	        Integer a=1;
	        Integer b=2;
	        Integer c=3;
	        System.out.println(c.equals(a+b));//true
	---4、基本型封装类型调用equals(),但是参数是基本类型，这时候，先会进行自动装箱，基本型转换为其封装类型，再进行3中的比较。  

	        int i=1;
	        int j = 2;
	        Integer c=3;
	        System.out.println(c.equals(i+j));//true

	--- Java封装类缓存
	        --基本类型、对象引用都在栈中；而对象本身在堆中。
	            == ：基本数据类型比较的是值 对象比较的是地址 ，
	            基本数据类型与封装类比较会自动拆箱，所以比较的还是值，两个封装类比较的是地址；
	            Equals： 比较值；
	        --Integer a = 1000  它的内部就是这样的：   Integer i = Integer.valueOf(1000);
	            而valueOf方法内部会去取缓存（默认范围 [-128, 127]） ，不会创建新对象。