
-- 关于序列化：
    在序列化的时候，被transient或者static修饰的属性，不可以序列化。
    ---一个类可以被序列化，那么它的子类也可以被序列化。
    ---序列化可以实现深复制，而Object中的clone实现的就只是浅复制。


--jdk里的jre与外面的jre有什么不同？
    1.为什么Sun要让JDK安装两套相同的JRE？
    JDK里的工具有些是用Java所编写，因此要使用JDK所附的工具来开发Java程序，也必须要附一套JRE才行，（如javac.exe、jar.exe等）。
    javac.exe与输入 java -cp c:/jdk/lib/tools.jar com.sun.tools.javac.Main 是一样的，可以认为javac.exe只是一个包装器（Wrapper），目的是简写指令。
    另外一套JRE就是专门用来运行开发好的Java程序用的。

    2.公用jre，就是你觉得没用的那个jre主要是为开发好的java程序提供执行的平台。
    假设jdk与公用jre各安装至C:\Program Files\Java\jdk1.6.0和C:\Program Files\Java\jre1.6.0，你会看到，在jdk1.6.0目录下也有一个jre目录，只是jdk本身所附的jre，是在你开发java程序时做测试之用。它与公用jre的主要差别在于jdk本身所附的jre比公用jre多了个server的vm执行选项，通过对比查看C:\Program Files\Java\jdk1.6.0\jre\bin和C:\Program Files\Java\jre1.6.0\bin就可以了解。
    server与client选项的差别在于所使用的vm不同，执行java程序时默认的是client VM。若使用server VM，会花比较长的启动时间及消耗较多的内存，为的是启动程序后可以获得较好的执行性能。



--区分Java中的关键字和Java标识符：
    ---关键字：
    1.Java 语言中有一些具有特殊用途的词被称为关键字。关键字对Java的编译器有着特殊的意义，在程序中应用时一定要慎重哦！！
    最常用的就有基本数据类型，try……catch……
    2.Java 关键字是区分大小写的哦！所以 void 是关键字，但 Void 就不是了~~

    ---标识符就是用于给 Java 程序中类、变量、方法等命名的符号。
    使用标识符时，需要遵守几条规则：

     1.  标识符可以由字母、数字、下划线（_）、美元符（$）组成，但不能包含@、%、空格等其它特殊字符，不能以数字开头。譬如：123name 就是不合法滴
     2.  标识符不能是 Java 关键字和保留字（ Java 预留的关键字，以后的升级版本中有可能作为关键字），但可以包含关键字和保留字。如：不可以使用 void 作为标识符，但是Myvoid 可以
     3.  标识符是严格区分大小写的。所以涅，一定要分清楚imooc和IMooc是两个不同的标识符哦！
     4.  标识符的命名最好能反映出其作用，做到见名知意。



--Socket套接字:
    就是源Ip地址，目标IP地址，源端口号和目标端口号的组合
    服务器端：ServerSocket提供的实例
    ServerSocket server= new ServerSocket(端口号)
    客户端：Socket提供的实例
    Socket soc=new Socket(ip地址，端口号)

    Client通过 new socket(ip,端口号)来建立与服务端连接.



--正则表达式的贪婪和非贪婪：
      1.什么是正则表达式的贪婪与非贪婪匹配
      如：String str="abcaxc";

      Patter p="ab*c";

      贪婪匹配:正则表达式一般趋向于最大长度匹配，也就是所谓的贪婪匹配。如上面使用模式p匹配字符串str，结果就是匹配到：abcaxc(ab*c)。

      非贪婪匹配：就是匹配到结果就好，就少的匹配字符。如上面使用模式p匹配字符串str，结果就是匹配到：abc(ab*c)。
      2.编程中如何区分两种模式

      默认是贪婪模式；在量词后面直接加上一个问号？就是非贪婪模式。

      量词：{m,n}：m到n个

      *：任意多个

      +：一个到多个

      ？：0或一个
      以上来自博主的博客，然后这道题目
      .表示除\n之外的任意字符
      *表示匹配0-无穷 
      +表示匹配1-无穷
      (?=Expression) 顺序环视，(?=\\()就是匹配正括号
      懒惰模式正则： 
      src=".*? (?=\\()） "
      结果：北京市
      因为匹配到第一个"就结束了一次匹配。不会继续向后匹配。因为他懒惰嘛。
    
    由于replaceAll方法的第一个参数是一个正则表达式，而"."在正则表达式中表示任何字符，所以会把前面字符串的所有字符都替换成"/"。如果想替换的只是"."，那么久要写成"\\.".



--Java内存模型：
        ---Java线程之间的通信由Java内存模型（简称为JMM）控制，JMM决定一个线程对共享变量的写入何时对另一个线程可见。从抽象的角度来看，JMM定义了线程和主内存之间的抽象关系：线程之间的共享变量存储在主内存（main memory）中，每个线程都有一个私有的本地内存（local memory），本地内存中存储了该线程以读写共享变量的副本。本地内存是JMM的一个抽象概念，并不真实存在。它涵盖了缓存，写缓冲区，寄存器以及其他的硬件和编译器优化。volatile变量的写-读可以实现线程之间的通信。从内存语义的角度来说，volatile与监视器锁有相同的效果：volatile写和监视器的释放有相同的内存语义；volatile读与监视器的获取有相同的内存语义。

        ---同一个类的对象使用不同的内存段，但静态成员共享相同的内存空间.



--关于构造方法：

    1.构造方法也是类的方法，可以在创建对象时为成员变量赋值
    2.构造方法可以进行重载，但是参数列表必须不相同，不以返回值和访问级别进行区分
    3.构造方法没有返回值
    4.构造方法一定要与定义为public的类同名
    5.接口中的方法默认是public abstract,且子类的访问权限不能低于父类
    48.由于构造器的名字必须与类名相同，而匿名类没有类名，所以匿名类不能有构造器。
    38.如果Child是class，且只有一个有参数的构造函数，那么必然会调用Parent中相同参数的构造函数。错的！因为可以调用父类无参的构造函数，子类的有参构造函数和是否调用父类的有参数的构造函数无必然联系。

    其实 普通的类方法是可以和类名同名的，和构造方法唯一的区分就是，构造方法没有返回值。

    当不显示提供构造方法时，Java才提供一个默认构造方法，当我们显示的提供一个无参或带参的构造方法时，Java都不会再提供构造方法了。
    java的构造函数在创建对象时，就会自动调用它.

    构造函数不能被继承，构造方法只能被显式或隐式的调用。



问题： java中子类继承父类时是否继承构造函数呢？
﻿﻿
          java继承中对构造函数是不继承的。

          以下是例子：

           public class FatherClass {
           public FatherClass() {
                 System.out.println(100);
           }

           public FatherClass(int age) {
                System.out.println(age);
           }

          }

           

          public class SonClass extends FatherClass{

                  public SonClass() {
                   }
                  public SonClass(int c) {
                           System.out.println(1234);
                  }
             
           public static void main(String[] args) {

            FatherClass f = new FatherClass(28);
            SonClass s = new SonClass(66);
           
           }
          }

          编译后执行结果如下是什么呢？

          分析：1. FatherClass f = new FatherClass(28);这句没有必要解释

          2.SonClass s = new SonClass(66);执行这句时，调用

           public SonClass(int c) {
                           System.out.println(1234);
                  }


          在这个构造函数中，等价于

           public SonClass(int c) {

                          super();//必须是第1行，否则不能编译
                           System.out.println(1234);
                  }

          所以结果是    100
                                   1234

          3.如果子类构造函数是这样写的

          public SonClass(int c) {

                          super(22);//必须是第1行，否则不能编译

                         //显示调用了super后，系统就不再调用super();
                           System.out.println(1234);
                  }

          执行结果是   22
                                   1234

          总结1：构造函数不能继承，只是调用而已。

          如果父类没有无参构造函数

          创建子类时，不能编译，除非在构造函数代码体中第一行，必须是第一行显示调用父类有参构造函数

          如下：

          SonClass (){

          super(777);//显示调用父类有参构造函数

          System.out.println(66);

          }

          如果不显示调用父类有参构造函数，系统会默认调用父类无参构造函数super();

          但是父类中没有无参构造函数，那它不是不能调用了。所以编译就无法通过了。

          总结2：创建有参构造函数后，系统就不再有默认无参构造函数。

          如果没有任何构造函数，系统会默认有一个无参构造函数。



--值传递和引用传递：Java 语言是一种强类型语言。通俗点说就是，在 Java 中存储的数据都是有类型的，而且必须在编译时就确定其类型。

        Java语言 中只有按值传递。但是java方法参数中有两种类型：基本数据类型（Primitive types）和对象引用（Object reference）。所以就有人以为当传递Object时是Call by reference。其实还是传递的这个reference的副本。
        基本数据类型变量存的是数据本身，而引用类型变量存的是保存数据的空间地址。

        引用数据类型是引用传递（call by reference），基本数据类型是值传递（call by value）
        值传递不可以改变原变量的内容和地址---》原因是java方法的形参传递都是传递原变量的副本，在方法中改变的是副本的值，而不适合原变量的。
        引用传递不可以改变原变量的地址，但可以改变原变量的内容---》原因是当副本的引用改变时，原变量 的引用并没有发生变化，当副本改变内容时，由于副本引用指向的是原变量的地址空间，所以，原变量的内容发生变化。

        引用传值方式传入参数时候,函数对参数复制了一份,在传入结构比较大的参数时,使用引用 可以避免 函数对参数构造和析构的 开销...

        结论：1.值传递不可以改变原变量的内容和地址；
                  2.引用传递不可以改变原变量的地址，但可以改变原变量的内容；

        Java中的四类八种基本数据类型：
            第一类：整数类型  byte short int long
            第二类：浮点型  float double
            第三类：逻辑型    boolean(它只有两个值可取true false)
            第四类：字符型  char
            除此之外都是引用类型，包括类、数组、接口。String 是一种常见的引用数据类型，用来表示字符串。

      基本类型和String=""是传值，其他类型都是传引用，当然，也可以认为java只有传值，因为一个是拷贝了栈中的值，一个是拷贝了引用的地址值。

      ---Java基本类型：

      float占4个字节为什么比long占8个字节大呢，因为底层的实现方式不同。
      浮点数的32位并不是简单直接表示大小，而是按照一定标准分配的。
      第1位，符号位，即S
      接下来8位，指数域，即E。
      剩下23位，小数域，即M，取值范围为[1 ,2 ) 或[0 , 1)
      然后按照公式： V=(-1)^s * M * 2^E
      也就是说浮点数在内存中的32位不是简单地转换为十进制，而是通过公式来计算而来，通过这个公式虽然，只有4个字节，但浮点数最大值要比长整型的范围要大。

      long和float，正常定义需要加l和f，但是long和float属于基本类型，会进行转化，所以不会报出异常。
      boolean类型不能和任何类型进行转换，会报出类型异常错误。
      byte的取值范围是-128—127。报出异常： cannot convert from int to byte.
      int的取值范围为： -2^31—2^31-1，即-2147483648——2147483647；
      1个字节的数据的取值范围为什么是-128到127 ；

      类变量在不设置初始值时，会进行默认值赋值。然而，局部方法中声明的变量则必须进行初始化，他不会进行默认值赋值。
      关于类的成员变量若没有赋值，都存在默认值的。对于基本类型，都存在对应值，int ： 0；对于引用类型，为null。 

      没有final修饰的变量相加后会被自动提升为int型。
      表达式的数据类型自动提升, 关于类型的自动提升，注意下面的规则。
        ①所有的byte,short，char型的值将被提升为int型；
        ②如果有一个操作数是long型，计算结果是long型；
        ③如果有一个操作数是float型，计算结果是float型；
        ④如果有一个操作数是double型，计算结果是double型；


      Float是类，float不是类.
      查看JDK源码就可以发现Byte，Character，Short，Integer，Long，Float，Double，Boolean都在java.lang包中.
      Float正确复制方式是Float f=1.0f,若不加f会被识别成double型,double无法向float隐式转换.
      Float a= new Float(1.0)是正确的赋值方法，但是在1.5及以上版本引入自动装箱拆箱后，会提示这是不必要的装箱的警告，通常直接使用Float f=1.0f.


--原码、反码和补码：

      10原码：0000000000000000,0000000000001010；
      -10： 1111111111111111,1111111111110101  变为负数，计算机用补码存储
      -10反码：10000000000000000,0000000000001010
      -10补码：10000000000000000,0000000000001011，等于 -11
      故程序结果-6

      0X是16进制

      1、Java中用补码形式表示
      2、第一位正负位，1表示负，0表示正。
      3、原码：一个数的二进制表示。
                       3的原码00000011   -3的 原码 10000011
      4、反码：负数原码按位取反（符号位不变）。正数原码本身。
                      3的反码00000011   -3的反码11111100
      5、补码：正数是原码本身。负数反码加1。
                       3的补码是00000011  -3的补码是11111101
      -------------------------------------------------------------------------------
      int占4个字节，32位
      byte占1个字节，8位
      所以强转时会截断。前24位
      ---------------------------------------------------------------------------
      在内存中表示形式（ 注意java中是以补码表示一个数，所以表示形式是补码，不是原码！ ）：
      int a = 3         00000000  00000000  00000000 00000011 （强转byte时前面24个0被截断）
      byte b = 3      00000011
      int a = -3       11111111  11111111   11111111   11111101 （强转byte时前面24个1被截断）
      byte b = -3     11111101
      ----------------------------------------------------------------------------
      已知负数的补码，求负数：
      补码-1=反码，反码按位取反=该负数绝对值
      已知负数，求负数的补码：
      1、负数原码除了符号位，按位取反（不含符号位），加1。
      2、负数绝对值的补码（也就是原码），按位取反（含符号位），加1
      -------------------------------------------------------------------------------
      例子：
      java int 128转为byte，值：
      128为正数，补码为10000000（前面24个0省略），变成byte，只剩下10000000（byte为1个字节），因为开头是1，所以为负数。即1个负数的补码是10000000。反码是01111111，原码是1000000。是128.因为是负数，所以是-128。



--关于static：

    无法直接调用静态初始化块，静态初始化块既没有访问修饰符，也没有参数。
    java不允许单独的方法，过程或函数存在,需要隶属于某一类中。java语言中的方法属于对象的成员,而不是类的成员。不过，其中静态方法属于类的成员；
    静态成员变量或静态代码块>main方法>非静态成员变量或非静态代码块>构造方法。
    被static修饰的变量称为静态变量，静态变量属于整个类，而局部变量属于方法，只在该方法内有效，所以static不能修饰局部变量。static 修饰的变量属于类。

    1如果是本类使用，可以直接就用静态变量名。
    2如果是其他类使用，可以使用类名来调用，也可以创建一个实例对象来调用。
    3如果静态变量所在的类是静态类，那么不管在本类里或者在其他外部类，都可以直接使用静态变量名。

    static不能用来修饰类，除非类是内部类，此时该类作为外部类的成员变量，可以用static来修饰；
    静态方法中不能调用对象的变量，因为静态方法在类加载时就初始化，对象变量需要在新建对象后才能使用。

    JVM加载class文件时，就会执行静态代码块，静态代码块中初始化了一个变量x并初始化为5，由于该变量是个局部变量，静态代码快执行完后变被释放。

    java为什么要使用静态变量或静态方法：
    Java类中的静态变量在程序运行期间，其内存空间对所有该类的对象实例而言是共享的，有些时候可以认为是全局变量。因此在某些时候为了节省系统内存开销、共享资源，可以将类中的一些变量声明为静态变量!
    我在补充一下:
    静态还有一个好处,可以代替包,有些时候不想用一个包,来封装一个类做一个公共的数据使用的时候,就可以通过静态属性来完成!
    工具类中的方法基本上都是静态的，直接用类名调用，不用实例化对象，方便。

    static变量不能使用this!!!!!!!!!!!，static 方法中没有this 这么一说.

    在类方法中不能有this关键字，，直接调用类方法即可，在类方法中可以通过创建实例对象调用类的实例方法。先要理解什么是类的方法，所谓类的方法就是指类中用static 修饰的方法（非static 为实例方法），比如main 方法，那么可以以main 方法为例，可直接调用其他类方法，必须通过实例调用实例方法，this 关键字不是这么用的。

    静态内部类可以访问外围类的静态数据，包括私有数据，但不能访问非静态数据；非静态内部类可以直接访问外围类的数据，包括私有数据 。


    静态成员属于整个类，当系统第一次使用该类时，就会为其分配内存空间直到该类被卸载才会进行资源回收！~~
    静态方法中可以直接调用同类中的静态成员，但不能直接调用非静态成员。
    静态初始化块只在类加载时执行，且只会执行一次，同时静态初始化块只能给静态变量赋值，不能初始化普通的成员变量。




--equals（）和hashcode（）方法：

      --都不是final方法，所以可以override。
      --equals（）判断2个对象是否相等；
      --hashcode（）计算对象的哈希码；
      --设计一个类需要重写equals时，必须重写hashcode方法；
      --hashcode方法：
            ---public native int hashCode();
            ---配合基于散列的集合【hashset、hashmap、hashtable】一起运行；
            ---集合中会有一个table保存存进去的对象的hashcode值。如果table中没有该hashcode值，它就可以直接存进去，不用再比较；如果存在，就用equals方法与新元素比较，相同则不存了，不同则散列到其他地址。
            ---hashcode方法的存在是为了减少equals方法调用次数，从而提高效率。
            ---hashcode返回的并非都是对象的存储地址，只是有所关联；默认情况下，hashcode方法是将对象的存储地址进行映射；
            ---不能根据hashcode值判断2个对象是否相等，但可以根据hashcode值判断2个对象不等；
            ---equals（）得到的结果是true，则两个对象的hashcode值必定相等；
              equals（）得到的结果是false，则两个对象的hashcode值不一定不等；
              两个对象的hashcode值不等，equals（）得到的结果一定是false；
              两个对象的hashcode值相等，equals（）得到的结果未知；


--equals和==区别：
                    基本类型          引用类型
==               值                    对象地址
equals          不能作用          对象内容

  ---对于"=="
        *用于基本数据类型相互比较. 比较二者的值是否相等.
        *用于引用数据类型相互比较. 比较二者地址是否相等.
        *不能用于基本数据类型与引用型比较.
        ==  优先级高于 三目运算符.

  ---对于"equals":
        * 不能用于基本数据类型比较(因为这是一个方法, 继承自object).
        *用于进行对象的比较, 比较二者的引用地址是否相同.

  ---特殊情况:
        1)数值型基本类型和数值型类会存在自动装箱和自动拆箱.
        2)字符串会以常量形式存在, 如果多个字符串变量值相同, 则他们指向同一个地址.
        3)数值类型会存在类型自动转换.



--Java装箱和拆箱：
        ---装箱——值类型转换为引用类型；拆箱——引用类型转换为值类型。
        
        1.①无论如何，Integer与new Integer不会相等。不会经历拆箱过程， 
          ②两个都是非new出来的Integer，如果数在-128到127之间，则是true,否则为false （Java缓存类型）
          java在编译Integer i2 = 128的时候,被翻译成-> Integer i2 = Integer.valueOf(128);而valueOf()函数会对-128到127之间的数进行缓存 
          ③两个都是new出来的,都为false 
          ④int和integer(无论new否)比，都为true，因为会把Integer自动拆箱为int再去比。
          
        2.包装类的“==”运算在不遇到算术运算的情况下不会自动拆箱，包装类的equals()方法不处理数据转型


--Java编码：
      Java默认使用Unioncode编码，即不论什么语言都是一个字符占两个字节
      Java的class文件编码为UTF-8，而虚拟机JVM编码为UTF-16
      UTF-8编码下，一个中文占3个字节，一个英文占1个字节
      Java中的char默认采用Unicode编码，所以Java中char占2个字节
      1(byte)字节=8(bit)位.
      ResourceBundle能够依据Local的不同，选择性的读取与Local对应后缀的properties文件，以达到国际化的目的。

      Java语言中，中文字符所占的字节数取决于字符的编码方式，一般情况下，采用ISO8859-1编码方式时，一个中文字符与一个英文字符一样只占1个字节；采用GB2312或GBK编码方式时，一个中文字符占2个字节；而采用UTF-8编码方式时，一个中文字符会占3个字节。

      常见字符的ASCII码值如下：空格的ASCII码值为32；数字0到9的ASCII码值分别为48到57；大写字母“A”到“Z”的ASCII码值分别为65到90；小写字母“a”到“z”的ASCII码值分别为97到到122。


--数组：

    写一下个人理解的数组声明为什么这么写？
    第一个就是为什么左边不用标大小，而右边需要标大小？ 
    首先数组一个对象，它不属于任何类，由jvm在运行期间在堆中创建并继承object，同时添加length属性。由于数组对象所占的内存在堆上，所以在声明时应明确告诉jvm自己所占的大小，方便分配，又因为数组对象的引用在栈中，所以声明时左边就无需标大小，之所以写成2个括号，就是为了表明这个引用指向堆中的二维数组。
    第二个就是为什么右边数组可以只声明几行，无需声明没行的大小？ 
    大概jvm在运行期间会根据行数分配对应的可扩展空间，方便每一行进行扩充。其实又可以按c语言那样理解，行其实又是一种引用，行首地址又代表一个一维数组。

    1.Java中数组是对象，不是基本数据类型（原生类），大小不可变且连续存储，因为是对象所以存在堆中。
    2.数组类是在运行的过程中创建的 
    3.Java中数组内容存储在连续的堆内存中，数组名（引用） 存储在栈内存中指向堆内存中的内容。

    在java 中，声明一个数组时，不能直接限定数组长度，只有在创建实例化对象时，才能对给定数组长度。定义一个变量时，仅仅定义了一个变量，这个引用变量还未指向任何有效的内存 。

    java中的数组自带length属性，例如：假设有个二维数组a[][]；  a.length就是行数，a[0].length就是列数啦；

    二维数组：
    需要了解的：在定义二维数组时也可以只指定行的个数，然后再为每一行分别指定列的个数。如果每行的列数不同，则创建的是不规则的二维数组。

    真数组： 数组元素在内存中是一个接着一个线性存放的，通过第一个元素就能访问随后的元素，避免了数据覆盖的可能性，和数据类型覆盖并没有关系。


    使用 Arrays 类操作 Java 中的数组：
    Arrays 类是 Java 中提供的一个工具类，在 java.util 包中。该类中包含了一些方法用来直接操作数组，比如可直接实现数组的排序、搜索等（关于类和方法的相关内容在后面的章节中会详细讲解滴~~）。
    Arrays 中常用的方法：
    1、 排序
    语法：  Arrays.sort(数组名);
    可以使用 sort( ) 方法实现对数组的排序，只要将数组名放在 sort( ) 方法的括号中，就可以完成对该数组的排序（按升序排列）；

    2、 将数组转换为字符串
    语法：  Arrays.toString(数组名);
    可以使用 toString( ) 方法将一个数组转换成字符串，该方法按顺序把多个数组元素连接在一起，多个元素之间使用逗号和空格隔开



--关于泛型：

    泛型只在编译的时候保证数据类型的正确性，和运行时性能无关。
    --1. 只看尖括号里边的！！明确点和范围两个概念
    --2. 如果尖括号里的是一个类，那么尖括号里的就是一个点，比如List<A>,List<B>,List<Object>
    --3. 如果尖括号里面带有问号，那么代表一个范围，<? extends A> 代表小于等于A的范围，<? super A>代表大于等于A的范围，<?>代表全部范围
    4. 尖括号里的所有点之间互相赋值都是错，除非是俩相同的点
    5. 尖括号小范围赋值给大范围，对，大范围赋值给小范围，错。如果某点包含在某个范围里，那么可以赋值，否则，不能赋值
    6. List<?>和List 是相等的，都代表最大范围
    ----------------------------------------------------------------------------------
    7.补充：List既是点也是范围，当表示范围时，表示最大范围

    下面贴代码：（本来用的Eclipse截图的，结果好像网站出来Bug，不能传图了o(╯□╰)o）
    public static void main(String[] args) {
            List<A> a;
            List list;
            list = a;   //A对，因为List就是List<?>，代表最大的范围，A只是其中的一个点，肯定被包含在内
            List<B> b;
            a = b;      //B错，点之间不能相互赋值
            List<?> qm;
            List<Object> o;
            qm = o;     //C对，List<?>代表最大的范围，List<Object>只是一个点，肯定被包含在内
            List<D> d;
            List<? extends B> downB;
            downB = d;  //D对，List<? extends B>代表小于等于B的范围，List<D>是一个点，在其中
            List<?extends A> downA;
            a = downA;  //E错，范围不能赋值给点
            a = o;      //F错，List<Object>只是一个点
            downA = downB;  //G对，小于等于A的范围包含小于等于B的范围，因为B本来就比A小，B时A的子类嘛
        }

       泛型值存在于java的编译期，编译后生成字节码文件泛型是被擦除的。



--反射：
	
	通过反射机制，可以在运行时访问java对象的属性、方法、构造方法；

	在运行状态下，对于任意一个类，都能知道这个类的所有属性和方法；
	 对于任意一个对象，都可以调用它的任意一个属性和方法。这种动态获取的信息和动态调用对象的方法的功能叫做反射。


	应用场景：
					1.开发通用框架；
					2.动态代理；
					3.注解；
					4.可扩展功能；


 	Java的反射机制主要由以下来实现：
														    Class类；一个类
														    Constructor类；类的构造方法
														    Field类；类的属性
														    Method类；类的方法


	通过反射创建对象：与传统的通过new 来获取对象的方式不同 ，反射机制，会先拿到Hero的“类对象”,然后通过类对象获取“构造器对象” ，再通过构造器对象创建一个对象；

		eg：//使用反射的方式创建对象
		        String className = "charactor.Hero";	包名+类名

		        //类对象
		        Class pClass=Class.forName(className);

		        //构造器
		        Constructor c= pClass.getConstructor();

		        //通过构造器实例化
		        Hero h2= (Hero) c.newInstance();



	Class对象的生成方式如下：

	    1.类名.class       				 说明： JVM将使用类装载器, 将类装入内存(前提是:类还没有装入内存),不做类的初始化工作.返回Class的对象

	    2.Class.forName("类名字符串")  （注：类名字符串是包名+类名）      				说明：装入类,并做类的静态初始化，返回Class的对象

	    3.实例对象.getClass()     					说明：对类进行静态初始化、非静态初始化；返回引用运行时真正所指的对象(因为:子对象的引用可能会赋给父对象的引用变量中)所属的类的Class的对象。



	实质：  实际上java的每个类被编译成.class文件的时候，java虚拟机（叫jvm）会自动为这个类生成一个类对象，这个对象保存了这个类的所有信息（成员变量，方法，构造器等），以后这个类要想实例化（也就是创				建类的实例或创建类的对象）那么都要以这个class对象为蓝图（或模版）来创建这个类的实例。

	  			eg：class<?> c=Class.forName("com.pojo.User"); 
	  					c就是User的类对象，而 User u=new User();这个u就是以c为模版创建的，其实就相当于u=c.newInstance(); 这个在java的反射里面讲的比较清楚。




--Java注解：









--Java命名格式：
    包名：一律采用小写。

    类名：首字母大写 、其余组成词依次首字母大写。

    方法名：首字母小写、其余组成词首字母大写。

    属性（变量名）：
    个人理解 分两种情况：1、变量名由多单词组成时，第一个单词的首字母小写，其后单词的首字母大写，俗称骆驼式命名法（也称驼峰命名法），如 myAge；
                                      2、变量命名时，尽量简短且能清楚的表达变量的作用，做到见名知意。如：定义变量名 stuName 保存“学生姓名”信息；

       a：全局变量：大写规范。

       b：局部变量：小写规范。

       c：属性、常量：大写规范。



--关于Object对象类：

    Object默认的基本方法中没有copy()，含有如下方法：getClass(), hashCode(), equals(), clone(), toString(), notify(), notifyAll(),  wait(), finalize()；
    源代码：https://www.nowcoder.com/test/question/done?tid=16664302&qid=14830#summary
    Object对象类的方法：
      1．clone方法
      保护方法，实现对象的浅复制，只有实现了Cloneable接口才可以调用该方法，否则抛出CloneNotSupportedException异常。
      2．getClass方法
      final方法，获得运行时类型。
      3．toString方法
      该方法用得比较多，一般子类都有覆盖。
      4．finalize方法
      该方法用于释放资源。因为无法确定该方法什么时候被调用，很少使用。
      5．equals方法
      该方法是非常重要的一个方法。一般equals和==是不一样的，但是在Object中两者是一样的。子类一般都要重写这个方法。
      6．hashCode方法
      该方法用于哈希查找，重写了equals方法一般都要重写hashCode方法。这个方法在一些具有哈希功能的Collection中用到。
      一般必须满足obj1.equals(obj2)==true。可以推出obj1.hash- Code()==obj2.hashCode()，但是hashCode相等不一定就满足equals。不过为了提高效率，应该尽量使上面两个条件接近等价。
      7．wait方法
      wait方法就是使当前线程等待该对象的锁，当前线程必须是该对象的拥有者，也就是具有该对象的锁。wait()方法一直等待，直到获得锁或者被中断。wait(long timeout)设定一个超时间隔，如果在规定时间内没有获得锁就返回。
      调用该方法后当前线程进入睡眠状态，直到以下事件发生。
        （1）其他线程调用了该对象的notify方法。
        （2）其他线程调用了该对象的notifyAll方法。
        （3）其他线程调用了interrupt中断该线程。
        （4）时间间隔到了。
      此时该线程就可以被调度了，如果是被中断的话就抛出一个InterruptedException异常。
      8．notify方法
      该方法唤醒在该对象上等待的某个线程。
      9．notifyAll方法
      该方法唤醒在该对象上等待的所有线程。
      这种类型的题一般考察点有两个：
                                                          1.Object中没有hasNext（） 方式，这个方法是迭代器中的
                                                          2.Object没有copy方法，但是有clone()方法， 用于创建并返回该对象的一个副本

      ---Object中没有hasNext（） 方式，这个方法是迭代器中的
      ---Object没有copy方法，但是有clone()方法， 用于创建并返回该对象的一个副本
      ---equals方法,该方法是非常重要的一个方法。一般equals和==是不一样的，但是在Object中两者是一样的。子类一般都要重写这个方法。

    ---Object类中通用方法之：toString()方法：
    1、System.out的println()方法只能在控制台上输出字符串，而Apple类实例是一个在内存中的对象，当用这种方法输出对象时，实际上输出的是Object类中的toString()方法返回值
    2、toString()方法是Object类里的一个实例方法，所有的Java类都是Object类的子类，所以所有Java对象都有toString()方法
    3、toString()方法是一个“自我描述”的方法，当输出某实例对象时，可以通过重写自定义等方式为对象实现输出自我描述的信息
    4、Object类的toString()方法默认返回该对象实现类的“类名+@+hashcode”值（如上结果中看到的那样），这个返回值不能实现自我描述功能，所以需要重写Object类的toString()方法来实现。

    Object类中的getClass方法是final的，所以无论谁调用得到的都一样，都是当前类的名字,
    得到父类名字用getClass.getSuperclass().
    super.getClass().getName():当前类
    this.getClass().getSuperclass().getName()：父类
    返回：包名+类名

    所有类都是object的子类，但是你用一个类A继承了object，在用一个类B继承A，object类提供的方法B类里也是可以使用的。


--Lambda表达式
  主要作用就是代替匿名内部类的繁琐语法， 它由三部分组成：
  （1） 形参列表。形参列表允许省略形参类型。如果形参列表中只有一个参数，甚至连形参列表的圆括号也可以省略。
  （2） 箭头（→）。必须通过英文中画线和大于符号组成。
  （3）代码块。如果代码块只包含一条语句，Lambda表达式允许省略代码块的花括号，那么那条语句就不要用花括号表示语句结束。Lambda代码块只有一条return语句，甚至可以省略return关键字。Lambda表达式需要返回值，而它的代码块中仅有一套省略了return的语句。Lambda表达式会自动返回这条语句的值。




--关于中间件：

    中间件位于操作系统之上，应用软件之下，而不是操作系统内核中.
    中间件是一种独立的系统软件或服务程序，分布式应用软件借助这种软件在不同的技术之间共享资源。中间件位于客户机/ 服务器的操作系统之上，管理计算机资源和网络通讯。是连接两个独立应用程序或独立系统的软件。相连接的系统，即使它们具有不同的接口，但通过中间件相互之间仍能交换信息。执行中间件的一个关键途径是信息传递。通过中间件，应用程序可以工作于多平台或OS环境。
    （简单来说，中间件并不能提高内核的效率，一般只是负责网络信息的分发处理）
    中间件特点的描述：
                                      1. 中间件应支持标准的协议和接口
                                      2. 中间件可运行于多种硬件和操作系统平台上
                                      3. 跨越网络,硬件，操作系统平台的应用或服务可通过中间件透明交互

    Java里的“中间件”有哪些？分别是什么意思？
    中间件：非底层操作系统软件、非业务应用软件，不是直接给最终用户使用的，不能直接给客户带来价值的软件，统称中间件。常见的有如下几种：服务中间件、集成中间件、数据中间件、消息中间件、安全中间件。
    用Java实现的中间件，统称Java中间件。中间件，可以理解为类库，介于类库和产品之间。
    说简单一点，就是你的程序A和程序B互相通信使用的协议，程序A,B可以由不同语言不同平台构建。但是协议可以保证他们能互相认识互发的东西。
    简单说，中间件有个很大的特点，是脱离于具体设计目标，而具备提供普遍独立功能需求的模块。这使得中间件一定是可替换的。如果一个系统设计中，中间件是不可替换的，不是架构、框架设计有问题，那么就是这个中间件，在 别处可能是个中间件，在这个系统内是引擎。


--Web service顾名思义是基于web的服务，它是一种跨平台，跨语言的服务。

    我们可以这样理解它，比如说我们可以调用互联网上查询天气信息的web服务，把它嵌入到我们的B/S程序中，当用户从我们的网点看到天气信息时，会认为我们为他提供很多的服务，但其实我们什么也没做，只是简单的调用了一下服务器上的一端代码而已。
    Web service 可以将你的服务发布到互联网上让别人去调用，也可以调用别人发布的web service，和使用自己的代码一样。它的通信机制实质就是xml数据交换;它是采用XML传输格式化的数据，它的通信协议是SOAP(简单对象访问协议).


--Java的鲁棒性(Robust,即健壮性)

    ---Java在编译和运行程序时，都要对可能出现的问题进行检查，以消除错误的产生。它提供自动垃圾收集来进行内存管理，防止程序员在管理内存时容易产生 的错误。通过集成的面向对象的例外处理机制，在编译时，Java揭示出可能出现但未被处理的例外，帮助程序员正确地进行选择以防止系统的崩溃。另外， Java在编译时还可捕获类型声明中的许多常见错误，防止动态运行时不匹配问题的出现。

    ---感觉B选项虽然描述也对，但是，不应该把它归结于鲁棒性，B选项主要是体现Java的由于虚拟机，实现了一次编译，到处运行，跨平台性的特点。因此，我选B。
    程序设计语言中，数组元素在内存中是一个接着一个线性存放的，通过第一个元素就能访问随后的元素，这样的数组称之为“真数组”。实现了真数组为Java语言健壮性的特点之一。



--sizeof和strlen的区别：
    一、sizeof
      sizeof(...)是运算符，在头文件中typedef为unsigned int，其值在编译时即计算好了，参数可以是数组、指针、类型、对象、函数等。
      sizeof计算长度包括字符串结束符\0；strlen不包括。
      它的功能是：获得保证能容纳实现所建立的最大对象的字节大小。
      由于在编译时计算，因此sizeof不能用来返回动态分配的内存空间的大小。实际上，用sizeof来返回类型以及静态分配的对象、结构或数组所占的空间，返回值跟对象、结构、数组所存储的内容没有关系。
      
    二、strlen
      strlen(...)是函数，要在运行时才能计算。参数必须是字符型指针（char*）。当数组名作为参数传入时，实际上数组就退化成指针了。
      它的功能是：返回字符串的长度。该字符串可能是自己定义的，也可能是内存中随机的，该函数实际完成的功能是从代表该字符串的第一个地址开始遍历，直到遇到结束符NULL。返回的长度大小不包括NULL。


--关于循环：
    1.增强for循环和iterator遍历的效果是一样的，也就说：增强for循环的内部也就是调用iterator实现的(可以查看编译后的文件)。但是增强for循环有些缺点，例如不能在增强循环里动态的删除集合内容，不能获取下标等。
    2.ArrayList由于使用数组实现，因此下标明确，最好使用普通循环。
    3.而对于 LinkedList 由于获取一个元素，要从头开始向后找，因此建议使用增强for循环，也就是iterator。


--AOP 和 OOP的区别：
    1. 面向方面编程 AOP 偏重业务处理过程的某个步骤或阶段，强调降低模块之间的耦合度，使代码拥有更好的移植性。
    2. 面向对象编程 (oop) 则是对业务分析中抽取的实体进行方法和属性的封装。
    也可以说 AOP 是面向业务中的动词领域， OOP 面向名词领域。
    AOP 的一个很重要的特点是源代码无关性，也就是说如果我们的系统中引用了 AOP 组件，即使我们把该组件去掉，系统代码也应该能够编译通过。要实现这一点，可以使用动态 proxy 模式。


--在Applet中：
      init(): 初始化；
      start() 激活；
      stop(): 当Applet被覆盖时，可用stop()方法停止线程， 典型作用是挂起一个线程；
      destroy() ：终止Applet,释放Applet的所有资源


--一条进程的栈区、堆区、数据区和代码区在内存中的映射
    1>栈区：主要用来存放局部变量, 传递参数, 存放函数的返回地址。.esp 始终指向栈顶, 栈中的数据越多, esp的值越小。
    2>堆区：用于存放动态分配的对象, 当你使用 malloc和new 等进行分配时,所得到的空间就在堆中。动态分配得到的内存区域附带有分配信息, 所以你　 能够 free和delete它们。
    3>数据区：全局，静态和常量是分配在数据区中的，数据区包括bss（未初始化数据区）和初始化数据区。
  注意：
    1)堆向高内存地址生长；
    2)栈向低内存地址生长；
    3)堆和栈相向而生，堆和栈之间有个临界点，称为stkbrk。

  一条进程在内存中的映射：
    假设现在有一个程序，它的函数调用顺序如下：
    main(...) ->; func_1(...) ->; func_2(...) ->; func_3(...)，即：主函数main调用函数func_1; 函数func_1调用函数func_2; 函数func_2调用函数func_3。
    当一个程序被操作系统调入内存运行, 其对应的进程在内存中的映射如下图所示：