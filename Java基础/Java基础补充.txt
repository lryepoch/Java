
·Java内存模型：

    ··Java线程之间的通信由Java内存模型（简称为JMM）控制，JMM决定一个线程对共享变量的写入何时对另一个线程可见。

    从抽象的角度来看，JMM定义了线程和主内存之间的抽象关系：
    线程之间的共享变量存储在主内存（main memory）中，每个线程都有一个私有的本地内存（local memory），本地内存中存储了该线程以读写共享变量的副本。
    本地内存是JMM的一个抽象概念，并不真实存在。它涵盖了缓存，写缓冲区，寄存器以及其他的硬件和编译器优化。volatile变量的写-读可以实现线程之间的通信。

    从内存语义的角度来说，volatile与监视器锁有相同的效果：volatile写和监视器的释放有相同的内存语义；volatile读与监视器的获取有相同的内存语义。

    ··同一个类的对象使用不同的内存段，但静态成员共享相同的内存空间。




·Math类中提供了三个与取整有关的方法：ceil,floor,round,这些方法的作用于它们的英文名称的含义相对应；

    floor: 求小于参数的最大整数。返回double类型-----n. 地板，地面
             例如：Math.floor(-4.2) = -5.0
    -----------------------------------------------------------
    ceil:   求大于参数的最小整数。返回double类型-----vt. 装天花板；
             例如：Math.ceil(5.6) = 6.0
    -----------------------------------------------------------
    round: 对小数进行四舍五入后的结果。返回int类型
             例如：Math.round(-4.6) = -5





·值传递和引用传递：Java语言是一种强类型语言。
                  通俗点就是，在Java中存储的数据都是有类型的，而且必须在编译时就确定其类型。

    Java语言中只有按值传递。
    但是java方法参数中有两种类型：基本数据类型（Primitive types）和对象引用（Object reference）。
    基本数据类型变量存的是数据本身，而引用类型变量存的是保存数据的空间地址。
    基本数据类型是值传递（call by value），引用数据类型是引用传递（call by reference）。
    有人以为当传递Object时是Call by reference。 其实还是传递的这个reference的副本。

    ··结论：1.值传递不可以改变原变量的内容和地址；原因是java方法的形参传递都是传递原变量的副本，在方法中改变的是副本的值，而不适合原变量的。
          2.引用传递不可以改变原变量的地址，但可以改变原变量的内容；原因是当副本的引用改变时，原变量的引用并没有发生变化，当副本改变内容时，由于副本引用指向的是原变量的地址空间，所以，原变量的内容发生变化。

    ··Java中的四类八种基本数据类型：
        第一类：整数类型  byte short int long
              byte的取值范围是-128—127。报出异常： cannot convert from int to byte.
              int的取值范围为： -2^31—2^31-1，即-2147483648——2147483647；
              没有final修饰的变量相加后会被自动提升为int型。

        第二类：浮点型  float double
              long和float，正常定义需要加l和f，但是long和float属于基本类型，会进行转化，所以不会报出异常。
              Float正确复制方式是Float f=1.0f,若不加f会被识别成double型,double无法向float隐式转换.
              float占4个字节为什么比long占8个字节大呢，因为底层的实现方式不同。

        第三类：逻辑型    boolean(它只有两个值可取true false)
              boolean类型不能和任何类型进行转换，会报出类型异常错误。

        第四类：字符型  char
        除此之外都是引用类型，包括类、数组、接口。String是一种常见的引用数据类型，用来表示字符串。

        基本类型和String=""是传值，其他类型都是传引用，当然，也可以认为java只有传值，因为一个是拷贝了栈中的值，一个是拷贝了引用的地址值。

    ··表达式的数据类型自动提升, 关于类型的自动提升，注意下面的规则。
      ①所有的byte,short，char型的值将被提升为int型；
      ②如果有一个操作数是long型，计算结果是long型；
      ③如果有一个操作数是float型，计算结果是float型；
      ④如果有一个操作数是double型，计算结果是double型；




·原码、反码和补码：

      10原码：0000000000000000,0000000000001010；
      -10： 1111111111111111,1111111111110101  变为负数，计算机用补码存储
      -10反码：10000000000000000,0000000000001010
      -10补码：10000000000000000,0000000000001011，等于 -11
      故程序结果-6

      0X是16进制

      1、Java中用补码形式表示
      2、第一位正负位，1表示负，0表示正。
      3、原码：一个数的二进制表示。
                       3的原码00000011   -3的 原码 10000011
      4、反码：负数原码按位取反（符号位不变）。正数原码本身。
                      3的反码00000011   -3的反码11111100
      5、补码：正数是原码本身。负数反码加1。
                       3的补码是00000011  -3的补码是11111101
      -------------------------------------------------------------------------------
      int占4个字节，32位
      byte占1个字节，8位
      所以int强转byte时会截断前24位
      ---------------------------------------------------------------------------
      在内存中表示形式（ 注意java中是以补码表示一个数，所以表示形式是补码，不是原码！ ）：
      int a = 3         00000000  00000000  00000000 00000011 （强转byte时前面24个0被截断）
      byte b = 3      00000011
      int a = -3       11111111  11111111   11111111   11111101 （强转byte时前面24个1被截断）
      byte b = -3     11111101
      ----------------------------------------------------------------------------
      已知负数的补码，求负数：
      补码-1=反码，反码按位取反=该负数绝对值
      已知负数，求负数的补码，2种方法：
      1、负数原码除了符号位，按位取反（不含符号位），加1。
      2、负数绝对值的补码（也就是原码），按位取反（含符号位），加1
      -------------------------------------------------------------------------------
      例子：
      java int 128转为byte，值：
      128为正数，补码为10000000（前面24个0省略），变成byte，只剩下10000000（byte为1个字节），因为开头是1，所以为负数。即1个负数的补码是10000000。反码是01111111，原码是1000000，是128。因为是负数，所以是-128。




·关于null
  null是关键字，NULL不是关键字，java区分大小写。
  null表示没有地址；null可以赋值给引用变量，不能将null赋给基本类型变量。

  ··null是代表不确定的对象

          Java中，null是一个关键字，用来标识一个不确定的对象。因此可以将null赋给引用类型变量，但不可以将null赋给基本类型变量。
           
          比如：int a = null;是错误的。Ojbect o = null是正确的。
           
          Java中，变量的适用都遵循一个原则，先定义，并且初始化后，才可以使用。我们不能int a后，不给a指定值，就去打印a的值。这条对对于引用类型变量也是适用的。
           
          有时候，我们定义一个引用类型变量，在刚开始的时候，无法给出一个确定的值，但是不指定值，程序可能会在try语句块中初始化值。这时候，我们下面使用变量的时候就会报错。这时候，可以先给变量指定一个null值，问题就解决了。例如：
           
                  Connection conn = null;
                  try {
                      conn = DriverManager.getConnection("url", "user", "password");
                  } catch (SQLException e) {
                      e.printStackTrace();
                  }
           
                  String catalog = conn.getCatalog();
           
          如果刚开始的时候不指定conn = null，则最后一句就会报错。

  ··null本身不是对象，也不是Objcet的实例

        null本身虽然能代表一个不确定的对象，但就null本身来说，它不是对象，也不知道什么类型，也不是java.lang.Object的实例。
        可以做一个简单的例子：
         
                //null是对象吗? 属于Object类型吗?
                if (null instanceof java.lang.Object) {
                    System.out.println("null属于java.lang.Object类型");
                } else {
                    System.out.println("null不属于java.lang.Object类型");
                }
         
        结果会输出：null不属于java.lang.Object类型

  ··Java默认给变量赋值

        在定义变量的时候，如果定义后没有给变量赋值，则Java在运行时会自动给变量赋值。赋值原则是整数类型int、byte、short、long的自动赋值为0，带小数点的float、double自动赋值为0.0，boolean的自动赋值为false，其他各供引用类型变量自动赋值为null。
        这个具体可以通过调试来看。

  ··容器类型与null

        List：允许重复元素，可以加入任意多个null。
        Set：不允许重复元素，最多可以加入一个null。
        Map：Map的key最多可以加入一个null，value字段没有限制。
        数组：基本类型数组，定义后，如果不给定初始值，则java运行时会自动给定值。引用类型数组，不给定初始值，则所有的元素值为null。

  ··null的其他作用

    1.判断一个引用类型数据是否null。 用==来判断。
    2.释放内存，让一个非null的引用类型变量指向null。这样这个对象就不再被任何对象应用了。等待JVM垃圾回收机制去回收。

    3.Arrays.asList()
      将一个数组转化为一个List对象，这个方法会返回一个ArrayList类型的对象， 这个ArrayList类并非java.util.ArrayList类，而是Arrays类的静态内部类！用这个对象对列表进行添加删除更新操作，就会报UnsupportedOperationException异常。




·关于static：

    ··java为什么要使用静态变量或静态方法：
      ···Java类中的静态变量在程序运行期间，其内存空间对所有该类的对象实例而言是共享的，有些时候可以认为是全局变量。因此在某些时候为了节省系统内存开销、共   享资  源，可以将类中的一些变量声明为静态变量!
      ···静态还有一个好处,可以代替包,有些时候不想用一个包,来封装一个类做一个公共的数据使用的时候,就可以通过静态属性来完成!
          工具类中的方法基本上都是静态的，直接用类名调用，不用实例化对象，方便。

    ··static变量不能使用this!!!!!!!!!!!，static方法中没有this这么一说。

    ··在类方法中不能有this关键字，直接调用类方法即可。在类方法中可以通过创建实例对象调用类的实例方法。

    静态成员属于整个类，当系统第一次使用该类时，就会为其分配内存空间直到该类被卸载才会进行资源回收！~~
    静态方法中可以直接调用同类中的静态成员，但不能直接调用非静态成员。
    静态初始化块只在类加载时执行，且只会执行一次，同时静态初始化块只能给静态变量赋值，不能初始化普通的成员变量。
    静态内部类可以访问外围类的静态数据，包括私有数据，但不能访问非静态数据；非静态内部类可以直接访问外围类的数据，包括私有数据。



·equals()和hashcode()区别：

      ··都不是final方法，所以可以override。
      ··equals（）判断2个对象是否相等；
      ··hashcode（）计算对象的哈希码；
      ··设计一个类当需要重写equals时，必须重写hashcode方法；

      ··hashcode()介绍：
        ···public native int hashCode();
        ···配合基于散列的集合【hashset、hashmap、hashtable】一起运行；
        ···集合中会有一个table保存存进去的对象的hashcode值。如果table中没有该hashcode值，它就可以直接存进去，不用再比较；如果存在，就用equals方法与新元素比较，相同则不存了，不同则散列到其他地址。
        ···hashcode方法的存在是为了减少equals方法调用次数，从而提高效率。
        ···hashcode返回的并非都是对象的存储地址，只是有所关联；默认情况下，hashcode方法是将对象的存储地址进行映射；

        ···不能根据hashcode值判断2个对象是否相等，但可以根据hashcode值判断2个对象不等；
            equals（）得到的结果是true，则两个对象的hashcode值必定相等；
            equals（）得到的结果是false，则两个对象的hashcode值不一定不等；
            两个对象的hashcode值不等，equals（）得到的结果一定是false；
            两个对象的hashcode值相等，equals（）得到的结果未知；



·equals和==区别：
                 基本类型          引用类型
  ==               值               对象地址
  equals          不能作用          对象内容




·Java编码：
  Java默认使用Unioncode编码，即不论什么语言都是一个字符占两个字节；
  Java的class文件编码为UTF-8，而虚拟机JVM编码为UTF-16；UTF-8编码下，一个中文占3个字节，一个英文占1个字节；
  Java中的char默认采用Unicode编码，所以Java中char占2个字节；

  1(byte)字节=8(bit)位，ResourceBundle能够依据Local的不同，选择性的读取与Local对应后缀的properties文件，以达到国际化的目的。

  ··Java语言中，中文字符所占的字节数取决于字符的编码方式：
    采用ISO8859-1编码方式时，一个中文字符与一个英文字符一样只占1个字节；
    采用GB2312或GBK编码方式时，一个中文字符占2个字节；
    采用UTF-8编码方式时，一个中文字符会占3个字节。

  ··常见字符的ASCII码值如下：
    空格的ASCII码值为32；
    数字0到9的ASCII码值分别为48到57；
    大写字母“A”到“Z”的ASCII码值分别为65到90；
    小写字母“a”到“z”的ASCII码值分别为97到到122。




·AOP 和 OOP的区别：
  ··面向方面编程 AOP 偏重业务处理过程的某个步骤或阶段，强调降低模块之间的耦合度，使代码拥有更好的移植性。AOP是面向业务中的动词领域。
  ··面向对象编程 (oop) 则是对业务分析中抽取的实体进行方法和属性的封装。OOP面向名词领域。

  AOP 的一个很重要的特点是源代码无关性，也就是说如果我们的系统中引用了AOP组件，即使我们把该组件去掉，系统代码也应该能够编译通过。要实现这一点，可以使用动态proxy模式。



·在Applet中：
  init(): 初始化；
  start() 激活；
  stop(): 当Applet被覆盖时，可用stop()方法停止线程， 典型作用是挂起一个线程；
  destroy() ：终止Applet,释放Applet的所有资源



·一条进程的栈区、堆区、数据区和代码区在内存中的映射：
  ··栈区：主要用来存放局部变量, 传递参数, 存放函数的返回地址。.esp 始终指向栈顶, 栈中的数据越多, esp的值越小。

  ··堆区：用于存放动态分配的对象, 当你使用 malloc和new 等进行分配时,所得到的空间就在堆中。动态分配得到的内存区域附带有分配信息, 所以你　 能够 free和delete它们。

  ··数据区：全局，静态和常量是分配在数据区中的，数据区包括bss（未初始化数据区）和初始化数据区。

  ··注意：
    1)堆向高内存地址生长；
    2)栈向低内存地址生长；
    3)堆和栈相向而生，堆和栈之间有个临界点，称为stkbrk。




·final、finally、finalize的区别：

  ··关于final：
          final可以修饰类、方法、变量，分别表示：该类不可继承、该方法不能重写、该变量是常量；
          final修饰的变量，他的类型不可再改变，即便进行了相关的运算也不会改变。这里是指引用变量不能变，引用变量所指向的对象中的内容还是可以改变的。
      被final修饰的变量不会自动转型。
      对于引用类型，被final修饰的变量不可更改其引用地址（当重新new时），但是可以更改其内部属性（通过setter方法）。
          final成员变量必须在声明的时候初始化或者在构造器中初始化，否则就会报编译错误。
          本地变量必须在声明时赋值。
          在匿名类中所有变量都必须是final变量。


  ··关于finally：
    ···finally语句在try或catch中的return语句执行之后返回之前执行，且finally里的修改语句不能影响try或catch中return已经确定的返回值。若finally里也有return语句则覆盖try或catch中的return语句直接返回。

    ···详细执行过程如下：
      如果try有返回值，就把返回值保存到局部变量中；
      执行jsr指令跳到finally语句里执行；
      执行完finally语句后，返回之前保存在局部变量表里的值。
      如果try，finally语句里均有return，忽略try的return，而使用finally的return.

      使用try时，catch和finally必须存在一个。
      finally语句总是要执行的，当finally语句中也有return时，会覆盖try/catch语句块的return，所以一般不要在finally中加return语句。

    ···谁说finally块必须执行？不服来辩：try-catch-finally块中，finally块在以下几种情况将不会执行。
      1.finally块中发生了异常。
      2.程序所在线程死亡。
      3.在前面的代码中用了System.exit（）；
      4.关闭了CPU


  ··finalize方法：
    Java技术允许使用finalize()方法在垃圾收集器将对象从内存中清除出去之前做必要的清理工作。
    这个方法是由垃圾收集器在确定这个对象没有被引用时对这个对象调用的。
    它是在 Object 类中定义的，因此所有的类都继承了它。子类覆盖 finalize() 方法以整理系统资源或者执行其他清理工作。
    finalize()方法是在垃圾收集器删除对象之前对这个对象调用的。
    注意：finalize()不一定被jvm调用，只有当垃圾回收器要清除垃圾时才被调用。

    深入理解java虚拟机中说到：当对象不可达后，仍需要两次标记才会被回收，首先垃圾收集器会先执行对象的finalize方法，但不保证会执行完毕（死循环或执行很缓慢的情况会被强行终止），此为第一次标记。第二次检查时，如果对象仍然不可达，才会执行回收。





·Java装箱和拆箱：
  装箱：值类型转换为引用类型；
  拆箱：引用类型转换为值类型。

  ··Java中基本类型和包装类之间的转换:
    自动装箱：Integer a=b;
    手动装箱：Integer a = new Integer(b);
    自动拆箱：int a=b;
    手动拆箱：int a=b.intValue();

  ··无论如何，Integer与new Integer不会相等。不会经历拆箱过程， 
  ··两个都是非new出来的Integer，如果数在-128到127之间，则是true，否则为false（Java缓存类型）
  java在编译Integer i2 = 128的时候,被翻译成-> Integer i2 = Integer.valueOf(128);而valueOf()函数会对-128到127之间的数进行缓存 
  ··两个都是new出来的,都为false 
  ··int和integer(无论new否)比，都为true，因为会把Integer自动拆箱为int再去比。
    
  ··包装类的“==”运算在不遇到算术运算的情况下不会自动拆箱，包装类的equals()方法不处理数据转型。





·Java中基本类型和字符串之间的转换：
  在程序开发中，我们经常需要在基本数据类型和字符串之间进行转换。

  ··基本类型转换为字符串有三种方法：
    1. 使用包装类的 toString() 方法；String str=Integer.toString(c);
    2. 使用String类的 valueOf() 方法；String str=String.valueOf(c);
    3. 用一个空字符串加上基本类型，得到的就是基本类型数据对应的字符串；String str=c+"";

  ··字符串转换成基本类型有两种方法：
    1. 调用包装类的 parseXxx 静态方法；int c=Integer.parseInt(str);
    2. 调用包装类的 valueOf() 方法转换为基本类型的包装类，会自动拆箱；int c=Integer.valueOf(str);





·Java的缓存机制：

  ··基本型和基本型封装型进行“==”运算符的比较，基本型封装型将会自动拆箱变为基本型后再进行比较，因此Integer(0)会自动拆箱为int类型再进行比较，显然返回true；

          int a = 220;
          Integer b = 220;
          System.out.println(a==b);//true

  ··两个Integer类型进行“==”比较， 如果其值在-128至127  ，那么返回true，否则返回false, 这跟Integer.valueOf()的缓冲对象有关，这里不进行赘述。

          Integer c=3;
          Integer h=3;
          Integer e=321;
          Integer f=321;
          System.out.println(c==h);//true
          System.out.println(e==f);//false

  ··两个Integer型的封装型进行equals()比较，首先equals()会比较类型，如果类型相同，则继续比较值，如果值也相同，返回true。

          Integer a=1;
          Integer b=2;
          Integer c=3;
          System.out.println(c.equals(a+b));//true

  ··基本型封装类型调用equals(参数),但是参数是基本类型，这时候，先会进行自动装箱，基本型转换为其封装类型，再进行3中的比较。  

          int i=1;
          int j = 2;
          Integer c=3;
          System.out.println(c.equals(i+j));//true

  ··Java封装类缓存
          ···基本类型、对象引用都在栈中；而对象本身在堆中。
              == ：基本数据类型比较的是值，对象比较的是地址；
                 基本数据类型与封装类比较会自动拆箱，所以比较的还是值;
                 两个封装类比较的是地址；    
              equals： 比较值；
          
          ···Integer a = 1000  它的内部就是这样的：   Integer i = Integer.valueOf(1000);
              而valueOf方法内部会去取缓存（默认范围 [-128, 127]） ，不会创建新对象。





-----------------------
·jdk里的jre与外面的jre有什么不同？
  ··为什么Sun要让JDK安装两套相同的JRE？
    JDK里的工具有些是用Java所编写，因此要使用JDK所附的工具来开发Java程序，也必须要附一套JRE才行，（如javac.exe、jar.exe等）。
    javac.exe与输入 java -cp c:/jdk/lib/tools.jar com.sun.tools.javac.Main 是一样的，可以认为javac.exe只是一个包装器（Wrapper），目的是简写指令。
    另外一套JRE就是专门用来运行开发好的Java程序用的。

  ··公用jre，就是你觉得没用的那个jre主要是为开发者开发好的java程序提供执行的平台。
    假设jdk与公用jre各安装至C:\Program Files\Java\jdk1.6.0和C:\Program Files\Java\jre1.6.0，你会看到，在jdk1.6.0目录下也有一个jre目录，只是jdk本身所附的jre，是在你开发java程序时做测试之用。

    它与公用jre的主要差别在于jdk本身所附的jre比公用jre多了个server的vm执行选项，通过对比查看C:\Program Files\Java\jdk1.6.0\jre\bin和C:\Program Files\Java\jre1.6.0\bin就可以了解。

    server与client选项的差别在于所使用的vm不同，执行java程序时默认的是client VM。若使用server VM，会花比较长的启动时间及消耗较多的内存，为的是启动程序后可以获得较好的执行性能。



·javac.exe是编译.java文件
  java.exe是执行编译好的.class文件
  javadoc.exe是生成Java说明文档
  jdb.exe是Java调试器
  javaprof.exe是剖析工具




·Java编译后生成字节码文件即.class文件，然后JVM将字节码文件翻译成机器码文件由CPU执行。
  语言跨平台是编译后的文件跨平台，而不是源程序跨平台。Java源代码首先经过编译器生成字节码，即class文件，该class文件与平台无关，而class文件经过解释执行之后翻译成最终的机器码，这是平台相关的。



·能够对对象进行传输的貌似只有ObjectOutputStream和ObjectInputStream这些以Object开头的流对象。
      transient：修饰的变量在对象串化的时侯并不会将所赋值的值保存到传中，串化的对象从磁盘读取出来仍然是null。
      volatile这个修饰符，它是针对多线程情况下出现的。当线程读取它修饰的变量时，都会强迫从主存中重新读取。



·存根类是一个类，它实现了一个接口，它的作用是：
    如果一个接口有很多方法，如果要实现这个接口，就要实现所有的方法。但是一个类从业务来说，可能只需要其中一两个方法。如果直接去实现这个接口，除了实现所需的方法，还要实现其他所有的无关方法。
    而如果通过继承存根类就实现接口，就免去了这种麻烦。就是适配器模式，继承该类则不需要实现一个接口全部方法。



·instance是java的二元运算符，用来判断他左边的对象是否为右面类（接口，抽象类，父类）的实例


·switch语句后的控制表达式只能是short、char、int、long整数类型和枚举类型，不能是float，double和boolean类型。String类型是java7开始支持。 


·for（;;）和while（true）区别：
    ··从寓意上来看，两种写法都是无限循环；
    ··从效率上看，while(true)每次循环要判断循环条件,for(;;)循环没有判断，理论上节省机器指令。
    对比之下，for(；；)指令少，不占用寄存器，而且没有判断跳转，比while(1)好。也就是说两者在在宏观上完全一样的逻辑，但是底层完全不一样，for相对于来说更加简洁明了。
    对于早期的C语言，两种写法性能会不一样。for语句编译器会优化成一条汇编指令，而while判断则编译器会生成好几条汇编指令。

·动态语言的定义：动态编程语言是高级程序设计语言的一个类别，在计算机科学领域已被广泛应用。它是一类在运行时可以改变其结构的语言：
  例如新的函数、对象、甚至代码可以被引进，已有的函数可以被删除或是其他结构上的变化。动态语言目前非常具有活力。众所周知的ECMAScript   
（JavaScript）便是一个动态语言，除此之外如PHP、Ruby、Python等也都属于动态语言，而C、C++等语言则不属于动态语言。

·复制的效率System.arraycopy>clone>Arrays.copyOf>for循环，这个有兴趣自己测试一下就知道了。这里面在System类源码中给出了arraycopy的
方法，是native方法，也就是本地方法，肯定是最快的。而Arrays.copyOf(注意是Arrays类，不是Array)的实现，在源码中是调用System.copyOf的，多
了一个步骤，肯定就不是最快的。前面几个说System.copyOf的不要看，System类底层根本没有这个方法，自己看看源码就全知道了。




·System是java.lang中的类，out为System中的一个静态成员，out是java.io.PrintStream类的对象，而println()是java.io.PrintStream类的方法，
  所以可以调用类.静态成员.println()方法。


·native修饰方法，native修饰的方法简单来说就是：
    一个Java方法调用了一个非Java代码的接口。定义navtive方法时，并不提供实现体，因为其实现体是用非Java语言在外面实现的。native可以和任何修饰符连用，abstract除外。
    因为native暗示这个方法时有实现体的，而abstract却显式指明了这个方法没有实现体。


·构造方法每次都是构造出新的对象，不存在多个线程同时读写同一对象中的属性的问题，所以不需要同步 


·如果父类中的某个方法使用了synchronized关键字，而子类中也覆盖了这个方法，默认情况下子类中的这个方法并不是同步的，必须显示的在子类的这个方法中加上 synchronized关键字才可。当然，也可以在子类中调用父类中相应的方法，这样虽然子类中的方法并不是同步的，但子类调用了父类中的同步方法，也就相当子类方法也同步了。
    详见：http://blog.csdn.net/welcome000yy/article/details/8941644


·一个.java文件中定义多个类：
  注意一下几点：
    ··public权限类只能有一个（也可以一个都没有，但最多只有一个）；
    ··这个.java文件名只能是public权限的类的类名；
    ··倘若这个文件中没有public类，则它的.java文件的名字是随便的一个类名；
    ··当用javac命令生成编译这个.java 文件的时候，则会针对每一个类生成一个.class文件；
    ··如果类中有内部类，会产生类名$内部类名.class。如果有匿名类则会产生类名$1.class.。所以类编译不一定会产生1个class文件。

    ··java采用局部优先的思想。局部变量可以和成员变量相同，使用标识符调用时，优先使用局部变量，使用成员变量就用this调用。



·关于文件：
    A.文件分为文本文件和二进制文件，计算机只认识二进制，所以实际上都是二进制的不同解释方式。文本文件是以不同编码格式显示的字符，例如Ascii、Unicode等，window中文本文件的后缀名有".txt",".log",各种编程语言的源码文件等；二进制文件就是用文本文档打开是看不懂乱码，只要能用文本打开的文件都可以算是文本文件，只是显示的结果不是你想要的，二进制文件只有用特殊的应用才能读懂的文件，例如".png",".bmp"等，计算机中大部分的文件还是二进制文件。

    B.File类是对文件整体或者文件属性操作的类，例如创建文件、删除文件、查看文件是否存在等功能，不能操作文件内容；文件内容是用IO流操作的。

    C.当输入过程中意外到达文件或流的末尾时，抛出EOFException异常,正常情况下读取到文件末尾时，返回一个特殊值表示文件读取完成，例如read()返回-1表示文件读取完成。

    D.不论是文本文件还是二进制文件，在计算机中都是以二进制形式存储的，所以都当做二进制文件读取。



·remove()方法调用的是remove(int index)，而不是remove(Object o)，因此删除的是index索引处的元素；


·java.util.*，只能读取其目录下的类，不能读取其子目录下的类。因为其根目录和子目录下可能有同名类，若都能读取，则会混淆。


·"c:\\my\\1.txt" "c:/my/1.txt" 都是正确的答案；
    可以这么记:"\"这个符号在中英文环境下是不一样的显示；而"/"在中英文环境下是相同的显示。所以前者需要转义。


·多个类时构造函数不一定与公共类同名，因为每个类都可以有构造函数，函数名同所属类。

·JVM是JavaVirtualMachine（Java虚拟机）的缩写，JVM是一种用于计算设备的规范，它是一个虚构出来的计算机，是通过在实际的计算机上仿真模拟各种计算机功能来实    现的。简单来看，虚拟机本质就是一个进程。模拟平台操作的一个进程。



·管道实际上是一种固定大小的缓冲区，管道对于管道两端的进程而言，就是一个文件，但它不是普通的文件，它不属于某种文件系统，而是自立门户单独构成一种文件系统，并且只存在于内存中。
    它类似于通信中半双工信道的进程通信机制，一个管道可以实现双向的数据传输，而同一个时刻只能最多有一个方向的传输，不能两个方向同时进行。管道的容量大小通常为内存上的一页，它的大小并不是受磁盘容量大小的限制。
    当管道满时，进程在写管道会被阻塞；而当管道空时，进程读管道会被阻塞。


·不能在同一个线程当中既写入又读取，这样会造成死锁，因为管道会有阻塞的时候(当管道当中没有数据，进行读操作时，读操作的线程会阻塞，直到有线程来写数据；
  当管道当中满数据，进行写操作时，写操作的线程阻塞，直到有线程来读数据)；


·Java虽然是单继承，但是继承具有传递性.


·getDeclaredMethods()返回Method对象的一个数组，这些对象反映此Class对象表示的类或接口声明的所有方法，包括公共、保护、默认（包）访问和私有方法，但不包括继承的方法。


·不同的服务器之间，哪种通信方式是不可行的（管道）？
管道( pipe )：管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有亲缘关系的进程间使用。进程的亲缘关系通常是指父子进程关系。管道通信类似于通信中半双工信道的进程通信机制，一个管道可以实现双向的数据传输，而同一个时刻只能最多有一个方向的传输，不能两个方向同时进行。


·java.lang包是java语言的核心包，lang是language的缩写。java.lang包定义了一些基本的类型，包括Integer,String之类的，是java程序必备的包，有解释器自动引入，无需手动导入.


·运算符优先级：单目>算数运算符>移位>比较>按位>逻辑>三目>赋值。




·Java一个源程序只能有一个public类存在，且类名与文件名相同。Java程序是从main方法开始执行的，public为类加载器提供入口，然后找到public类中的main方法开始执行。如果存在多个public类，程序将不知道该从哪里执行。注意，内部类可以是public的，因为内部类是作为外部类的成员存在的。


·Collection是java.util下的接口，它是各种集合结构的父接口。Collections是java.util下的类，它包含有各种有关集合操作的静态方法。

·Thread.sleep() 和 Object.wait(),都可以抛出 InterruptedException。这个异常是不能忽略的，因为它是一个检查异常(checked exception)。

·实际上，xsd本身就是XML本身。它的目的是验证另一个XML文档的结构。对于任何XML，xsd并不是必需的，但它确保XML可以用于某些特定目的。XML只包含适当格式和结构的数据。


·Java中没用指针，而是用对象的引用来代替指针。当使用new这个单词时，就是为对象开辟空间。
      如果我们希望完成对象的拷贝，使用一个简单的赋值语句是无法完成的。要达到这一目的可以通过实现Cloneable接口并重写clone方法来完成。
      如果我们希望判断两个对象引用是否一致时，可以覆盖继承自Object类的equals()来实现。

·把类名作为数据类型的原因：
    其实类名不是作为数据类型，只能说将这个类的对象作为返回值。意思就是说，这个方法的返回值不是普通的数据类型，而是一个类对象。这样做可以避免一个方法要返回N多的数据，比如说，你要同一个方法中得到name和age，但是java又不能返回多个值，除了可以使用一个字符串或者字符串数组存放外，我们可以定义一个Student对象，对象中包含name和age属性，这样就可以用这个对象把属性封装起来以及方法，一起返回。


·串又称为字符串，是一种特殊的线性表，其特殊性体现在数据元素是一个字符，也就是说串是一种内容受限的线性表。（栈和队列是操作受限的线性表）。

·所谓树的带权路径长度，就是树中所有的叶结点的权值乘上其到根结点的路径长度。
    哈夫曼树的画法：https://www.nowcoder.com/test/question/done?tid=19976137&qid=1001#summary

·在命令提示框运行一个Java程序：
  1.编辑。写好一个xxx.java文件；
  2.编译。javac xxx.java；生成xxx.class文件；
  3.运行xxx.class。java xxx；不用加后缀；



·System.getProperty()的使用：

    System.getProperty("user.dir")    //用户的当前工作目录，在linux下与pwd(print working directory) 命令相同

    System.getProperty()    //这个系统属性集合总是包含以下键的值

                              键           相关值的描述

                              java.version Java运行时环境版本 
                              java.vendor Java运行时环境供应商 
                              java.vendor.url Java供应商的URL
                              java.home Java安装目录 
                              java.vm.specification.version Java虚拟机规范版本 
                              java.vm.specification.vendor Java虚拟机规范供应商 
                              java.vm.specification.name Java虚拟机规范名称 
                              java.vm.version Java虚拟机实现版本 
                              java.vm.vendor Java虚拟机实现供应商 
                              java.vm.name Java虚拟机实现名称 
                              java.specification.version Java运行时环境规范版本 
                              java.specification.vendor Java运行时环境规范供应商 
                              java.specification.name Java运行时环境规范名称 
                              java.class.version Java类格式版本号 
                              java.class.path Java类路径 
                              java.library.path 加载库时搜索的路径列表 
                              java.io.tmpdir 默认的临时文件路径 
                              java.compiler 要使用的 JIT 编译器的名称 
                              java.ext.dirs 一个或多个扩展目录的路径 
                              os.name 操作系统的名称 
                              os.arch 操作系统的架构 
                              os.version 操作系统的版本 
                              file.separator 文件分隔符（在 UNIX 系统中是“/”） 
                              path.separator 路径分隔符（在 UNIX 系统中是“:”） 
                              line.separator 行分隔符（在 UNIX 系统中是“/n”） 
                              user.name 用户的账户名称 
                              user.home 用户的主目录 
                              user.dir 用户的当前工作目录 
                              
                              系统属性值中的多个路径是用平台的路径分隔符分隔的。 
                              注意，即使安全管理器不允许执行 getProperties 操作，它可能也会选择允许执行 getProperty(String) 操作。




·Math类的常用API：
  ··Math.random()和Random的对比：
    ···Random类专门用于生成一个伪随机数，它有两个构造器：一个构造器使用默认的种子（以当前时间作为种子），另一个构造器需要程序员显式的传入一个long型整数的种子。Random比Math的random（）方法提供了更多的方式来生成各种伪随机数。

      ···Random类中的nextXxxx系列方法生成0－n的随机数；Math.random() 方法生成[0, 范围内的double类型随机数，Math.random() 线程安全，多线程环境能被调用，如无特殊需求，则使用(int)(Math.random()*n)的方式生成随机数即可。

      eg：public int nextInt(int n)        该方法的作用是生成一个随机的int值，该值介于[0,n)的区间，也就是0到n之间的随机int值，包含0而不包含n。

    ··Math.max(a,b);找最大值；
    ··Math.min(a, b);找最小值；


    










