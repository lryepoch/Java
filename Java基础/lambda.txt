
匿名类与lambda表达式：
---------------------
·使用Java 8时，首先做的就是使用lambda表达式替换匿名类；用() -> {}代码块代替了整个匿名类。

·与匿名类概念相比较，Lambda其实就是匿名方法，这是一种把方法作为参数进行传递的编程思想。引入Lambda表达式，会使得代码更加紧凑，而不是各种接口和匿名类到处飞。


·局限性：
	1.可读性差，与啰嗦的但清晰的匿名类代码结构比较起来，Lambda表达式一旦变得比较长，就难以理解
	2.不便于调试，很难在Lambda表达式中增加调试信息，比如日志
	3.版本支持，Lambda表达式在JDK8版本中才开始支持，如果系统使用的是以前的版本，考虑系统的稳定性等原因，而不愿意升级，那么就无法使用。
	4.Lambda比较适合用在简短的业务代码中，并不适合用在复杂的系统中，会加大维护成本。


·可以使用lambda写出如下代码：(只有一个参数的时候，才可以去掉圆括号)
		(params) -> expression
		(params) -> statement
		(params) -> { statements }

		Lambda代码块只有一条return语句，甚至可以省略return关键字。Lambda表达式需要返回值，而它的代码块中仅有一套省略了return的语句。Lambda表达式会自动返回这条语句的值。


·stream：
	··能够对集合中的每个元素进行一系列并行或串行的流水线操作。只需要告诉流你的要求，流便会在背后自行根据要求对元素进行处理。

	··parallelStream并行流就是把内容分成多个数据块，使用不同的线程分别处理每个数据块的流。
		执行效率要比传统的for循环和stream要快的多，那么什么时候要用stream或者parallelStream呢？
		可以从以下三点入手考虑：
								是否需要并行？  
								任务之间是否是独立的？是否会引起任何竞态条件？  
								结果是否取决于任务的调用顺序？

	··使用stream().forEach()就是单纯的串行遍历循环，这跟使用for循环得到的效果一样，只是这种方式可以使代码更精简；
		stream().forEach(System.out::println)遍历输出。

	··使用parallelStream().forEach()，是并行遍历循环，相当于是使用了多线程处理，这样可以在一定程度上提高执行效率.而程序在运行过程中具体会使用多少个线程进行处理,系统会根据运行服务器的资源占用情况自动进行分配。

	··集合list也有forEach()方法，惊了。

	


·@Builder用法：一步步创建一个对象，它对用户屏蔽了里面构建的细节，但却可以精细地控制对象的构造过程。
	eg：Student.builder()
	               .sno( "001" )
	               .sname( "admin" )
	               .sage( 18 )
	               .sphone( "110" )
	               .build();



lambda：
-------------------------
·是什么：
	··箭头函数、匿名函数、闭包
	··轻量级函数式编程
	··‘->’：左侧是操作参数，右侧是操作表达式

	尽可能将代码封装成数据，解决方案：接口以及实现类


·函数式接口(Functional Interface)就是一个有且仅有一个抽象方法，但是可以有多个非抽象方法的接口。函数式接口可以被隐式转换为lambda表达式。
	语义化检测注解：@FunctionalInterface


·函数式接口和lambda表达式的关系：
	··函数式接口：只包含一个操作方法；
	··lambda表达式：只能操作一个方法；
	··java中的lambda表达式，核心就是一个函数式接口的实现；


·高级部分：
	··匿名内部类实现
	··lambda表达式的实现方式（在匿名内部类基础上进化）
	··静态引用：将参数默认传给调用的方法
	··实例方法引用：通过创建对象调用实例方法
	··构造方法引用：绑定函数式接口


·stream api
	··聚合操作：
	··stream的处理流程：
		数据源
		数据转换
		获取结果

	··获取stream对象
		1.从集合或者数组中获取
		2.BufferedReader
		3.……

	··中间操作API：
		操作结果是一个Stream,中间操作可以有一个或者多个连续的中间操作，中间操作只记录操作方式，不做具体执行，直到结束操作发生时，才做数据的最终执行。
		
		中间操作本质：业务逻辑处理。

		中间操作过程：无状态；数据处理时不受前置中间操作的影响；
						map/filter/peek/parallel/sequential/unordered
						map：
						filter：过滤
						peek：
						parallel：
						sequential：
						unordered：

					  有状态：数据处理时受到前置中间操作的影响：
						distinct/sorted/limit/skip
						distinct：去重
						sorted：排序
						limit：限制
						skip：跳转

		map和forEach区别是：map有返回值而且必须return返回一个数组才行，而forEach没有返回值可直接打印结果。

	··结束操作：
		注意：一个stream对象，只能有一个terminal操作，这个操作一旦发生，就会正常处理数据，生成对应的处理结果。

		分类：非短路操作：当前的stream对象必须处理完集合中所有数据，才能得到处理结果。forEach/forEachOrdered/toArray/reduce/collect/min/max/count/iterator
			  短路操作：当前的stream对象在处理过程中，一旦满足某个条件，就可以得到结果。anyMatch/allMatch/noneMatch/findFirst/findAny等




Optional：
----------------------
·背景：解决NullPointerException（NPE）；

·创建 Optional 对象：
	··使用静态方法 empty() 创建一个空的 Optional 对象；
	··使用静态方法 of() 创建一个非空的 Optional 对象；
	··使用静态方法 ofNullable() 创建一个即可空又可非空的 Optional 对象：
	ofNullable()方法内部有一个三元表达式，如果为参数为null，则返回私有常量EMPTY；否则使用 new 关键字创建了一个新的 Optional 对象，不会再抛出 NPE 异常；

·判断值是否存在:
	··isPresent()判断一个Optional对象是否存在，如果存在，该方法返回true，否则返回 false；
	··Java11后还可以通过方法isEmpty()判断与isPresent()相反的结果；

·非空表达式：
	··ifPresent()：使用函数式编程的方式执行一些代码
	··Java9后还可以通过方法ifPresentOrElse(action, emptyAction)执行两种结果，非空时执行action，空时执行emptyAction。


·设置（获取）默认值：
	··orElse()方法用于返回包裹在 Optional对象中的值，如果该值不为null，则返回该值；否则返回默认值。该方法的参数类型和值的类型一致。
	··orElseGet()方法与orElse()方法类似，但参数类型不同。如果Optional对象中的值为 null，则执行参数中的函数。

	在optional为空值的情况下orElse和orElseGet都会执行，当optional不为空时，orElse会执行，orElseGet不会执行。


·获取值：
	··get()方法才是最正宗的获取 Optional 对象值的方法，但很遗憾，该方法是有缺陷的，因为假如 Optional 对象的值为 null，该方法会抛出 NoSuchElementException 异常。这完全与我们使用 Optional 类的初衷相悖。
	··建议 orElseGet() 方法获取 Optional 对象的值。

·过滤值：
	··filter()方法的参数类型为 Predicate（Java 8 新增的一个函数式接口），也就是说可以将一个Lambda表达式传递给该方法作为条件，如果表达式的结果为 false，则返回一个EMPTY的Optional 对象，否则返回过滤后的 Optional 对象。

·转换值：
	··map()方法，该方法可以按照一定的规则将原有Optional对象转换为一个新的Optional对象，原有的Optional对象不会更改。