
·编码：https://www.cnblogs.com/linjiqin/tag/java%20%E5%A4%9A%E7%BA%BF%E7%A8%8B/default.html?page=1


·Java多线程的实现：
	首先：创建并启动线程的过程为：定义线程—》实例化线程—》启动线程。
	
	一 、定义线程：
		1、扩展java.lang.Thread类。 

		2、实现java.lang.Runnable接口。
		··实现步骤：
			定义类实现Runnable接口；
			覆盖接口中的run方法。将线程任务代码定义到run方法中；
			创建Thread类的对象；
			将Runnable接口的子类对象作为参数传递给Thread类的构造函数；
			调用Thread类的start方法开启线程。

		··这种方式的好处： 
			1. 实现Runnable接口避免了单继承的局限性，所以较为常用。 
			2. 实现Runnable接口的方式，更加的符合面向对象，线程分为两部分，一部分线程对象，一部分线程任务。

			继承Thread类：run方法在Thread里。线程对象和线程任务耦合在一起。一旦创建Thread类的子类对象，既是线程对象，又有线程任务。 
			实现Runnable接口：run方法在Runnable里。将线程任务单独分离出来封装成对象（Runnable接口类型），用Runnable来标明线程任务，用Thread来明确线程对象。Runnable接口对线程对象和线程任务进行解耦。


		>创建线程的三种方式的对比
		1. 采用实现 Runnable、Callable 接口的方式创建多线程时，线程类只是实现了 Runnable 接口或 Callable 接口，还可以继承其他类。
		2. 使用继承 Thread 类的方式创建多线程时，编写简单，如果需要访问当前线程，则无需使用 Thread.currentThread() 方法，直接使用 this 即可获得当前线程。


	二、实例化线程：
					 1、如果是扩展java.lang.Thread类的线程，则直接new即可。
	                 2、如果是实现了java.lang.Runnable接口的类，则用Thread的构造方法：

	        Thread(Runnable target) 
	        Thread(Runnable target, String name) 
	        Thread(ThreadGroup group, Runnable target) 
	        Thread(ThreadGroup group, Runnable target, String name) 
	        Thread(ThreadGroup group, Runnable target, String name, long stackSize)

	三、启动线程： 在线程的Thread对象上调用start()方法，而不是run()或者别的方法。

	注：以上方式run方法都是无返回值的，如果需要返回值，需要Callable接口。



·问题：java多线程有几种实现方法，都是什么？同步有几种实现方法，都是什么?         

			1、java实现多线程有 2 种方法：

				（1）继承Thread类；

				（2）实现Runnable接口；

				这两种方法的共同点：

				不论用哪种方法，都必须用Thread（如果是Thead子类就用它本身）产生线程，然后再调用start()方法。

				两种方法的不同点：

						1、继承Thread类有一个缺点就是单继承，而实现Runnable接口则弥补了它的缺点，可以实现多继承

						2、继承Thread类，如果产生Runnable实例对象，就必须产生多个Runnable实例对象，然后再用Thread产生多个线程；而实现Runnable接口，只需要建立一个实现这个类的实例，然后用这一个实例对象产生多个线程。即实现了资源的共享性。
        

			2、同步的实现方面有 2 种，分别是synchronized，wait与notify。

				另解决线程同步与互斥的主要方式是Cas、Synchronized、和Lock。





·Java中线程的可用状态有下面几种：

	1. 新建( new )：新创建了一个线程对象。

	2. 就绪( runnable )：线程准备运行，不一定立马就能开始执行。线程对象创建后,其他线程(比如 main 线程)调用了该对象 的 start ()方法。该状态的线程位于可运行线程池中,等待被线程调度选中,获 取 cpu 的使用权 。

	3. 运行( running )：进程正在执行线程的代码。可运行状态( runnable )的线程获得了 cpu 时间片( timeslice ) ,执行程序代码。

	4. 阻塞( block )：阻塞状态是指线程因为某种原因放弃了 cpu 使用权,也即让出了 cpu timeslice ,暂时停止运行。直到线程进入可运行( runnable )状态,才有机会再次获得 cpu timeslice 转到运行( running )状态。
		阻塞的情况分三种:

			(一). 等待阻塞(Waiting)：线程处于阻塞的状态，等待外部的处理结束。运行( running )的线程执行 o . wait ()方法, JVM 会把该线程放 入等待队列( waitting queue )中。

			(二). 同步阻塞(BlockedonSynchronization)：等待获取锁。运行( running )的线程在获取对象的同步锁时,若该同步锁 被别的线程占用,则 JVM 会把该线程放入锁池( lock pool )中。

			(三). 其他阻塞：睡眠中(Sleeping)：线程被强制睡眠。I/O阻塞(BlockedonI/O)：等待I/O操作完成。
									运行( running )的线程执行 Thread . sleep ( long ms )或 t . join ()方法，或者发出了 I / O 请求时, JVM 会把该线程置为阻塞状态。
									当 sleep ()状态超时、 join ()等待线程终止或者超时、或者 I / O 处理完毕时，线程重新转入就绪( runnable )状态。

	5. 死亡( dead )：线程完成了执行。线程 run ()、 main () 方法执行结束,或者因异常退出了 run ()方法,则该线程结束生命周期。死亡的线程不可再次复生。




·线程的通信方式：wait、notify、notifyAll(同步对象才有)

	在 Java 中，可以通过配合调用 Object 对象的 wait() 方法和 notify()方法或 notifyAll() 方法来实现线程间的通信。
	在线程中调用 wait() 方法，将阻塞等待其他线程的通知（其他线程调用 notify() 方法或 notifyAll() 方法），在线程中调用 notify() 方法或 notifyAll() 方法，将通知其他线程从 wait() 方法处返回。

	Object 是所有类的超类，它有5个方法组成了等待/通知机制的核心：
	notify()、notifyAll()、wait()、wait(long)和wait(long，int)。
	在Java中，所有的类都从Object继承而来，因此，所有的类都拥有这些共有方法可供使用。而且，由于他们都被声明为 final，因此在子类中不能覆写任何一个方法。


	>意思：
	wait()的意思是，让占用了这个同步对象的线程，临时释放当前的占用，并且等待。 所以调用wait是有前提条件的，一定是在synchronized块里，否则就会出错。
	notify()的意思是，通知一个等待在这个同步对象上的线程，你可以苏醒过来了，有机会重新占用当前对象了。
	notifyAll()的意思是，通知所有的等待在这个同步对象上的线程，你们可以苏醒过来了，有机会重新占用当前对象了。


	>深入理解：
	如果线程调用了对象的 wait()方法，那么线程便会处于该对象的等待池中，等待池中的线程不会去竞争该对象的锁。
	当有线程调用了对象的 notifyAll()方法（唤醒所有 wait 线程）或 notify()方法（只随机唤醒一个 wait 线程），被唤醒的的线程便会进入该对象的锁池中，锁池中的线程会去竞争该对象锁。

	优先级高的线程竞争到对象锁的概率大，假若某线程没有竞争到该对象锁，它还会留在锁池中，唯有线程再次调用 wait()方法，它才会重新回到等待池中。而竞争到对象锁的线程则继续往下执行，直到执行完了 synchronized 代码块，它会释放掉该对象锁，这时锁池中的线程会继续竞争该对象锁。


	>补充：
	wait()与notify/notifyAll() 的执行过程：
	由于 wait() 与  notify/notifyAll() 是放在同步代码块中的，因此线程在执行它们时，肯定是进入了临界区中的，即该线程肯定是获得了锁的。

	当线程执行wait()时，会把当前的锁释放，然后让出CPU，进入等待状态。

	当执行notify/notifyAll方法时，会唤醒一个处于等待该 对象锁 的线程，然后继续往下执行，直到执行完退出对象锁锁住的区域（synchronized修饰的代码块）后再释放锁。

	从这里可以看出，notify/notifyAll()执行后，并不立即释放锁，而是要等到执行完临界区中代码后，再释放。故，在实际编程中，我们应该尽量在线程调用notify/notifyAll()后，立即退出临界区。即不要在notify/notifyAll()后面再写一些耗时的代码。wait()与notify/notifyAll()都是放在同步代码块中才能够执行的。如果在执行wait() 与  notify/notifyAll()之前没有获得相应的对象锁，就会抛出：java.lang.IllegalMonitorStateException异常。




·sleep和wait的区别有：
	   sleep：Thread类的方法；不释放锁；任意位置使用；需要捕获异常；
	   wait：Object类的方法；释放锁；只能在同步方法或者同步代码块中使用；不需要捕获异常；





·CAS与ABA问题：

	CAS：乐观锁的一种实现，是一种轻量级锁，Juc中很多工具类的实现就是基于Cas。
			  Cas操作是线程在读取数据时不进行加锁，在准备写回数据时，比较原值是否修改，若未被其他线程修改则写回，若已被修改，则重新执行读取流程。这是一种乐观策略，认为并发操作并不总会发生。
			  比较并写回的操作是通过操作系统原语实现的，保证执行过程中不会被中断。

	ABA问题：Cas容易出现Aba问题，如果线程T1读取值A之后，发生过两次写入，先由线程T2写回了b，又由T3写回了A，此时T1在写回比较时，值还是A，就无法判断是否发生过修改。
					Aba问题不一定会影响结果，但还是需要防范，解决的办法可以增加额外的标志位或者时间戳。Juc工具包中提供了这样的类。




·synchronized详解：
	底层实现：
	进入时，执行 monitorenter，将计数器 +1，释放锁 monitorexit 时，计数器-1；当一个线程判断到计数器为 0 时，则当前锁空闲，可以占用；反之，当前线程进入等待状态。

	含义：（monitor 机制）
	Synchronized 是在（获取）加锁，加对象锁，对象锁是一种重量锁（monitor），synchronized的锁机制会根据线程竞争情况在运行时会有偏向锁（单一线程）、轻量锁（多个线程访问 synchronized 区域）、自旋锁、对象锁（重量锁，多个线程存在竞争的情况）等。

	Synchronized获取锁的方式，Jvm使用了锁升级的优化方式，就是先使用偏向锁优先同一线程再次获取锁。如果失败，就升级为Cas轻量级锁。如果再失败会短暂自旋，防止线程被系统挂起。最后如果以上都失败就是升级为重量级锁。

	该关键字是一个几种锁的封装。




·ThreadLocal详解：同一个线程下，变量跨类跨方法调用！！！！！！
	
	>背景：
		多线程下，有时候遇到的问题：
			1、一个线程操作读取到另外一个线程的数据。
			2、在同一个线程之内，多个方法读取到的同一个数据不一样。

	>ThreadLocal设计的初衷：
		··ThreadLocal类在多线程环境下访问时，能保证各个线程里的变量相对独立于其他线程内的变量。ThreadLocal实例通常来说都是private static类型的，用于关联线程和线程的上下文。 

		··ThreadLocal的作用是提供线程内的局部变量，这种变量在线程的生命周期内起作用，减少同一个线程内多个函数或者组件之间一些公共变量的传递的复杂度。 

		··Java中的ThreadLocal类允许我们创建只能被同一个线程读写的变量。因此，如果一段代码含有一个ThreadLocal变量的引用，即使两个线程同时执行这段代码，它们也无法访问到对方的ThreadLocal变量。

	>ThreadLocal的工作原理：
		··ThreadLocal类用于创建一个线程本地变量；线程内共享，线程间互斥；Threadlocal使用弱引用的ThreadLocalMap保存不同的Threadlocal变量。

		··Map.Entry的作用。Map.Entry是为了更方便的输出map键值对。一般情况下，要输出Map中的key和value是先得到key的集合keySet()，然后再迭代每个key得到每个value。values()方法是获取集合中的所有值，不包含键，没有对应关系。而Entry可以一次性获得这两个值。

		··ThreadLocal是如何为每个线程创建变量的副本的？
			首先，在每个线程Thread内部有一个（ThreadLocal.ThreadLocalMap类型）的成员变量threadLocals（相当于entrySet），这个threadLocals就是用来存储实际的变量副本的，键值为当前ThreadLocal变量，value为变量副本（即T类型的变量）。通过ThreadLocal的get()方法可以获取该线程变量的本地副本，在get()之前要先set()，否则就要重写initialValue()。

			初始时，在Thread里面，threadLocals为空，当通过ThreadLocal变量调用get()方法或者set()方法，就会对Thread类中的threadLocals进行初始化，并且以当前ThreadLocal变量为键值，以ThreadLocal要保存的副本变量为value，存到threadLocals。然后在当前线程里面，如果要使用副本变量，就可以通过get方法在threadLocals里面查找。

	>ThreadLocal的作用：
		··ThreadLocal是用来维护本地线程的变量，并不能解决线程间共享变量的并发问题。
			ThreadLocal只是一个工具，一个往各个线程的ThreadLocal.ThreadLocalMap中table的某一位置set一个值的工具而已。
			ThreadLocal是各线程将值存入该线程的map中，以ThreadLocal自身作为key，需要用时获得线的是该程之前存入的值。如果存入的是共享变量，那取出的也是共享变量，并发问题还是存在的。

		··ThreadLocal和多线程并发没有什么关系！
			ThreadLocal模式是为了解决单线程内的跨类跨方法调用的。ThreadLocal不是用来解决对象共享访问问题的，而主要是提供了保持对象的方法和避免参数传递的方便的对象访问方式。一般情况下，通过ThreadLocal.set() 到线程中的对象是该线程自己使用的对象，其他线程是不需要访问的，也访问不到的。各个线程中访问的是不同的对象。
			同步与ThreadLocal是解决多线程中数据访问问题的两种思路，前者是数据共享的思路，后者是数据隔离的思路。

	>ThreadLocal的使用场景：
		··使用ThreadLocal的场景最好满足两个条件，一是该对象不需要在多线程之间共享；二是该对象需要在线程内被传递。

        ··数据库连接：在多线程中，如果使用懒汉式的单例模式创建Connection对象，由于该对象是共享的，那么必须要使用同步方法保证线程安全。
				        这样当一个线程在连接数据库时，那么另外一个线程只能等待，这样就造成性能降低。
				        如果改为哪里要连接数据库，就进行连接，那么就会频繁的对数据库进行连接，性能还是不高。
				        这时使用ThreadLocal就可以既可以保证线程安全又可以让性能不会太低。但是ThreadLocal的缺点是占用了较多的空间。

	        注意：数据库连接时之所以使用threadlocal是因为数据库连接池，连接池里面很多connection，导致同一个事务（可理解为涉及多个DAO）每次获取的connection不是同一个。
	        		  所以为了解决这个问题，就用threadlocal，把当前的connection放到当前线程里，如果是这个线程就获取得到对应的connection。 

	    ··何时以及如何使用ThreadLocal变量？一种可能的（也是常见的）用法是当有一些线程不安全的对象，但您希望避免同步访问该对象。这时可以为每个线程提供它自己的对象实例。

	>参考：
		1、ThreadLocal的类声明：public class ThreadLocal<T>		从中可以看出ThreadLocal并没有继承自Thread，也没有实现Runnable接口。
			ThreadLocal没有实现任何接口。
			ThreadLocal并不是一个Thread，而是Thread的局部变量。

		2、ThreadLocal类为每一个线程都维护了自己独有的变量拷贝。所以ThreadLocal作用并不在于多线程间的数据共享，而是数据的独立；由于每个线程在访问该变量时，读取和修改的，都是自己独有的那一份变量拷贝，不会被其他线程访问，变量被彻底封闭在每个访问的线程中。




·ThreadLocal 与 Synchronized区别

		a、相同：ThreadLocal和线程同步机制都是为了解决多线程中相同变量的访问冲突问题。
			 不同：Synchronized同步机制采用了“以时间换空间”的方式，仅提供一份变量，让不同的线程排队访问；
						而ThreadLocal采用了“以空间换时间”的方式，每一个线程都提供了一份变量副本，因此可以同时访问而互不影响。

		b、所谓ThreadLocal，简单一点想，就是一个全局的Map，Map的key是线程对象，value是你要保存的对象进入某个线程后，就可以从map中取得之前存储的相应线程关联的对象。当然，ThreadLocal并不是一个Map，但用Map			来理解是没有问题的。

		c、ThreadLocal与共享没有关系。ThreadLocal 是多线程中的免锁解决方案之一。 就是每个线程对于ThreadLocal 都有一个备份  ，这篇内存分配在堆上。

				第二点  在两个线程同时执行getConnection()  的时候  会生成两个connection变量哦。

				第三点 ThreadLocal  是多线程下的无锁定解决方案   主要用于保存 线程 的特征，比如你给线程重命名啦之类的 。核心是 每个线程中都有一个 ThreadLocal的副本而普通的则是共享的。

		总结：一个是锁机制进行时间换空间，一个是存储拷贝进行空间换时间。

小结：ThreadLocal是解决线程安全问题一个很好的思路，它通过为每个线程提供一个独立的变量副本解决了变量并发访问的冲突问题。

			在很多情况下，ThreadLocal比直接使用synchronized同步机制解决线程安全问题更简单，更方便，且结果程序拥有更高的并发性。

			Synchronized用于线程间的数据共享，而ThreadLocal则用于线程间的数据隔离。




·Lock解析：
	Aqs，也就是队列同步器，这是实现Lock的基础。
	Aqs有一个State标记位，值为1时表示有线程占用，其他线程需要进入到同步队列等待。同步队列是一个双向链表。
	当获得锁的线程需要等待某个条件时，会进入Condition的等待队列，等待队列可以有多个。
	当Condition条件满足时，线程会从等待队列重新进入到同步队列进行获取锁的竞争。

	Reentrantlock就是基于Aqs实现的，Reentrantlock内部有公平锁和非公平锁两种实现，差别就在于新来的线程会不会比已经在同步队列中的等待线程更早获得锁。

	和Reentrantlock实现方式类似，Semaphore也是基于aqs，差别在于Reentrantlock是独占锁，Semaphore是共享锁。





·Lock与synchronized区别：
		1)本质：Lock是一个接口，而synchronized是Java中的关键字，synchronized是内置的语言实现，Lock是代码层面的实现。

		2) 获取锁：Lock可以选择性的获取锁，如果一段时间获取不到，可以放弃。synchronized不行，会一根筋一直获取下去。 借助Lock的这个特性，就能够规避死锁，synchronized必须通过谨慎和良好的设计，才能减少死锁的发生。

		3) 释放锁：synchronized在发生异常和同步块结束的时候，会自动释放锁。而Lock必须手动释放， 所以如果忘记了释放锁，一样会造成死锁。

		4) 线程交互：使用synchronized方式进行线程交互，用到的是同步对象的wait,notify和notifyAll方法；Lock也提供了类似的解决办法，首先通用过lock对象得到一个Condition对象，然后分别调这个Condition对象的：await, signal,signalAll 方法。




·volatile关键字：

	  出于运行速率的考虑，java编译器会把经常访问的变量放到缓存（严格讲应该是工作内存）中，读取变量则从缓存中读。但是在多线程编程中,内存中的值和缓
	  存中的值可能会出现不一致。volatile用于限定变量只能从内存中读取，保证对所有线程而言，值都是一致的。
	  
	  Java中的volatile关键字的功能:
	  volatile是java中的一个类型修饰符。它是被设计用来修饰被不同线程访问和修改的变量。如果不加入volatile，基本上会导致这样的结果：要么无法编写多线程程序，要么编译器失去大量优化的机会。
	  volatile只能保证变量的安全，不能保证线程的安全，他保证变量对于其他线程的可见性。

	  1，可见性，不保证原子性，也就不能保证线程安全：
	      可见性指的是在一个线程中对该变量的修改会马上由工作内存（Work Memory）写回主内存（Main Memory），所以会马上反应在其它线程的读取操作中。顺便
	      一提，工作内存和主内存可以近似理解为实际电脑中的高速缓存和主存，工作内存是线程独享的，主存是线程共享的。

	  2，禁止指令重排序优化，解析：关于指令重排序的问题，可以查阅 DCL 双检锁失效相关资料。
	      禁止指令重排序优化。大家知道我们写的代码（尤其是多线程代码），由于编译器优化，在实际执行的时候可能与我们编写的顺序不同。编译器只保证程序执行结果
	      与源代码相同，却不保证实际指令的顺序与源代码相同。这在单线程看起来没什么问题，然而一旦引入多线程，这种乱序就可能导致严重问题。volatile关键字就可以从语义上解决这个问题。

	      注意，禁止指令重排优化这条语义直到jdk1.5以后才能正确工作。此前的JDK中即使将变量声明为volatile也无法完全避免重排序所导致的问题。所以，在jdk1.5版本
	      前，双重检查锁形式的单例模式是无法保证线程安全的。因此，下面的单例模式的代码，在JDK1.5之前是不能保证线程安全的。






·关于synchronized和volatile之间的比较：
		1）volatile是轻量级的实现，所以性能比synchronized要好。
			volatile只能修饰变量，synchronized可以修饰方法以及代码块。随着jdk新版本的发布，synchronized在执行效率上得到很大的提升，开发中使用synchronized的比率还是比较大的。

		2）多线程访问volatile不会阻塞，synchronized则会。

		3）volatile保证数据可见性，不能保证原子性；synchronized可保证原子性，也可间接保证可见性，因为他会将私有内存和公有内存中的数据做同步，synchronized解决的是多线程之间访问资源的同步性。

		总结：线程安全包含原子性和可见性2个方面，Java的同步机制都是围绕这两个方面来确保线程安全的。




·Atomic 关键字：
答：可以使基本数据类型以原子的方式实现自增自减等操作。
		
		参考我的博客：concurrent.atomic 包下的类 AtomicInteger 的使用。

		AtomicInteger：JDK6以后，新增加了一个包java.util.concurrent.atomic，里面有各种原子类，比如AtomicInteger。而AtomicInteger提供了各种自增，自减等方法，这些方法都是原子性的。 换句话说，自增方法 incrementAndGet是线程安全的，同一个时间，只有一个线程可以调用这个方法。





·同步方法和同步代码块的区别是什么？

	同步方法默认用this或者当前类class对象作为锁；
	同步代码块可以选择以什么来加锁，比同步方法要更细颗粒度，我们可以选择只同步会发生同步问题的部分代码而不是整个方法；
	同步方法使用关键字 synchronized修饰方法，而同步代码块主要是修饰需要进行同步的代码，用   synchronized（object）{代码内容}进行修饰；




·线程为什么调用start()而不是直接调用run()？

	1、run()方法只是一个类中的普通方法，直接执行和普通的方法没有设么两样;
	2、start()方法则不同，它首先做了创建线程等一系列工作，然后调用行的run()方法。





·线程池：
	概念：线程池的模式很像生产者消费者模式，消费的对象是一个一个的能够运行的任务。通过复用线程，避免线程频繁创建和销毁。
				其实就是一个容纳多个线程的容器，其中的线程可以反复使用，省去了频繁创建线程对象的操作，无需因反复创建线程而消耗过多资源。

	··线程池都是通过线程池工厂创建，调用线程池中的方法获取线程，再通过线程去执行任务方法。

	··两种使用线程池创建线程的方法：
						···使用Runnable接口创建线程池					execute()：

						···使用Callable接口创建线程池						submit()：会返回一个future对象；

							区别就是Submit可以返回一个Future对象，通过Future对象可以了解任务执行情况，可以取消任务的执行，还可获取执行结果或执行异常。Submit最终也是通过Execute执行的。

								····Future 接口：用来记录封装线程任务执行完毕后产生的结果。
	                     									线程池创建与使用：get() 获取 Future对象中封装的数据结果
					 
	java.util.concurrent.ThreadPoolExecutor 类就是一个线程池类。客户端调用 ThreadPoolExecutor.submit(Runnable task) 提交任务，线程池内部维护的工作者线程的数量就是该线程池的线程池大小，有 3 种形态：

			当前线程池大小 ：表示线程池中实际工作者线程的数量；
			最大线程池大小 （maxinumPoolSize）：表示线程池中允许存在的工作者线程的数量上限；
			核心线程大小 （corePoolSize ）：表示一个不大于最大线程池大小的工作者线程数量上限。

	如果运行的线程少于 corePoolSize，则 Executor 始终首选添加新的线程，而不进行排队；
	如果运行的线程等于或者多于 corePoolSize，则 Executor 始终首选将请求加入队列，而不是添加新线程；
	如果无法将请求加入队列，即队列已经满了，则创建新的线程，除非创建此线程超出 maxinumPoolSize， 在这种情况下，任务将被拒绝。


	>线程池提交任务时的执行顺序如下：

				向线程池提交任务时，会首先判断线程池中的线程数是否大于设置的核心线程数，如果不大于，就创建一个核心线程来执行任务。

				如果大于核心线程数，就会判断缓冲队列是否满了，如果没有满，则放入队列，等待线程空闲时执行任务。
				如果队列已经满了，则判断是否达到了线程池设置的最大线程数，如果没有达到，就创建新线程来执行任务。
				如果已经达到了最大线程数，则执行指定的拒绝策略。这里需要注意队列的判断与最大线程数判断的顺序，不要搞反。






·Thread.yield()方法作用是：暂停当前正在执行的线程对象，并执行其他线程。

	yield()应该做的是让当前运行线程回到可运行状态，以允许具有相同优先级的其他线程获得运行机会。因此，使用yield()的目的是让相同优先级的线程之间能适当的轮转执行。但是，实际中无法保证yield()达到让步目的，因为让步的线程还有可能被线程调度程序再次选中。

	结论：yield()从未导致线程转到等待/睡眠/阻塞状态。在大多数情况下，yield()将导致线程从运行状态转到可运行状态，但有可能没有效果。




·前台线程与后台线程：

		··后台线程：指为其他线程提供服务的线程，也称为守护线程。JVM的垃圾回收线程就是一个后台线程。 

			前台线程：是指接受后台线程服务的线程，其实前台后台线程是联系在一起，就像傀儡和幕后操纵者一样的关系。傀儡是前台线程、幕后操纵者是后台线程。由前台线程创建的线程默认也是前台线程。可以通过isDaemon()和setDaemon()方法来判断和设置一个线程是否为后台线程。

		··使用Thread建立的线程默认情况下是前台线程，在进程中，只要有一个前台线程未退出，进程就不会终止。主线程就是一个前台线程。而后台线程不管线程是否结束，只要所有的前台线程都退出（包括正常退出和异	 常退出）后，进程就会自动终止。





问题：

·线程交互的需求，考虑如下：
		this.wait()表示让占有this的线程等待，并临时释放占有。
		this.notify（）通知那些等待this的线程，可以苏醒。

		留意wait()和notify() 这两个方法是什么对象上的？所有的Object都可以被用来作为同步对象，所以准确的讲，wait和notify是同步对象上的方法。

		public synchronized void hurt() {
		  		。。。
		  		this.wait();
		  		。。。
		}
		 
		public synchronized void recover() {
			   。。。
			   this.notify();
			   。。。
		}






·java concurrent包下的4个类，选出差别最大的一个：C
		A、Semaphore：类，控制某个资源可被同时访问的个数;
		B、ReentrantLock：类，具有与使用synchronized方法和语句所访问的隐式监视器锁相同的一些基本行为和语义，但功能更强大；
		C、 Future：接口，表示异步计算的结果；
		D、 CountDownLatch： 类，可以用来在一个线程中等待多个线程完成任务的类。	



·协程是一种用户态的轻量级线程，协程的调度完全由用户控制。协程拥有自己的寄存器上下文和栈。协程调度切换时，将寄存器上下文和栈保存到其他地方，在切回来的时候，恢复先前保存的寄存器上下文和栈，直接操作栈则基本没有内核切换的开销，可以不加锁的访问全局变量，所以上下文的切换非常快。



·线程调度分为协同式调度和抢占式调度，Java使用的是抢占式调度，也就是每个线程将由操作系统来分配执行时间，线程的切换不由线程本身来决定（协同式调度）。这就是平台独立的原因。





·如何提高一个系统的并发性？

	1.物理层增加网络宽带，域名解析分发多台服务器

	2..操作系统层，多线程多核编程，epoll，事件驱动框架，异步消息机制

	3.业务层，优化数据库查询redis缓存



