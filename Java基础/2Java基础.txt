
·javac.exe是编译.java文件
  java.exe是执行编译好的.class文件
  javadoc.exe是生成Java说明文档
  jdb.exe是Java调试器
  javaprof.exe是剖析工具

·关于序列化：
  ··在序列化的时候，被transient或者static修饰的属性，不可以序列化。
  ··一个类可以被序列化，那么它的子类也可以被序列化。
  ··序列化可以实现深复制，而Object中的clone实现的就只是浅复制。
  ··反射和序列化同样会调用构造方法。不过这个构造方法不能有参数。

·Java编译后生成字节码文件即.class文件，然后JVM将字节码文件翻译成机器码文件由CPU执行。
  语言跨平台是编译后的文件跨平台，而不是源程序跨平台。Java源代码首先经过编译器生成字节码，即class文件，该class文件与平台无关，而class文件经过解释执行之后翻译成最终的机器码，这是平台相关的。

·能够对对象进行传输的貌似只有ObjectOutputStream和ObjectInputStream这些以Object开头的流对象。
      transient：修饰的变量在对象串化的时侯并不会将所赋值的值保存到传中，串化的对象从磁盘读取出来仍然是null。
      volatile这个修饰符，它是针对多线程情况下出现的。当线程读取它修饰的变量时，都会强迫从主存中重新读取。


·存根类是一个类，它实现了一个接口，它的作用是：
    如果一个接口有很多方法，如果要实现这个接口，就要实现所有的方法。但是一个类从业务来说，可能只需要其中一两个方法。如果直接去实现这个接口，除了实现所需的方法，还要实现其他所有的无关方法。
    而如果通过继承存根类就实现接口，就免去了这种麻烦。就是适配器模式，继承该类则不需要实现一个接口全部方法。

·instance是java的二元运算符，用来判断他左边的对象是否为右面类（接口，抽象类，父类）的实例

·switch语句后的控制表达式只能是short、char、int、long整数类型和枚举类型，不能是float，double和boolean类型。String类型是java7开始支持。 

·for（；；）和while（true）区别：
    ··从寓意上来看，两种写法都是无限循环；
    ··从效率上看，while(true)每次循环要判断循环条件,for(;;)循环没有判断，理论上节省机器指令。
    对比之下，for(；；)指令少，不占用寄存器，而且没有判断跳转，比while(1)好。也就是说两者在在宏观上完全一样的逻辑，但是底层完全不一样，for相对于来说更加简洁明了。
    对于早期的C语言，两种写法性能会不一样。for语句编译器会优化成一条汇编指令，而while判断则编译器会生成好几条汇编指令。

·动态语言的定义：动态编程语言是高级程序设计语言的一个类别，在计算机科学领域已被广泛应用。它是一类在运行时可以改变其结构的语言：
  例如新的函数、对象、甚至代码可以被引进，已有的函数可以被删除或是其他结构上的变化。动态语言目前非常具有活力。众所周知的ECMAScript   
（JavaScript）便是一个动态语言，除此之外如PHP、Ruby、Python等也都属于动态语言，而C、C++等语言则不属于动态语言。

·复制的效率System.arraycopy>clone>Arrays.copyOf>for循环，这个有兴趣自己测试一下就知道了。这里面在System类源码中给出了arraycopy的
方法，是native方法，也就是本地方法，肯定是最快的。而Arrays.copyOf(注意是Arrays类，不是Array)的实现，在源码中是调用System.copyOf的，多
了一个步骤，肯定就不是最快的。前面几个说System.copyOf的不要看，System类底层根本没有这个方法，自己看看源码就全知道了。




·System是java.lang中的类，out为System中的一个静态成员，out是java.io.PrintStream类的对象，而println()是java.io.PrintStream类的方法，
  所以可以调用类.静态成员.println()方法。


·native修饰方法，native修饰的方法简单来说就是：
    一个Java方法调用了一个非Java代码的接口。定义navtive方法时，并不提供实现体，因为其实现体是用非Java语言在外面实现的。native可以和任何修饰符连用，abstract除外。
    因为native暗示这个方法时有实现体的，而abstract却显式指明了这个方法没有实现体。


·构造方法每次都是构造出新的对象，不存在多个线程同时读写同一对象中的属性的问题，所以不需要同步 


·如果父类中的某个方法使用了synchronized关键字，而子类中也覆盖了这个方法，默认情况下子类中的这个方法并不是同步的，必须显示的在子类的这个方法中加上 synchronized关键字才可。当然，也可以在子类中调用父类中相应的方法，这样虽然子类中的方法并不是同步的，但子类调用了父类中的同步方法，也就相当子类方法也同步了。
    详见：http://blog.csdn.net/welcome000yy/article/details/8941644


·一个.java文件中定义多个类：
  注意一下几点：
    ··public权限类只能有一个（也可以一个都没有，但最多只有一个）；
    ··这个.java文件名只能是public权限的类的类名；
    ··倘若这个文件中没有public类，则它的.java文件的名字是随便的一个类名；
    ··当用javac命令生成编译这个.java 文件的时候，则会针对每一个类生成一个.class文件；
    ··如果类中有内部类，会产生类名$内部类名.class。如果有匿名类则会产生类名$1.class.。所以类编译不一定会产生1个class文件。

    ··java采用局部优先的思想。局部变量可以和成员变量相同，使用标识符调用时，优先使用局部变量，使用成员变量就用this调用。



·关于文件：
    A.文件分为文本文件和二进制文件，计算机只认识二进制，所以实际上都是二进制的不同解释方式。文本文件是以不同编码格式显示的字符，例如Ascii、Unicode等，window中文本文件的后缀名有".txt",".log",各种编程语言的源码文件等；二进制文件就是用文本文档打开是看不懂乱码，只要能用文本打开的文件都可以算是文本文件，只是显示的结果不是你想要的，二进制文件只有用特殊的应用才能读懂的文件，例如".png",".bmp"等，计算机中大部分的文件还是二进制文件。

    B.File类是对文件整体或者文件属性操作的类，例如创建文件、删除文件、查看文件是否存在等功能，不能操作文件内容；文件内容是用IO流操作的。

    C.当输入过程中意外到达文件或流的末尾时，抛出EOFException异常,正常情况下读取到文件末尾时，返回一个特殊值表示文件读取完成，例如read()返回-1表示文件读取完成。

    D.不论是文本文件还是二进制文件，在计算机中都是以二进制形式存储的，所以都当做二进制文件读取。



·remove()方法调用的是remove(int index)，而不是remove(Object o)，因此删除的是index索引处的元素；


·java.util.*，只能读取其目录下的类，不能读取其子目录下的类。因为其根目录和子目录下可能有同名类，若都能读取，则会混淆。


·"c:\\my\\1.txt" "c:/my/1.txt" 都是正确的答案；
    可以这么记:"\"这个符号在中英文环境下是不一样的显示；而"/"在中英文环境下是相同的显示。所以前者需要转义。


·多个类时构造函数不一定与公共类同名，因为每个类都可以有构造函数，函数名同所属类。

·JVM是JavaVirtualMachine（Java虚拟机）的缩写，JVM是一种用于计算设备的规范，它是一个虚构出来的计算机，是通过在实际的计算机上仿真模拟各种计算机功能来实    现的。简单来看，虚拟机本质就是一个进程。模拟平台操作的一个进程。



·管道实际上是一种固定大小的缓冲区，管道对于管道两端的进程而言，就是一个文件，但它不是普通的文件，它不属于某种文件系统，而是自立门户单独构成一种文件系统，并且只存在于内存中。
    它类似于通信中半双工信道的进程通信机制，一个管道可以实现双向的数据传输，而同一个时刻只能最多有一个方向的传输，不能两个方向同时进行。管道的容量大小通常为内存上的一页，它的大小并不是受磁盘容量大小的限制。
    当管道满时，进程在写管道会被阻塞；而当管道空时，进程读管道会被阻塞。


·不能在同一个线程当中既写入又读取，这样会造成死锁，因为管道会有阻塞的时候(当管道当中没有数据，进行读操作时，读操作的线程会阻塞，直到有线程来写数据；
  当管道当中满数据，进行写操作时，写操作的线程阻塞，直到有线程来读数据)；


·Java虽然是单继承，但是继承具有传递性.


·getDeclaredMethods()返回Method对象的一个数组，这些对象反映此Class对象表示的类或接口声明的所有方法，包括公共、保护、默认（包）访问和私有方法，但不包括继承的方法。


·不同的服务器之间，哪种通信方式是不可行的（管道）？
管道( pipe )：管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有亲缘关系的进程间使用。进程的亲缘关系通常是指父子进程关系。管道通信类似于通信中半双工信道的进程通信机制，一个管道可以实现双向的数据传输，而同一个时刻只能最多有一个方向的传输，不能两个方向同时进行。


·java.lang包是java语言的核心包，lang是language的缩写。java.lang包定义了一些基本的类型，包括Integer,String之类的，是java程序必备的包，有解释器自动引入，无需手动导入.


·运算符优先级：单目>算数运算符>移位>比较>按位>逻辑>三目>赋值。



·java中的异常通常分为编译时异常和运行异常。
    编译时异常需要我们手动的进行捕捉处理，也就是我们用try....catch块进行捕捉处理。
    对于运行时异常只有在编译器在编译运行时才会出现，这些不需要我们手动进行处理。

·Java一个源程序只能有一个public类存在，且类名与文件名相同。Java程序是从main方法开始执行的，public为类加载器提供入口，然后找到public类中的main方法开始执行。如果存在多个public类，程序将不知道该从哪里执行。注意，内部类可以是public的，因为内部类是作为外部类的成员存在的。


·Collection是java.util下的接口，它是各种集合结构的父接口。Collections是java.util下的类，它包含有各种有关集合操作的静态方法。

·Thread.sleep() 和 Object.wait(),都可以抛出 InterruptedException。这个异常是不能忽略的，因为它是一个检查异常(checked exception)。

·实际上，xsd本身就是XML本身。它的目的是验证另一个XML文档的结构。对于任何XML，xsd并不是必需的，但它确保XML可以用于某些特定目的。XML只包含适当格式和结构的数据。


·Java中没用指针，而是用对象的引用来代替指针。当使用new这个单词时，就是为对象开辟空间。
      如果我们希望完成对象的拷贝，使用一个简单的赋值语句是无法完成的。要达到这一目的可以通过实现Cloneable接口并重写clone方法来完成。
      如果我们希望判断两个对象引用是否一致时，可以覆盖继承自Object类的equals()来实现。

·把类名作为数据类型的原因：
    其实类名不是作为数据类型，只能说将这个类的对象作为返回值。意思就是说，这个方法的返回值不是普通的数据类型，而是一个类对象。这样做可以避免一个方法要返回N多的数据，比如说，你要同一个方法中得到name和age，但是java又不能返回多个值，除了可以使用一个字符串或者字符串数组存放外，我们可以定义一个Student对象，对象中包含name和age属性，这样就可以用这个对象把属性封装起来以及方法，一起返回。


·串又称为字符串，是一种特殊的线性表，其特殊性体现在数据元素是一个字符，也就是说串是一种内容受限的线性表。（栈和队列是操作受限的线性表）。

·所谓树的带权路径长度，就是树中所有的叶结点的权值乘上其到根结点的路径长度。
    哈夫曼树的画法：https://www.nowcoder.com/test/question/done?tid=19976137&qid=1001#summary

·在命令提示框运行一个Java程序：
  1.编辑。写好一个xxx.java文件；
  2.编译。javac xxx.java；生成xxx.class文件；
  3.运行xxx.class。java xxx；不用加后缀；











    










