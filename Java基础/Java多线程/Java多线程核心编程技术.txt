java多线程核心编程技术：

--thread类的核心API：
		--自定义线程的实例变量有共享和不共享之分；
			共享的话，就新建一个Thread,然后给这个Thread传参即可；一个线程调用另一个线程的run方法。
			不共享的话，无需新建Thread，直接将线程start即可。

		--Thread构造方法：
			最复杂的一个是：Thread(ThreadGrop group,Runnable target,String name，long stackSize):分配新的thread对象，以便将target作为其运行对象，将指定的name作为其名称，并作为group所引用的线程组的一员,并具有指定的堆栈大小；

		--实例变量与线程安全，用synchronized进行线程同步，即有顺序地执行；
				---线程共享变量：把自定义线程对象传递到新建的Thread类对象中。
				---加锁的代码段称为互斥区或临界区。
				---非线程安全：多个线程对同一对象同一实例变量进行操作时出现值被更改、值不同步的情况，从而影响程序的执行。
				---解决非线程安全：用synchronized关键字来同步方法。
				---i--与system.out.println的异常：i--在println之前执行的。

		--currentThread（）方法：返回代码段正被哪个线程调用的信息。
				Thread.currentThread（）.getName（）与this.getName（）的区别？？？？？。

				使用Thread.currentThread().getName()和使用this.getName()和对象实例.getName(),都可以得到线程的名称,但是使用this调用getName()方法只能在本类中，而不能在其他类中，更不能在Runnable接口中，所以只能使用Thread.currentThread().getName()获取线程的名称，否则会出现编译时异常。

				1.new一个自定义的线程，然后把这个线程对象丢给Thread对象构造方法，执行start 才会出现区别；
				2.如果是直接new一个自定义对象不交给 Thread线程执行调用 在其内部外部 使用 Thread.currentThread().getName()  ，对象实例.getName() 和 this.getName(），这3个区别都不存在,都是相同的，因为没有交给Thread执行，直接调用的是当前实例本身

				this.getName()实际上返回的是target.getName()，而Thread.currentThread().getName()实际上是t1.getName()

			总结几点：
				---一个进程里main是一开始就活着的，但是，它跟main方法半毛钱关系都没有，仅仅是同名罢了；
				---谁调用了start函数，谁才把自己交给线程调度器，谁才是活着的线程，否则，管你继承啥，还是实现啥，都是一个普通的对象；
				---实现了Runable接口的对象具有运行线程的资格，但是，只要它不被start，它就是一个普通的对象，有资格，并不代表它就是线程，线程是活着的东西，对象是死的；
				---线程可以级级包裹嵌套，就像上边一样，它运行的是：target的run
				自己调用run的话，仅仅就是一个函数调用，要让调度器去调用，它才是一个线程。

		--线程类的构造方法、静态块是被new这个线程类所在的线程所调用的，而run方法里面的代码才是被线程自身所调用的。

		--isAlive（）：判断当前线程是否处于活动状态。活动状态就是线程已经启动且尚未终止。
		--sleep（）：在指定的毫秒数时间内让当前“正在执行的线程”休眠（暂停执行），这个“正在执行的线程”是指this.currentThread（）返回的线程。
							 主要是为了暂停当前线程，把cpu片段让出给其他线程，减缓当前线程的执行。 
		--getId（）：取得线程的唯一标识，对象.getId（）。

		--1.7停止线程：Thread.stop（）方法可以停止一个线程，但是这是不安全的，已经被弃用了。
				1.7.1.Thread.interrupt（）方法不会直接终止一个正在运行的线程,仅仅是打标记，还需要加入一个判断才可以完成线程的停止。

				通常有以下3种方法可以终止正在运行的线程：
				1）使用退出标志，即当run方法完成后线程终止。
				2）使用stop方法强行终止线程，但不推荐使用这个方法，因为stop和suspend以及resume一样，都是过期作废的。
				3）使用interrupt方法中断线程。建议使用“抛异常法”来实现线程的停止；也可以用sleep(),在沉睡中停止；
				interrupt（）方法并非真正停止线程，而是在当前线程中打上一个停止的标记。之后根据这个标志再停止线程。
				
				而休眠和阻塞不能停止线程，线程优先级高只能是说明，它获得时间片的概率大，但不是一定会先执行它。

				1.7.2.判断线程是否停止：
				1）this.interruptted（）：测试当前线程是否已经中断；（static）
					interrupted()具有清除状态功能；
				2）this.isInterrupted（）：测试线程是否已经中断。（非static），不清除状态标志。


				1.7.3.异常法停止线程：定义一个throw new InterrupttedException（）；
				1.7.4.在沉睡中停止：在sleep状态下停止线程，会进入catch中并清除停止状态值，使之变成false。
				1.7.5.能停止的线程----暴力停止，使用stop（）停止非常暴力。
						方法stop（）会抛出java.lang.ThreadDeath异常，但通常不需要显示捕捉。但stop（）已经作废，如果用它，一方面可能使得一些清理工作完成不了，另一方面对锁对象进行“解锁”，导致数据不能同步处理，出现数据不一致。
				1.7.8.使用return停止线程：interrupt（）与return结合使用即可。

		--暂停线程：suspend（）暂停线程，resume（）方法恢复线程。
				缺点：
				---独占：使用不当，易造成公共的同步对象的独占，使得其他线程无法访问公共同步对象。
					虽然suspend（）已经过期作废，但是有必要研究它作废的原因，这很有意义。
				---不同步：看后面喔？

		--yield方法：放弃当前的CPU资源，把它让给其他的任务去占用CPU执行时间。但是放弃的时间不确定，可能刚刚放弃，马上又获得CPU时间片。明显地，让给别人会导致自己变慢。

		--线程的优先级：setPriority（）方法是设置线程优先级的，优先级分1~10个等级，如果小于1或者大于10，则抛出异常throw new IllegalArgumentException（）。
		
		在jdk中使用3个常量来预置定义优先级的值，如下：
				源代码后面一部分看不懂！！！！！！！！！！
				public final static int MIN_PRIORITY = 1;
				public final static int NORM_PRIORITY = 5;
				public final static int MAX_PRIORITY = 10;

				1.10.1、线程优先级的继承特性：A线程启动B线程，则B线程的优先级与A的一样。
							 普通优先级线程优先级默认值为5。
				1.10.2、优先级具有规则性：即CPU尽量将执行资源让给优先级比较高的线程。
				1.10.3、优先级具有随机性：优先级和打印顺序无关。
				1.10.4、优先级高的线程运行得更快。

		--守护线程：有两种线程，一是用户线程，二是守护线程。
							GC（垃圾回收器）是最典型的守护线程。
							thread.setDaemon（true）；


--synchronized的使用以及volatile

	2.1.synchronized同步方法：
		2.1.1.方法内的私有变量是线程安全的；（是方法内定义的，不是类内方法外）
		2.1.2.实例变量是非线程安全的；
				两个线程访问同一个对象中的同步方法是一定是线程安全的。
		2.1.3.多个对象多个锁：如果多个线程访问多个对象，则JVM会创建多个锁。同理，一个对象只能有一个锁、
				同步的单词是synchronized，异步的为asynchronized。
		2.1.4.synchronized方法与锁对象：调用synchronized声明的方法一定是要排队的。另外，只用共享资源的读写访问才需要同步化，如果不是共享资源，那么根本没有同步的必要。
				1）A线程先持有object对象的lock锁，B线程可以以异步的方式调用object对象中的非synchronized类型的方法；
				2）A线程先持有object对象的lock锁，B线程如果在这时调用object对象中的synchronized类型的方法则需要等待，也就是同步。
		2.1.5.脏读：读取实例变量时，此值已经被其他线程更改过了。这也可以死通过synchronized关键字来解决。
		2.1.6.synchronized锁重入：使用synchronized时，当一个线程得到一个对象锁后，再次请求此对象锁是可以再次得到该对象的锁的。这也证明在一个synchronized方法/块的内部调用本类的其他synchronized方法/块时，是永远可以得到锁的。
				可重入锁：即自己可以再次获取自己的内部锁。而不可重入锁会造成死锁。
				可重入锁支持在父子类继承的环境中。当存在父子类继承时，子类完全可以通过"可重入锁"调用父类的同步方法。
		2.1.7.出现异常，锁自动释放。
		2.1.8.同步不可以继承。


	2.2.synchronized同步代码块：synchronized方法是对当前对象加锁，synchronized代码块是对某一个对象加锁；

		在用synchronized关键字的时候，能缩小代码段的范围就尽量缩小，能在代码段上加同步就不要再整个方法上加同步。这叫减小锁的粒度，使代码更大程度的并发。原因是基于以上的思想，锁的代码段太长了，别的线程要等很久。

		2.2.1.synchronized方法的弊端：同步下，一个线程等待另一个线程时间长；

		2.2.2.同一时间只能有一个线程访问同步代码块，其他线程需要等待当前线程完成后才能抢占；

		2.2.3.用同步代码块解决同步方法的弊端；当一个线程访问object的一个synchronized同步代码块时，另一个线程仍然可以访问该object对象中的非synchronized（this）同步代码块。

		2.2.4.一半同步，一半异步：不在synchronized块中就是异步执行，在synchronized块中就是同步执行。

		2.2.5.synchronized代码块间的同步性；

		2.2.6.synchronized（this）代码块是锁定当前对象的；

		2.2.7.将任意对象作为对象监视器；对象监视器不同，运行结果就是异步的。

		2.2.8.细化验证3个结论：
				（1）多个线程同时执行synchronized（x）{}同步代码块时呈同步效果。
				（2）其他线程执行x对象中synchronized同步方法时呈同步效果；
				（3）其他线程执行x对象方法里面的synchronized（this）代码块是呈同步效果。

		2.2.9.静态同步synchronized方法与synchronized（class）代码块；
				--synchronized关键字加到static静态方法上是给Class类上锁，而synchronized关键字加到非static静态方法上是给对象上锁。而Class锁可以对类的所有对象实例起作用。
				--同步synchronized（class）代码块的作用其实和synchronized static方法的作用一样。【非杂交在一起使用时的情况】

		2.2.10.数据类型String的常量池特性：
					将synchronized（string）同步块与string联合使用时，要注意常量池以带来一些例外（如导致两个线程持有相同的锁）。因此大多情况下，同步synchronized代码块都不使用String作为锁对象，而改用其他，如new Object（）实例化一个Object对象，但它并不放入缓存中。

		2.2.11.同步synchronized方法无限等待与解决：
					同步方法容易造成死循环。可以使用同步代码块来解决这个问题。

		2.2.12.多线程的死锁：只要互相等待对方释放锁就有可能出现死锁。

		2.2.13.内置类和静态内置类：
					内置类想要实例化，必须：PrivateClass privateClass = publicClass.new PrivateClass（）；
					静态内置类想要实例化，可以：PrivateClass privateClass = new PrivateClass（）；

		2.2.14.内置类与同步：
					实验一：内置类中有2个同步方法，但使用的却是不同的锁，打印的结果也是异步的。
					实验二：同步代码块synchronized（class2）对class2上锁后，其他线程只能以同步的方式调用class2中的静态同步方法。

		2.2.16.锁对象的改变：多个线程如果同时持有相同的锁对象，则这些线程之间是同步的；如果分别获得锁对象，这些线程之间是异步的。只要对象不变，对象的属性被改变，运行结果还是同步的。


	2.3.volatile关键字：使得变量在多个线程间可见。
		2.3.1.volatile与死循环：
				出现“多继承”的情况时，用Runnable接口的方式处理多线程是很有必要的；
				而不是的时候，使用继承Thread类和实现Runnable接口的取得程序运行的结果无大差别。
		2.3.2.解决同步死循环：
		2.3.3.解决异步死循环：
				使用volatile关键字，强制从内存中读取变量的值，从主内存加载到线程工作内存中的值是最新的。增加了实例变量在多个线程之间的可见性，但volatile缺点是不支持原子性。

		2.3.4.volatile非原子的特性：不具备同步性，也就不具备原子性。
		2.3.5.使用原子类进行i++操作：除了使用synchronized实现同步外，还可以使用AtomicInteger原子锁进行实现，这是一个原子操作的可用类型，可以在没有锁的情况下做到线程安全。
		2.3.6.原子类也并不完全安全：在具有逻辑性的情况下输出结果也具有随机性。
		2.3.7.synchronized代码块有volatile同步的功能：即多线程访问资源具有同步性，还有将私有内存和公有内存中的变量同步的功能。

		总结：多线程并发，外练互斥，内修可见。


--线程间的通信：
	3.1.等待/通知机制：
		3.1.1.不使用等待/通知机制实现线程间通信：sleep（）结合while（true）死循环来实现多线程间的通信。但这样会浪费CPU资源。
		3.1.2.什么是等待/通知机制：


	3.2.方法join的使用：其作用是等待线程对象销毁。join有些类似同步，join和synchronized区别：join在内部使用wait（）方法等待，因此会释放锁；而synchronized使用的是“对象监视器”原理做为同步。
		3.2.3.join（）与inturrupt（）彼此相遇，会出现异常；
		3.2.4.方法join（long）的使用：参数是设定等待的时间的。


	3.3.ThreadLocal的使用：变量值的共享可以使用public static变量的形式，所有的线程都使用同一个public static。
		而实现每一个线程都有自己的共享变量，则可以用ThreadLocal。
		3.3.1.方法get（）与null：类Threadlocal解决的是变量在不同线程间的隔离性，也就是不同线程拥有自己的值。


--Lock的使用


--定时器类


--单例模式与多线程：
	6.1.立即加载/“饿汉模式”：调用方法前，实例已经创建；
	6.2.延迟加载/“懒汉模式”：实例需要才创建；但在多线程环境下，这种模式是错误的。可以用synchronized方法和synchronized代码块来解决，但是效率很低。我们由此引出双重校验锁。
	--使用DCL双检查锁机制：DCL也是大多数多线程结合单例模式使用的解决方案，保证线程安全。
	6.3.使用静态内部类实现单例模式，可以保证线程安全；
	6.4.序列化与反序列化的单例模式：
	6.5.使用static代码块实现单例模式；
	6.6.使用enum枚举数据类型实现单例模式；


--线程知识点的拾遗




