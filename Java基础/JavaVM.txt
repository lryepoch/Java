
·垃圾回收机制思想：

	1、Java编写程序不需要考虑内存管理；
	2、垃圾回收器作为守护线程在后台运行。在不可预知的情况下（在内存紧张时自动跳出来），对内存堆中死亡的对象或者长时间不运行的对象进行清除和回收，程序员不可以实时调用垃圾回收器进行垃圾回收。
	3、可以手动使用System.gc（）通知GC运行，但是Java的语言规范并不能保证GC一定会运行。



·JVM内存模型：描述的是类被加载时，经过解析后，存储到特定的数据区。

	线程共享：

	堆：内存中最大一块，存放对象实例以及数组。垃圾收集器管理的主战场，分新生代和老年代。内存空间逻辑上连续，物理上可不连续。
			作用：jvm启动时创建，用来维护运行时数据。


	方法区：又称永久代（PermGen），用来存储类的信息（方法，方法名，返回值）、常量、静态变量、即时编译器生成的代码，别名（非堆）。
				JVM规范把方法区称为堆的一个逻辑部分，但方法区还有一个别名叫非堆，目的是将其与堆区分开来。

				运行时常量池：方法区的一部分， 存放编译期生成的各种字面量和符号引用。

				JDK1.8改进：方法区中永久代向元空间的转换。

										>为什么要做这个转换？

									　　1、字符串存在永久代中，容易出现性能问题和内存溢出。

									　　2、类及方法的信息等比较难确定其大小，因此对于永久代的大小指定比较困难，太小容易出现永久代溢出，太大则容易导致老年代溢出。

									　　3、永久代会为 GC 带来不必要的复杂度，并且回收效率偏低。

										>解析：
													元空间的本质和永久代类似，都是对JVM规范中方法区的实现。不过元空间与永久代之间较大的区别在于：元空间并不在虚拟机中，而是使用本地内存。
													因此，默认情况下，元空间的大小仅受本地内存限制，但可以通过以下参数来指定元空间的大小：

												　-XX:MetaspaceSize                ##初始空间大小，达到该值就会触发垃圾收集进行类型卸载，同时GC会对该值进行调整：
																										如果释放了大量的空间，就适当降低该值；
																										如果释放了很少的空间，那么在不超过MaxMetaspaceSize时，适当提高该值。

												　-XX:MaxMetaspaceSize          ##最大空间，默认是没有限制的。

											　　除了上面两个指定大小的选项以外，还有两个与 GC 相关的属性：
											　　-XX:MinMetaspaceFreeRatio，在GC之后，最小的Metaspace剩余空间容量的百分比，减少为分配空间所导致的垃圾收集；
											　　-XX:MaxMetaspaceFreeRatio，在GC之后，较大的Metaspace剩余空间容量的百分比，减少为释放空间所导致的垃圾收集；



	线程隔离：

	程序计数器：当前线程执行字节码的行号指示器，每个线程都有自己的程序计数器；如果正在执行Java方法，则记录的是正在执行的字节码指令的地址；如果是native方法，则计数器为空。这是jvm中唯一没有规定					任何outofMemoryError情况的区域。

	虚拟机栈：生命周期同线程，描述的是Java方法执行的内存模型。方法从执行到结束对应着栈帧进栈出栈的过程，线程结束内存自动释放；

	本地方法栈：描述的是为虚拟机用到的native方法出栈和入栈的过程(通常我们不需要了解这块，它底层是C语言实现的，)；




·为什么分为线程共享和非线程共享的呢?
	首先我们熟悉一下一个一般性的 Java 程序的工作过程。一个 Java 源程序文件，会被编译为字节码文件（以 class 为扩展名），每个java程序都需要运行在自己的JVM上，然后告知 JVM 程序的运行入口，再被 JVM 通过字节码解释器加载运行。那么程序开始运行后，都是如何涉及到各内存区域的呢？
	
	概括地说来，JVM初始运行的时候都会分配好 Method Area（方法区） 和Heap（堆） ，而JVM 每遇到一个线程，就为其分配一个 Program Counter Register（程序计数器） , VM Stack（虚拟机栈）和Native Method Stack  （本地方法栈）， 当线程终止时，三者（虚拟机栈，本地方法栈和程序计数器）所占用的内存空间也会被释放掉。这也是为什么我把内存区域分为线程共享和非线程共享的原因。

	非线程共享的那三个区域的生命周期与所属线程相同，而线程共享的区域与JAVA程序运行的生命周期相同，所以这也是系统垃圾回收的场所只发生在线程共享的区域（实际上对大部分虚拟机来说知发生在Heap上）的原因。




·内存泄露：
	·含义：程序申请内存空间后，无法释放内存空间；内存泄漏堆积起来最后会消耗完内存； 
	·分类：
		··常发性：多次；
		··偶发性：特定情况下；
		··一次性：一次；
		··隐式：不停地分配；

	·原因：
		··静态集合类引起内存泄漏；像HashMap、Vector等的使用最容易出现内存泄露，这些静态变量的生命周期和应用程序一致，他们所引用的所有的对象Object也不能被释放，因为他们也将一直被Vector等引用着。
		··当集合里面的对象属性被修改后，再调用remove()方法时不起作用。
		··各种连接；比如数据库连接（dataSourse.getConnection()），网络连接(socket)和io连接，除非其显式的调用了其close（）方法将其连接关闭，否则是不会自动被GC 回收的。
		··监听器。在释放对象的时候却没有去删除这些监听器，增加了内存泄漏的机会。
		··单例模式；如果单例对象持有外部对象的引用，那么这个外部对象将不能被jvm正常回收，导致内存泄露。

		或者：长生命周期对象引用短生命周期对象；没有将无用对象设置为null。

	·解决方案：
		··修改JVM启动参数，直接增加内存。(-Xms，-Xmx参数一定不要忘记加。)
		··检查错误日志，查看“OutOfMemory”错误前是否有其它异常或错误。
		··对代码进行走查和分析，找出可能发生内存溢出的位置。



·内存溢出：
	··含义：程序申请内存时，没有足够的空间供其使用，出现out of memory；

	··关于下面哪种情况会导致持久区jvm堆内存溢出？https://www.nowcoder.com/test/question/done?tid=16720950&qid=14849#summary




·JVM启动参数：
	答：
			1.堆内存分配：
			-Xms?            ##设置堆的最小值，默认是物理内存的 1/64；
			-Xmx ?           ##设置堆的最大值，默认是物理内存的 1/4；

			默认空余堆内存小于 40% 时，JVM 就会增大堆直到-Xmx 的最大限制；空余堆内存大于 70% 时，JVM 会减少堆直到 -Xms 的最小限制；
			因此服务器一般设置-Xms、-Xmx 相等以避免在每次 GC 后调整堆的大小。

			2.非堆内存分配：
			-XX:PermSize=?                     ##设置永久代初始值，默认是物理内存的 1/64；
			-XX:MaxPermSize=?              ##设置永久代最大值，默认是物理内存的 1/4；
			-Xmn2G                              ##设置新生代大小为 2G；
			-XX:SurvivorRatio=?             ##设置年轻代中 Eden 区与 Survivor 区的比值。



·堆的分区：
	··新生代：采用复制算法回收内存；
			  HotSpot虚拟机默认Eden和Survivor的大小比例是8:1；
		···Eden区：内存分配的地方，是一个连续的空闲内存区域；新对象总是在Eden区生成，只有经受住了Minor GC，才能顺利进入存活区。
		···存活区：2个（s0和s1），交替使用，在下一次垃圾回收时，之前被清除的存活区又用来放置存活下来的对象。

	··老年代：在新生代中经历了N次（默认16）回收后仍然没有被清除的对象，就会被复制到年老代中，都是生命周期较长的对象。如果对象不能在Eden区中创建，它也会直接在年老代中创建。

						设置-XX:PretenureSizeThreshold:参数（通常3MB）       ##当大于该值时，对象直接在老年代中创建

	··永久代：即方法区。存储的是常量，常量池，静态变量。

					>JVM的永久代中会发生垃圾回收么？

					参考答案
					永久代会垃圾回收,但是没有自己的垃圾收集器,是和老年代一起回收的。

					永生代也是可以回收的，条件是：
					1.该类的实例都被回收；
					2.加载该类的classLoader已经被回收；
					3.该类不能通过反射访问到其方法而且该类的java.lang.class没有被引用；
					当满足这3个条件时，是可以回收，但回不回收还得看jvm。

					“相对而言，垃圾收集行为在这个区域是比较少出现的，但并非数据进入了方法区就如永久代的名字一样“永久”存在了。这区域的内存回收目标主要是针对常量池的回收和对类型的卸载，一般来说，这个区域的回收“成绩”比较难以令人满意，尤其是类型的卸载，条件相当苛刻，但是这部分区域的回收确实是必要的。”



·内存分配规则/对象分配规则？：

	··对象优先分配在Eden区，如果没有足够空间，将执行一次Minor GC;

	··大对象直接进入年老区，目的是避免在Eden区和2个存活区之间发生大量的内存拷贝；

	··长期存活的对象进入年老代。JVM为每个对象定义了一个年龄计数器，如果对象经过了1次Minor GC，那么对象就会进入Survivor区。之后每经过一次Minor GC，那么对象的年龄加1，直到达到阈值后对象进入老年区。

	··动态判断对象年龄；如果存活区中相同年龄的所有对象大小总和大于存活区空间的一半，那么年龄大于或者等于该年龄的对象可以直接进入年老区；

	··空间分配担保；每次进行Minor GC时，JVM会计算存活区移动到年老区对象的平均大小，如果这个值大于老年区的剩余空间大小则进行一次Full GC；如果小于，则检查 HandlePromotionFailure 设置，如果为true，则只进行Monitor GC，如果是false，则进行Full GC。




·如何GC?

	··Minor GC：Minor GC是发生在新生代中的垃圾收集动作，采用的是复制算法。
		在Eden区申请空间失败时就会MinorGC，对Eden区GC来清除非存活对象，同时把存活对象复制到存活区中的一个，对象经过MinorGC才能进入到存活区，MinorGC只会生在新生代，会非常频繁地执行；又触发了一次Minor GC后，Eden和s0中存活的对象被复制到s1中，然后Eden和s0被清空。同一时刻，只有Eden和一个存活区同时被操作。当每次从Eden复制到一个存活区或者从一个存活区复制到另一个存活区时，由于虚拟机给每个对象定义一个年龄计数器，计数器自动增加，默认情况下如果复制发生超过16次，jvm会停止复制并把们移动到年老代中。

	·Major GC：清理老年代

	··Full GC：Full GC是发生在老年代的垃圾收集动作，采用的是标记-清除-压缩算法。如果年老代空间满了，就会触发Full GC。Full GC对整个块进行回收包括年轻代、年老代和永久代。Full GC是一个压缩处理过程，所以它比Minor GC要慢得多。发生 Full GC 一般都会有一次 Minor GC。


	··Java的垃圾回收器（GC）主要针对堆区。方法调用时，会创建栈帧在栈中，调用完是程序自动出栈释放，而不是gc释放。java虚拟机，对于方法的调用采用的是栈帧（方法调用和方法执行），调用则入栈，完成之后则出栈。不就回收了内存资源。而针对于其他，GC回收的时间不定。


	··java的垃圾收集机制主要针对新生代和老年代的内存进行回收，不同的垃圾收集算法针对不同的区域。所以java的垃圾收集算法使用的是分代回收。
		一般java的对象首先进入新生代的Eden区域，当进行GC的时候会回收新生代的区域，新生代一般采用复制收集算法，将活着的对象复制到survivor区域中，如果survivor区域装在不下，就查看老年代是否有足够的空间装下新生代中的对象，如果能装下就装下，否则老年代就执行FULL GC回收自己，老年代还是装不下，就会抛出OUtOfMemory的异常。




·判断对象是否是垃圾？

	引用计数法 ：为创建的对象分配一个引用计数器，用来存储该对象引用的次数。当次数为0，可以认为该对象已经死亡。但该方法无法检测“循环引用”：当2个对象互相引用时，即使它俩都不被外界引用，它俩的计数器都不为0，因此永远不会被回收。实际上，他们已经无用了。

	可达性分析算法：把所有对象想象成一个树，从树的根结点GC Roots出发，持续遍历找出所有连接的树枝对象，这些对象称为“可达”对象。其余的则是“不可达”对象。

			哪些对象可以作为GC Roots呢？
								1.虚拟机栈中引用的对象；
								2.本地方法栈中引用的对象；
								3.方法区中静态变量、常量引用的对象；



·垃圾回收算法有哪些？

答：
		复制算法 ：此算法把内存空间划为两个相等的区域，每次只使用其中一个区域。垃圾回收时，遍历当前使用区域，把正在使用中的对象复制到另外一个区域中；此算法每次只处理正在使用中的对象，因此复制成						本比较小，同时复制过去以后还能进行相应的内存整理，不会出现 “碎片” 问题。当然，此算法的缺点也是很明显的，就是需要两倍内存空间；
						  两个区域A和B，初始对象在A，继续存活的对象被转移到B。此为新生代最常用的算法；

						  ##存活对象少，垃圾多。

		标记-清除 ：此算法执行分两阶段。第一阶段从引用根节点开始标记所有被引用的对象，第二阶段遍历整个堆，把未标记的对象清除；此算法需要暂停整个应用，同时，会产生内存碎片；
							一块区域，标记可达对象（可达性分析），然后回收不可达对象，会出现碎片，那么引出；

							##简单方便，但内存碎片多。

		标记-整理 ：此算法结合了 “标记-清除” 和 “复制” 两个算法的优点。也是分两阶段，第一阶段从根节点开始标记所有被引用对象，第二阶段遍历整个堆，把清除未标记对象并且把存活对象 “压缩” 								到堆的其中一块，按顺序排放。	此算法避免了 “标记-清除” 的碎片问题，同时也避免了 “复制” 算法的空间问题。多了碎片整理，整理出更大的内存放更大的对象；

							##存活对象多，垃圾少。

		分代收集：

		综上：新生代基本采用复制算法，老年代采用标记-整理算法。cms采用标记-清除算法。




·类加载器：

    ··类加载器的概念？
		类加载器用来加载 Java 类到 Java 虚拟机中。

		Java 虚拟机使用 Java 类的方式如下：Java 源程序（.java 文件）在经过 Java 编译器编译之后就被转换成 Java 字节代码（.class 文件）。类加载器负责读取 Java 字节代码，并转换成 java.lang.Class 类的一个实例。每个这样的实例用来表示一个 Java 类。通过此实例的 newInstance() 方法就可以创建出该类的一个对象。实际的情况可能更加复杂，比如 Java 字节代码可能是通过工具动态生成的，也可能是通过网络下载的。


	··如何判定两个 Java 类是相同的？
			1、类的全名是否一致；
			2、加载此类的类加载器是否一致。


	··类加载器加载 class 文件的过程？
			1、加载：把.class文件加载到内存；
			2、连接：分3步。字节码验证，类数据结构分析及内存分配，符号表的链接；
			3、初始化；
			4、使用；
			5。卸载；GC垃圾回收。


	··JDK中提供了3个类加载器，根据层级从高到低为：

		Bootstrap ClassLoader，主要加载JVM自身工作需要的类。
												##加载系统类（即内置类如String）。

		Extension ClassLoader，主要加载%JAVA_HOME%\lib\ext目录下的库类。
												##加载扩展类（即继承类和实现类）。

		Application ClassLoader，主要加载Classpath指定的库类，一般情况下这是程序中的默认类加载器，也是ClassLoader.getSystemClassLoader()的返回值。
		（这里的Classpath默认指的是环境变量中配置的Classpath，但是可以在执行Java命令的时候使用-cp 参数来修改当前程序使用的Classpath）
												##加载应用类（程序员自定义的类）
		

	··JVM加载类的实现方式，我们称为 双亲委托模型：

		>双亲委派模型的工作过程？
			如果一个类加载器收到了类加载的请求，他首先不会自己去尝试加载这个类，而是把这个请求委托给自己的父加载器，每一层的类加载器都是如此，因此所有的类加载请求最终都应该传送到顶层的Bootstrap ClassLoader中，只有当父加载器反馈自己无法完成加载请求时，子加载器才会尝试自己加载。


		>为什么这样设计呢？

			1、为了安全。避免自定义的类替换掉Java的核心类；
					eg：假设有一个开发者自己编写了一个名为Java.lang.Object的类，想借此欺骗JVM。现在他要使用自定义ClassLoader来加载自己编写的java.lang.Object类。然而幸运的是，双亲委托模型不会让他成功。因为JV	M会优先在Bootstrap ClassLoader的路径下找到java.lang.Object类，并载入它。

			2、避免重复加载。区分不同类，不仅仅看类名，还要看类加载器。


	··类加载器基于3个机制：
		1、委托性：双亲委派模型。
		2、可见性：子类加载器可以看到所有父类加载器加载的类，但是反过来不能。
		3、单一性：一次就加载一个类，确保类不会被重复加载。




·常见的GC收集器：
		Serial New收集器                                			  ##针对新生代，采用复制算法。client模式下首选新生代收集器
		Serial Old（串行）收集器                       ##新生代采用复制算法，老年代采用标记-整理算法。client模式下首选老年代收集器

		Parallel New（并行）收集器                 		 ##新生代采用复制算法，老年代采用标记-整理算法。server模式下首选的新生代收集器
		Parallel Scavenge（并行）收集器          ##针对新生代，采用复制算法。更加关注吞吐量
		Parallel Old（并行）收集器                    ##针对老年代，标记-整理算法。Parallel Scavenge（并行）收集器的老年代版本

		CMS收集器                                           ##基于标记-清除算法。获取最短停顿时间为目标，老年代收集器
		G1收集器                                              ##整体上是基于标记-整理算法 ，局部采用复制算法。更加关注停顿时间




·Java内存模型：

	1、所有变量存储在主内存上；
	2、每条线程有自己的工作内存；
	3、线程的工作内存保存了需要使用的变量拷贝，这是从主内存中拷贝而来的；
	4、线程对变量的所有操作在工作内存中进行，不能直接操作主内存的变量；
	5、不同线程不能直接访问对方工作内存的变量；
	6、线程间变量的值传递需要经过主内存。

	问题：2个线程如何通信？

				当存在公共状态时：2个线程之间的通信通过共享对象来进行。

				当不存在时：必须通过明确的发送信息来显式通信。
						  例如：使用wait（）和notify（）方法。



·内存屏障？
	··内存屏障为何重要？


	··Java创建一个对象的过程：
		1.装载
		2.初始化
		3.卸载
