
·使用Java 8时，首先做的就是使用lambda表达式替换匿名类；用() -> {}代码块替代了整个匿名类。

·与匿名类概念相比较，Lambda其实就是匿名方法，这是一种把方法作为参数进行传递的编程思想。引入Lambda表达式，会使得代码更加紧凑，而不是各种接口和匿名类到处飞。

·局限性：
		1.可读性差，与啰嗦的但是清晰的匿名类代码结构比较起来，Lambda表达式一旦变得比较长，就难以理解
		2.不便于调试，很难在Lambda表达式中增加调试信息，比如日志
		3.版本支持，Lambda表达式在JDK8版本中才开始支持，如果系统使用的是以前的版本，考虑系统的稳定性等原因，而不愿意升级，那么就无法使用。
		4.Lambda比较适合用在简短的业务代码中，并不适合用在复杂的系统中，会加大维护成本。


·可以使用lambda写出如下代码：(只有一个参数的时候，才可以去掉圆括号)
								(params) -> expression
								(params) -> statement
								(params) -> { statements }


·stream：
	··能够对集合中的每个元素进行一系列并行或串行的流水线操作。只需要告诉流你的要求，流便会在背后自行根据要求对元素进行处理。

	··parallelStream执行效率要比传统的for循环和stream要快的多，那么什么时候要用stream或者parallelStream呢？
		并行流就是把内容分成多个数据块，使用不同的线程分别处理每个数据块的流。

	··可以从以下三点入手考虑：
							是否需要并行？  
							任务之间是否是独立的？是否会引起任何竞态条件？  
							结果是否取决于任务的调用顺序？


	··使用stream().forEach(),就是单纯的串行遍历循环和使用for循环得到的效果一样,只是这种方式可以使代码更精简;

	··使用parallelStream().forEach()，是并行遍历循环，相当于是使用了多线程处理，这样可以在一定程度上提高执行效率.而程序在运行过程中具体会使用多少个线程进行处理,系统会根据运行服务器的资源占用情况自动进行分配。

	

------------------------------------------------------------

·是什么：
	··箭头函数、匿名函数、闭包
	··轻量级函数式编程
	··‘->’：左侧是操作参数，右侧是操作表达式

	尽可能将代码封装成数据，解决方案：接口以及实现类


·函数式接口(Functional Interface)就是一个有且仅有一个抽象方法，但是可以有多个非抽象方法的接口。函数式接口可以被隐式转换为 lambda 表达式。
	语义化检测注解：@FunctionalInterface

·函数式接口和lambda表达式的关系：
	··函数式接口：只包含一个操作方法；
	··lambda表达式：只能操作一个方法；
	··java中的lambda表达式，核心就是一个函数式接口的实现；








·高级部分：
··匿名内部类实现
··lambda表达式的实现方式（在匿名内部类基础上进化）
··静态引用：将参数默认传给调用的方法
··实例方法引用：通过创建对象调用实例方法
··构造方法引用：绑定函数式接口

·stream api
··聚合操作：
··stream的处理流程：
	数据源
	数据转换
	获取结果

··获取stream对象
	1.从集合或者数组中获取
	2.BufferedReader
	3.……

··中间操作API：
	操作结果是一个Stream,中间操作可以有一个或者多个连续的中间操作，中间操作只记录操作方式，不做具体执行，直到结束操作发生时，才做数据的最终执行。
		中间操作：就是业务逻辑处理。

	中间操作过程：无状态；数据处理是，不受前置中间操作的影响；
					map/filter/peek/parallel/sequential/unordered
				  有状态：数据处理时，受到前置中间操作的影响：
					distinct/sorted/limit/skip

··结束操作：
	需要注意：一个stream对象，只能有一个terminal操作，这个操作一旦发生，就会正是处理数据，生成对应的处理结果。

	分类：非短路操作：当前的stream对象必须处理完集合中所有数据，才能得到处理结果。forEach/forEachOrdered/toArray/reduce/collect/min/max/count/iterator
			短路操作：当前的stream对象在处理过程中，一旦满足某个条件，就可以得到结果。anyMatch/allMatch/noneMatch/findFirst/findAny等
