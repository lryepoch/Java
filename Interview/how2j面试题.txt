
J2SE:
1.面向对象的特征：封装、继承、多态。
2.String是类类型，不是基本类型。
3.int是基本类型，Integer是封装类。可通过自动装箱和拆箱来转换。
4.immutable指不可变的，内容一旦创建好，不可更改。String是immutable的，StringBuffer可以变长，内容可以更改，因为它的内部是采用字符数组存放数据，需要增加长度时，创建新的数组，然后复制原数组到新的数组。
5.运行异常又叫非可查异常，不要求进行显示捕捉；一般异常又叫可查异常，要么捕捉，要么throw抛出去。

7.Collection是List和Set接口,Collections是工具类，提供了排序、查找等等实用方法。
8.
		&：位与和逻辑与，是长路与，两侧都会被运算。
		&&：逻辑与，是短路与，只要第一个是false，第二个不用算了。
9.HashMap和Hashtable的区别
10.final、finally、finalize的区别：
		final：
		修饰类时，该类不能被继承；
		修饰方法时，该方法不能被重写；
		修饰变量时，该变量只能被赋值一次；
		修饰引用时，该引用只有一次指向对象的机会。
		finally：
		用于异常处理，无论是否有异常，都会被执行。
		finalize:
		是Object的方法，所有的类都继承了该方法。垃圾回收时，该方法被调用。

11.重载：同一个类，方法名一样，参数列表不同。可以改变返回值类型，本质上是不同的方法，只不过取了同样的名字。
		重写：子类继承父类后，对父类中的方法又重写了一遍。
12.Error和Exception区别：
										都继承了Throwable接口；
										Error指JVM层面错误；
										Exception指代码逻辑错误；
13.抽象类和接口区别：
			抽象类只能通过继承被使用，接口需要通过实现被使用；
			抽象类不仅可以有抽象方法，也可以有实现方法。
			接口只能有抽象方法，不能提供实现方法。但是JAVA8开始，接口可以有实现方法了。前提是要在方法前加一个default修饰符。
14.heap：堆>放对象》自动增加，大小不定，速度较慢
stack：（堆）栈>放基本类型、引用（对象地址）、方法调用》大小固定，先进后出，速度较快
15.GC垃圾回收，有了它，可以使开发人员专注于开发。

17.Math.round();加0.5取整数的意思。
18.String s = new String("xyz");
		首先构造方法 new String("xyz"); 中的"xyz" 这本身就是一个字符串对象
		然后 new 关键字一定会创建一个对象
		所以总共创建了两个String对象
19.Java中goto存在，但是是保留字，没有功能。
20.接口可以继承接口；抽象类可以实现接口；抽象类可以继承实体类。

22.抽象类的method不可同时是static，不可同时是synchronized.
23.获取长度的手段：
数组：.length属性;
String：length();
集合：size();
文件：length();
24.HashSet判断是否重复的逻辑是：
		a.看hashcode是否相同，如果同，则重复；
		b.如果不同，用equals判断值是否相同，同则重复。

25.不存在重写父类的构造方法，因为子类不能继承父类的构造方法。子类可以用super（）调用父类的构造方法，这并不能叫继承父类的构造方法。String是final修饰的，所以不能继承String。

26.switch可以作用byte、short、int、String、Enum,不能作用在long.
27.try里的return和finally中的return都支持，但当前方法只会执行finally中的return.
28.重写equals方法时，也需要对hashcode方法进行重写，如此来保证这两个掉毛的一致性。当equals返回true时，他们就有相同的hashcode。
29.GC的两种方式：定时回收和按垃圾所占百分比回收。
30.Java集合类以及主要方法。

31.char型变量是16位的，即2个字节。汉字也是2个字节。所以可以存放汉字。
32.读取XML文档的2种方法：SAX和DOM。SAX是逐行读取，直到找到目标为止；先全文档加载，然后读取。
33.throws：用在方法声明上，该方法可能会抛出异常；
throw：一定会抛出异常；
try……catch：成对出现，可能会抛出异常，一旦抛出异常后会在catch中进行捕捉。
finally：无论是否抛出异常，都会执行。
34.一个.java源文件可以包含多个类（非内部类），但只能有一个用Public修饰的类，可以有多个非public修饰的类。
35.java中有几种类型的流？
Java中所有的流都是基于字节流，所以最基本的流是输入输出字节流InputStream/OutputStream;
在字节流基础上，封装了字符流Reader、Writer;
进一步，又封装了缓存流BufferedReader/PrintWriter;
以及数据流DataInputStream/DataOutputStream;
对象流ObjectInputStream/ObjectOutputStream;
以及一些其他的奇奇怪怪的流……。

36.java存在Java特色的内存泄漏。当某些对象不被使用，但又有非直接引用指向时，这不满足垃圾回收机制，而形成了内存泄漏。
eg:比如代码中的例子，每个Object创建的时候，有一个引用o指向，接着就被放进了集合al中。 下一个Object创建的时候，上一个Object就没有引用指向了。
这些Object都没有引用指向，但是却放在ArrayList中，而这个Arraylist忘记了回收，那么里面的所有对象，都会一直存活下去，虽然不再被使用了。
37.类的多态的条件：父类（接口）引用指向子类对象；方法有重写。
38.静态变量直接有类访问，不需实例对象，实例变量需要实例对象才能访问。
39.序列化即把一个对象通过某种介质进行传输，如利用Socket进行输入输出流或者保存到文件中。要实现序列化，可以让该类实现接口Serializable,该接口没有方法，仅仅表示该类可以序列化。
40.static方法不可以调用非static方法，因为非static方法需要实例对象才可调用，而static不一定有实例对象。

41.在JAVA中，如何跳出当前的多重嵌套循环？
在外部循环的前一行加上一个标签，在break后使用该标签即可。
43.匿名内部类本质上就是继承其他类，实现其他接口。
44.内部类可以调用外部类的成员。但
														如果是非静态内部类可以引用外部所有成员；
														如果是静态内部类，只能引用外部静态成员。
45.Java 创建一个线程有三种方式
			1. 继承一个Thread类
			2. 实现Runnable接口
			3. 匿名内部类

46.sleep()和wait()之间没有任何关系。
sleep是Thread类的方法，指的是当前线程暂停；
wait是Object类的方法，指的是占用当前对象的线程临时释放对当前对象的占用，让其他线程有机会占用当前对象，注意调用wait方法一定是在synchronized修饰的方法中进行的。
47.数据库连接池:创建连接和关闭连接非常耗时,我们可以先创建n条数据库连接，循环使用，但不会关闭他们，再执行SQL语句，不需要额外创建数据库连接，直接使用现成的，从而节约开销。
48.简述synchronized和java.util.concurrent.locks.Lock的异同 ？
Lock是一个接口，是代码层面的实现；synchronized是一个关键字，是内置的语言实现；
Lock会选择性获取锁，一段时间获取不到，则会取消；synchronized则会一根筋地获取下去。所以Lock可以很好地规避死锁，而synchronized需要好的设计才能减少死锁的发生；
synchronized在发生异常或者同步块结束时，自动释放锁；而Lock必须手动释放，如果忘记释放，则会发生死锁。

49.Class.forName的作用?为什么要用?
		初始化数据库驱动；
		把类加载到JVM中，初始化静态属性，在此过程中，执行相关代码，以达到加载驱动的效果。
50.当一个线程进入一个对象的一个synchronized方法后，其它线程是否可进入此对象的其它方法:
如果其他方法也被synchronized修饰的话，则无法进入其他的方法。

51.给我五个你最常见到的runtime exception（运行异常）:
NullPointerException:空指针异常；
ClassCastException:类型转换异常；


J2EE:
一.前端：
1.常见选择器：
元素选择器：
id选择器：对应#符号；
class选择器：对应.符号；
2.块级元素：div p h1 h2 h3 h4 form ul;
行内元素：a b i span input select;
3.前端页面的三大层：
结构层(内容)：html;
表示层：css;
行为层：js;
4.标签上title和alt属性的区别：
alt当图片不显示，是用文字代表；
title为该属性提供信息；
5.js的typeof返回哪些数据类型：
Object number function boolean undefined;
6.js如何进行数字和字符串的转换：
数字转字符串：toString();
字符串转数字：new Number();
7.如何隐藏一个元素：
css隐藏：1）display:nono();(不占位置)。2）visibility:hidden;(要占位置)
JQuery方式隐藏：$(selector).hide()

二.服务端；
1.jsp9种隐式对象，以及他们的用途：
request：
response：
out：
pageContxt:
session:
application:
config:
page:
exception:

2.3种jsp指令：
<%@page
JSP的基本设置，比如编码方式，import其他类，是否开启EL表达式

<%@include
包含其他的文件

<%@taglib
使用标签库

3.2种jsp动作：
<jsp:foward
服务端跳转

<jsp:include
包含其他文件

4.doGet()和 doPost的区别，分别在什么情况下调用
5.servlet的init方法和service方法的区别
6.servlet的生命周期
7.页面间对象传递的方法：
		假设是a.jsp传递数据到b.jsp，那么页面间对象传递的方式有如下几种
		1. 在a.jsp中request.setAttribute，然后服务端跳转到b.jsp

		2. 在a.jsp中session.setAttribute，然后跳转到b.jsp, 无所谓客户端还是服务端跳转

		3. 在a.jsp中application.setAttribute, 然后跳转到b.jsp，无所谓客户端还是服务端跳转

8.Request常见方法：
request.getRequestURL(): 浏览器发出请求时的完整URL，包括协议 主机名 端口(如果有)" + 
request.getRequestURI(): 浏览器发出请求的资源名部分，去掉了协议和主机名" + 
request.getQueryString(): 请求行中的参数部分，只能显示以get方式发出的参数，post方式的看不到
request.getRemoteAddr(): 浏览器所处于的客户机的IP地址
request.getRemoteHost(): 浏览器所处于的客户机的主机名
request.getRemotePort(): 浏览器所处于的客户机使用的网络端口
request.getLocalAddr(): 服务器的IP地址
request.getLocalName(): 服务器的主机名
request.getMethod(): 得到客户机请求方式一般是GET或者POST

9.J2EE是技术，还是平台，还是框架？
是平台，上面运行各种各样的技术(servlet,jsp,filter,listner)和框架(struts,hibernate,spring)

10.Servlet与JSP的关系：JSP就是Servlet。
11.编写JavaBean的注意事项：
JavaBean就是实体类
无参构造方法
属性都有public的getter和setter

12.MVC的各个部分都有哪些技术来实现，分别如何实现？
M 模型层代表数据，使用bean,dao等等，
V 视图层代表展现，使用html,jsp,css，
C 控制层代表控制，使用servlet。

13.JSP中两种include的区别？
一种是静态包含，一种是动态包含

详见：JSP中两种include的区别。

14.JSP中两种跳转的方式是什么，区别是什么？
分别是服务端跳转和客户端跳转。

15.如何实现在Servlet中用正则表达式对e-mail格式进行验证？

16.如何处理中文问题？
中文问题分几个部分：
1. 提交数据的时候使用UTF-8 编码；
2. 接受数据的时候使用UTF-8 解码；
3. 显示数据的时候使用UTF-8 编码。

17.简述你对简单Servlet、过滤器、监听器的理解：
Servlet 作用是处理获取参数，处理业务，页面跳转.

过滤器的作用是拦截请求，一般会用做编码处理，登陆权限验证.

监听器的作用是监听Request,Session,Context 等等的生命周期，以及其中数据的变化.