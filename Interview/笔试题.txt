止痒笔试：
--区别：

&和&&都可以用作逻辑与的运算符，表示逻辑与（and），当运算符两边的表达式的结果都为true时，整个运算结果才为true，否则，只要有一方为false，则结果为false。

&&还具有短路的功能，即如果第一个表达式为false，则不再计算第二个表达式，例如，对于if(str != null && !str.equals(“”))表达式，当str为null时，后面的表达式不会执行，所以不会出现NullPointerException如果将&&改为&，则会抛出NullPointerException异常。If(x==33 & ++y>0) y会增长，If(x==33 && ++y>0)不会增长

&还可以用作位运算符，当&操作符两边的表达式不是boolean类型时，&表示按位与操作，我们通常使用0x0f来与一个整数进行&运算，来获取该整数的最低4个bit位，例如，0x31 & 0x0f的结果为0x01。

--JAVA如何判断两个字符串是否相等
==比较引用，equals 比较值
1、java中字符串的比较：==
我们经常习惯性的写上if(str1==str2)，这种写法在java中可能会带来问题

 example1:

String a="abc";String b="abc"
那么a==b将返回true。因为在java中字符串的值是不可改变的，相同的字符串在内存中只会存

 一份，所以a和b指向的是同一个对象；

example2：

String a=new String("abc"); String b=new String("abc");
 那么a==b将返回false，此时a和b指向不同的对象。

 2、用equals方法比较的是字符串的内容是否相同，
example：

String a=new String("abc"); 
String b=new String("abc");
 a.equals(b);
将返回true。

--值传递和引用传递区别：
按值传递：值传递是指在调用函数时将实际参数复制一份传递到函数中，这样在函数中如果对参数进行修改，将不会影响到实际参数。简单来说就是直接复制了一份数据过去，因为是直接复制，所以这种方式在传递时如果数据量非常大的话，运行效率自然就变低了，所以java在传递数据量很小的数据是值传递，比如java中的各种基本类型：int,float,double,boolean等类型的，具体可以自己测试。
--------------------- 
引用传递：引用传递其实就弥补了上面说的不足，如果每次传参数的时候都复制一份的话，如果这个参数占用的内存空间太大的话，运行效率会很底下，所以引用传递就是直接把内存地址传过去，也就是说引用传递时，操作的其实都是源数据，这样的话修改有时候会冲突，记得用逻辑弥补下就好了。
--重载和重写的区别：

--jvm加载class文件的原理机制：
http://www.importnew.com/25295.html
原理机制非常简单，就是下面几个步骤:

1.装载:查找和导入class文件;

2.连接:

      (1)检查:检查载入的class文件数据的正确性;

      (2)准备:为类的静态变量分配存储空间;

      (3)解析:将符号引用转换成直接引用(这一步是可选的)

3.初始化:初始化静态变量，静态代码块。

      这样的过程在程序调用类的静态成员的时候开始执行，所以静态方法main()才会成为一般程序的入口方法。类的构造器也会引发该动作。

      
--常量池在哪？
方法区里存储着class文件的信息和动态常量池,class文件的信息包括类信息和静态常量池。可以将类的信息是对class文件内容的一个框架，里面具体的内容通过常量池来存储。

动态常量池里的内容除了是静态常量池里的内容外，还将静态常量池里的符号引用转变为直接引用，而且动态常量池里的内容是能动态添加的。例如调用String的intern方法就能将string的值添加到String常量池中，这里String常量池是包含在动态常量池里的，但在jdk1.8后，将String常量池放到了堆中。

--抽象类和接口的区别：

--Error和Exception的区别：
首先，Error类和Exception类都是继承Throwable类

Error（错误）是系统中的错误，程序员是不能改变的和处理的，是在程序编译时出现的错误，只能通过修改程序才能修正。一般是指与虚拟机相关的问题，如系统崩溃，虚拟机错误，内存空间不足，方法调用栈溢等。对于这类错误的导致的应用程序中断，仅靠程序本身无法恢复和和预防，遇到这样的错误，建议让程序终止。

Exception（异常）表示程序可以处理的异常，可以捕获且可能恢复。遇到这类异常，应该尽可能处理异常，使程序恢复运行，而不应该随意终止异常。

　　Exception又分为两类

　　　　CheckedException：（编译时异常） 需要用try——catch显示的捕获，对于可恢复的异常使用CheckedException。

　　　　UnCheckedException（RuntimeException）：（运行时异常）不需要捕获，对于程序错误（不可恢复）的异常使用RuntimeException。

--a=a+b和a+=b区别：

--int和Integer有什么区别？哪个会占用更多的内存？
1、Integer是int的包装类，int则是java的一种基本数据类型 
2、Integer变量必须实例化（new 一下是最常见的实例化）后才能使用，而int变量不需要 
3、Integer实际是对象的引用，new Integer()，实际上是生成一个指针指向此对象；而int则是直接存储数据值 
4、Integer的默认值是null，int的默认值是0

注意
Integer对象会占用更多的内存。Integer是一个对象，需要存储对象的元数据。但是int是一个原始类型的数据，所以占用的空间更少


--JRE/JDK/JVM/JIT之间有什么不同？
java虚拟机(JVM)
    使用java编程语言的主要优势就是平台的独立性。你曾经想知道过java怎么实现平台的独立性吗？对，就是虚拟机，它抽象化了硬件设备，开发者和他们的程序的得以操作系统。虚拟机的职责就是处理和操作系统的交流。java不同的接口规范对任何平台都有良好的支持，因为jvm很好的实现了每个平台的规范。jvm可以理解伪代码字节码，在用户和操作系统之间建立了一层枢纽。
 
java运行时环境(JRE)
    java运行时环境是JVM的一个超集。JVM对于一个平台或者操作系统是明确的，而JRE确实一个一般的概念，他代表了完整的运行时环境。我们在jre文件夹中看到的所有的jar文件和可执行文件都会变成运行时的一部分。事实上，运行时JRE变成了JVM。所以对于一般情况时候使用JRE，对于明确的操作系统来说使用JVM。当你下载了JRE的时候，也就自动下载了JVM。
 
java开发工具箱(JDK)
    java开发工具箱指的是编写一个java应用所需要的所有jar文件和可执行文件。事实上，JRE是JDK的一部分。如果你下载了JDK,你会看到一个名叫JRE的文件夹在里面。JDK中要被牢记的jar文件就是tools.jar,它包含了用于执行java文档的类还有用于类签名的jar包。
 
即时编译器(JIT)
    即时编译器是种特殊的编译器，它通过有效的把字节码变成机器码来提高JVM的效率。JIT这种功效很特殊，因为他把检测到的相似的字节码编译成单一运行的机器码，从而节省了CPU的使用。这和其他的字节码编译器不同，因为他是运行时(第一类执行的编译？)the firs of its kind to perform the compilation(从字节码到机器码）而不是在程序运行之前。正是因为这些，动态编译这个词汇才和JIT有那么紧密的关系。

--用最有效率的方法计算2乘以16？
由于在计算机中，位运算的效率是最高的，所以要想找出最有效率的运算方法，应该从位运算入手。Java 语言的位运算中提供了左移、右移和无符号右移运算符，它们分别是<>、>>>。左移运算会把操作数变大，它相当于把左侧操作数乘以2 的n 次幂，这个n 是由右操作数决定的。而右移运算恰恰相反，它实现的是除法。

使用位运算符计算2 乘以16，实现代码如下：

int value = 2 << 4;说明：

上面的代码段中2 << 4 就是将2 进行左移4 位运算，相当于2 乘以2 的4 次方，执行后value 的值是32，与2 乘以16 的值是完全相同的，但是由于位运算的速度要比乘法运算的速度快，所以2 乘以16 等于几最有效率的计算方法应该写成2 << 4。


--final、finally、finalize的不同之处？

--索引的概念和应用场景？
索引的好处：
建立索引后，查询时不会扫描全表，而会查询索引表锁定结果。

索引的缺点：
在数据库进行DML操作的时候，除了维护数据表之外，还需要维护索引表，运维成本增加。

应用场景：
数据量比较大，查询字段较多的情况。

索引规则：
1.选用选择性高的字段作为索引，一般unique的选择性最高。

2.复合索引：选择性越高的排在越前面。（左前缀原则）

3.如果查询条件中两个条件都是选择性高的，最好都建索引。

--------------------------------------------------------------------------------
索引的应用场景以及如何使用?

唯一的是什么？

  1. 索引列（字段）的所有值都只能出现一次，即必须唯一

--------------------------------------------------------------------------------

主键索引与唯一索引的区别

  1. 主键是一种约束，唯一索引是一种索引，两者在本质上是不同的。

  2. 主键创建后一定包含一个唯一性索引，唯一性索引并不一定就是主键。

  3. 唯一性索引列允许空值，而主键列不允许为空值。

  4. 主键列在创建时，已经默认为空值 ++    唯一索引了。

  5. 一个表最多只能创建一个主键，但可以创建多个唯一索引。

  6. 主键更适合那些不容易更改的唯一标识，如自动递增列、身份证号等。

  7. 主键可以被其他表引用为外键，而唯一索引不能。   ？

--------------------------------------------------------------------------------

复合索引

  1. 用户可以在多个列上建立索引，这种索引叫做复合索引(组合索引)。

  2. 就是几个字段联合在一起组成一个索引.复合索引的创建方法与创建单一索引的方法完全一样。

  3. 但复合索引在数据库操作期间所需的开销更小，可以代替多个单一索引。

  4. 当表的行数远远大于索引键的数目时，使用这种方式可以明显加快表的查询速度。

--------------------------------------------------------------------------------

（abc） （ab） （ac）（bc）（a） （b） （c）

  1. 复合索引又叫联合索引。

  2. abc    ab    a     ac  可以

  3. 对于复合索引:Mysql从左到右的使用索引中的字段，一个查询可以只使用索引中的一部份，但只能是最左侧部分。

  4. 例如索引是key index (a,b,c). 可以支持a | a,b| a,b,c 3种组合进行查找，但不支持 b,c进行查找 ,当最左侧字段是常量引用时，索引就十分有效。

--------------------------------------------------------------------------------

除复合索引外，什么情况下索引被使用，什么情况下不会被使用

  1. 建立索引的目的就是帮助查询,如果查寻用不到则索引就没有必要建立。

  2. 如果表是经常需要更新的也不适合做索引 。频繁更新会导致索引也会频繁更新，降低写的效率。

  3. 唯一性差的字段不适合创建索引。

  4. 当给一个字段创建了索引的话，而这个字段要进行like模糊查询的话，那么这个值左边不可以有%，因为索引查询是要从左到右的，你如果给它加上%后，左边的值不是确定的话，它会找不到这个索引。所以在使用like模糊查询的时候，值得左边不可以有%。

  5. order by  不会使用索引

  6. or 当前后2个字段都有索引时才可以索引出来 否则不可以。

  7. 如果数据表过大(5w以上)则有些字段(字符型长度超过(40))不适合作为索引。查询大量数据时,索引有效,但是慢

  8. 不使用索引的原因：因为索引时会先过一遍索引在过一遍数据

--------------------------------------------------------------------------------

全文检索：

  1. 全文检索就是FULLTEXT，用于 MyISAM 表，在列类型为 CHAR、VARCHAR 或 TEXT 列上创建。

  2. 将数据装载到一个没有 FULLTEXT 索引的表中，然后再使用 ALTER TABLE (或 CREATE INDEX) 创建索引，这将是非常快的。

  3. 将数据装载到一个已经有 FULLTEXT 索引的表中，将是非常慢的。

  4. MySQL自带的全文索引只能对英文进行全文检索。要检索中文用sphinx。

  5. 创建全文检索：alter table 表名 add fulltext index 索引名(列名,[列名]，[列名]..（可以有多个，可以有一个）

  6. 在创建表的时候建全文检索：CREATE TABLE article (

  7.      id INT UNSIGNED AUTO_INCREMENT NOT NULL PRIMARY KEY,

  8.      FULLTEXT (title, content) --在title和content列上创建全文索引

);

--------------------------------------------------------------------------------

场景

  1. 当数据多且字段值有相同的值得时候用普通索引。

  2. 当字段多且字段值没有重复的时候用唯一索引。

  3. 当有多个字段名都经常被查询的话用复合索引。

  4. 普通索引不支持空值，唯一索引支持空值。

  5. 但是，若是这张表增删改多而查询较少的话，就不要创建索引了，因为如果你给一列创建了索引，那么对该列进行增删改的时候，都会先访问这一列的索引，

  6. 若是增，则在这一列的索引内以新填入的这个字段名的值为名创建索引的子集，

  7. 若是改，则会把原来的删掉，再添入一个以这个字段名的新值为名创建索引的子集，

  8. 若是删，则会把索引中以这个字段为名的索引的子集删掉。

  9. 所以，会对增删改的执行减缓速度，

  10. 所以，若是这张表增删改多而查询较少的话，就不要创建索引了。

  11. 更新太频繁地字段不适合创建索引。

  12. 不会出现在where条件中的字段不该建立索引。

--------------------------------------------------------------------------------

索引创建

CREATE [UNIQUE|CLUSTERED] INDEX INDEX_NAME ON TABLE_NAME(PROPERTY_NAME)；

其中UNIQUE和CLUSTERED为可选项，分别是建立唯一索引和聚簇索引，具体解释为：

UNIQUE:表示此索引的每一个索引值只对应唯一的数据。

CLUSTERED:表示要建立的索引时聚簇索引，即索引项的顺序与表中记录的物理顺序一致的索引组织

ALTER TABLE table_name ADD INDEX index_name (column_list)


--利用递归求出一个数组的最大值？

--插入排序的时间复杂度、空间复杂度分析?