
---------------------
·索引：对数据库表中一列或多列的值进行排序的一种结构，使用索引可快速访问数据库表中的特定信息；
		快速查找排好序的一种数据结构。

	··索引方法/数据结构：https://www.cnblogs.com/luyucheng/p/6289048.html
		···B+Tree索引：
			非叶子节点不存储data，只存储索引（冗余），可以放更多的索引
			叶子节点包含所有索引字段
			叶子节点用指针连接（双向）-便于范围查找，提高取件访问的性能

		···Hash索引：
			底层数据结构就是hash表，需求为单条记录查询的话可以使用这个，查询性能快；
			仅支持"=","IN"和"<>"精确查询（“相等比较”），不能使用范围查询，不支持排序；时间复杂度是O(1)；
			在任何时候都不能避免表扫描；
			Hash索引一般用于内存数据库，比如Memory存储引擎（在MySQL中只有Memory存储引擎显式支持Hash索引，虽然它也支持B-Tree索引），数据放到内存里，为了加快速度，创建hash索引。

		···R-Tree索引在MySQL很少使用，仅支持geometry数据类型，支持该类型的存储引擎只有MyISAM、BDb、InnoDb、NDb、Archive几种。


	··索引性质：
		聚簇索引：表中记录的物理顺序和索引的排列顺序一致；
					CREATE CLUSTER INDEX index_name ON table_name(column_name1,column_name2,...);
					一个表只能有一个主键， 一个表只能有一个「聚集索引」，因为主键的作用就是把「表」的数据格式转换成「索引（平衡树）」的格式放置。
					但是，主键就是聚集索引，这种想法笔者认为是极端错误的，是对聚集索引的一种浪费。使用聚集索引的最大好处就是能够根据查询要求，迅速缩小查询范围，避免全表扫描。在实际应用中，因为ID号是自动生成的，我们并不知道每条记录的ID号，所以我们很难在实践中用ID号来进行查询。这就使让ID号这个主键作为聚集索引成为一种资源浪费。其次，让每个ID号都不同的字段作为聚集索引也不符合“大数目的不同值情况下不应建立聚合索引”规则;当然，这种情况只是针对用户经常修改记录内容， 特别是索引项的时候会负作用，但对于查询速度并没有影响。 

		非聚簇索引：……不一致；
					非聚集索引，也就是我们平时经常提起和使用的常规索引。
					非聚集索引和聚集索引一样，同样是采用平衡树作为索引的数据结构。索引树结构中各节点的值来自于表中的索引字段，假如给user表的name字段加上索引，那么索引就是由name字段中的值构成，在数据改变时，DBMS需要一直维护索引结构的正确性。如果给表中多个字段加上索引，那么就会出现多个独立的索引结构，每个索引（非聚集索引）互相之间不存在关联。 

		区别：聚簇索引能提高多行检索的速度，而非聚簇索引对于单行的检索很快。

		聚集索引和聚集索引的区别在于，通过聚集索引可以查到需要查找的数据，而通过非聚集索引可以查到记录对应的主键值，再使用主键的值通过聚集索引查找到需要的数据。聚集索引（主键）是通往真实数据所在的唯一路径。

		然而，有一种例外可以不使用聚集索引就能查询出所需要的数据，这种非主流的方法 称之为「覆盖索引」查询，也就是平时所说的组合索引或者多字段索引查询。 当为字段建立索引以后，字段中的内容会被同步到索引之中，如果为一个索引指定两个字段，那么这个两个字段的内容都会被同步至索引之中。



	··mysql索引类型：
		普通索引[Normal]：最基本的MySQL数据库索引，它没有任何限制；
							普通索引允许关键字段有相同值。在一对多关系的多方，可以使用普通索引。
							索引字段值不唯一，应该选择的索引类型为普通索引。
							CREATE INDEX indexName ON mytable(username(length))；
							如果是CHAR类型，VARCHAR类型，length可以小于字段实际长度；如果是BLOB和TEXT类型，必须指定length，下同。

		
		唯一索引[Unique]：数据库索引列的值必须唯一，但允许有空值；
							唯一索引允许关键字取重复的值。当有重复值出现时，索引文件只保存重复值的第1次出现。提供唯一索引主要是为了兼容早期的版本。
							CREATE UNIQUE INDEX indexName ON mytable(username(length))

		主键索引：一种特殊的唯一索引，一个表只能有一个主键，不允许有空值；
					主索引是一种只能在数据库表中建立、不能在自由表中建立的索引。在指定的字段或表达式中，主索引的关键字绝对不允许有重复值。
					候选索引和主索引类似，它的值也不允许在指定的字段或表达式中重复。一个表中可以有多个候选索引。
					CREATE TABLE mytable(   ID INT NOT NULL,    username VARCHAR(16) NOT NULL,   PRIMARY KEY(ID)   );一般建表时创建。

		组合索引：对比于单列索引，MySQL组合索引遵循“最左前缀”集合，简单的理解就是只从最左边的开始组合。在查询条件中使用了创建索引时的第一个字段，索引才会被使用。
					效率大于各个单列索引的索引合并；
					组合索引的列值的组合必须唯一。
				eg:
					CREATE TABLE mytable(   ID INT NOT NULL,    username VARCHAR(16) NOT NULL,   city VARCHAR(50) NOT NULL,   age INT NOT NULL  ); 
					ALTER TABLE mytable ADD INDEX name_city_age (name(10),city,age);
					建表时，usernname长度为 16，这里用10。这是因为一般情况下名字的长度不会超过10，这样会加速索引查询速度，还会减少索引文件的大小，提高INSERT的更新速度。
					
					如果分别在 usernname，city，age上建立单列索引，让该表有3个单列索引，查询时和上述的组合索引效率也会大不一样，远远低于我们的组合索引。虽然此时有了三个索引，但MySQL只能用到其中的那个它认为似乎是最有效率的单列索引。

					建立这样的组合索引，其实是相当于分别建立了下面三组组合索引：
					usernname,city,age   usernname,city   usernname  为什么没有city，age这样的组合索引呢？这是因为MySQL组合索引“最左前缀”的结果。

					并不是只要包含这三列的查询都会用到该组合索引，下面的几个SQL就会用到这个组合索引：
					SELECT * FROM mytable WHREE username="admin" AND city="郑州"  SELECT * FROM mytable WHREE username="admin"
					而下面几个则不会用到：
					SELECT * FROM mytable WHREE age=20 AND city="郑州"  SELECT * FROM mytable WHREE city="郑州"


		全文索引[Full Text]：用来查找文本中的关键字，而不是直接与索引中的值相比较；像是一个搜索引擎，而不是简单的where语句的参数匹配。
							fulltext索引配合match against操作使用，而不是一般的where语句加like；
							目前只有char、varchar，text列上可以创建全文索引。
							值得一提的是，在数据量较大时候，现将数据放入一个没有全局索引的表中，然后再用CREATE index创建fulltext索引，要比先为一张表建立fulltext然后再将数据写入的速度快很多。）；


	··为什么要使用索引？/索引优点？
		···加快数据的检索速度；
		···将随机i/o变成顺序i/o；
		···帮助服务器避免排序和临时表；
		···创建唯一性索引，保证表中每一行数据的唯一性；
		···加快表和表之间的连接；


	··为什么不可以每一列都创建索引？/索引缺点？
		1.虽然索引大大提高了查询速度，同时却会降低更新表的速度，如对表进行INSERT、UPDATE和DELETE。因为更新表时，MySQL不仅要保存数据，还要保存一下索引文件。
		2.建立索引会占用磁盘空间的索引文件。一般情况这个问题不太严重，但如果你在一个大表上创建了多种组合索引，索引文件的会膨胀很快。
		索引只是提高效率的一个因素，如果你的MySQL有大数据量的表，就需要花时间研究建立最优秀的索引，或优化查询语句。


	··索引是如何提高检索速度的？
		将无序的数据变成相对有序的数据；


	··在什么情况下建立索引呢？
		···一般来说，在where和join、order by排序和 group by分组中出现的列需要建立索引，但也不完全如此，
			因为MySQL只对<，<=，=，>，>=，BETWEEN，IN，以及某些时候的LIKE才会使用索引。

		···主键自动创建唯一索引；多表关联查询时外键应该创建；在不同值多的列上建；经常搜索的列上；非经常更新的行建立索引；单键/组合索引的选择问题，组合索引性价比高；

		···非越多越好；表记录少不用；经常增删改的表或者字段不用(因为提高了查询速度，却降低了更新表的速度；更新表时，不仅要保存数据，还要保存索引文件)；


	··索引使用经验：
		···短索引：给索引设置长度。
				如果可以的话，应该指定一个前缀长度。如果有一个char(255)的列，如果在前10个或20个字符内，多数值是惟一的，那么就不要对整个列进行索引。短索引不仅能够提高查询速度，而且能节省I/O操作。

		···使用逻辑主键作为主键，不要使用业务主键为主键；
		···删除长期未使用的索引，不要造成不必要的性能损耗；

		···MySQL查询只使用一个索引，因此如果where子句中已经使用了索引的话，那么order by中的列是不会使用索引的。
			因此数据库默认排序可以符合要求的情况下不要使用排序操作；尽量不要包含多个列的排序，如果需要最好给这些列创建组合索引。

			其实，MySQL5.0之后是有索引合并这个概念的，MySQL可以同时使用多个索引。

		···数据库中查询记录时是否每次只能使用一个索引？
			与其说是“数据库查询只能用到一个索引”，倒不如说是 和全表扫描/只使用一个索引的速度比起来，去分析两个索引二叉树更加耗费时间，所以绝
			大多数情况下数据库都是是用一个索引。
			如这条语句：
						select count(1) from table1 where column1 = 1 and column2 = 'foo' and column3 = 'bar'

			我们来想象一下当数据库有N个索引并且查询中分别都要用上他们的情况：
			查询优化器（用大白话说就是生成执行计划的那个东西）需要进行N次主二叉树查找[这里主二叉树的意思是最外层的索引节点]，此处的查找流程大概如下：
			查出第一条column1主二叉树等于1的值，然后去第二条column2主二叉树查出foo的值并且当前行的coumn1必须等于1，最后去column主二叉树查找bar的值并且column1必须等于1和column2必须等于foo。

			如果这样的流程被查询优化器执行一遍，就算不死也半条命了，查询优化器可等不及把以上计划都执行一遍，贪婪算法（最近邻居算法）可不允许这种情况的发生，所以当遇到以上语句的时候，数据库只要用到第一个筛选列的索引（column1），就会直接去进行表扫描了。
						
			所以与其说是数据库只支持一条查询语句只使用一个索引，倒不如说N条独立索引同时在一条语句使用的消耗比只使用一个索引还要慢。

			所以如上条的情况，最佳推荐是使用index(column1,column2,column3）这种联合索引，此联合索引可以把b+tree结构的优势发挥得淋漓尽致：
			一条主二叉树（column=1），查询到column=1节点后基于当前节点进行二级二叉树column2=foo的查询，在二级二叉树查询到column2=foo后，去三级二叉树column3=bar查找。


	··索引什么情况下会失效？
		···字段包含有null值，索引会忽略null值，所以我们在设计数据库的时候设置为NOT_NULL；

		···不适用于否定操作（not in , <>, !=）；

		···索引列上对字段表达式的操作失效，包括运算、使用函数；

		···对于多列索引，不是使用的第一部分，则不会使用索引；

		···like查询以通配符%和_开头作查询时，不会使用索引；结尾可以生效。

		···条件中有or，即使其中有条件带索引也不会使用(这也是为什么尽量少用or的原因)；
			注意：要想使用or，又想让索引生效，只能将or条件中的每个列都加上索引；

		···如果列类型是字符串，那一定要在条件中将数据使用引号引用起来,否则不使用索引；

		···如果mysql估计使用全表扫描要比使用索引快，则不使用索引；

		查看索引的使用情况：
			show status like 'Handler_read%';
			大家可以注意：
			Handler_read_first 		代表读取索引头的次数，如果这个值很高，说明全索引扫描很多。
			Handler_read_key		代表一个索引被使用的次数，如果我们新增加一个索引，可以查看Handler_read_key是否有增加，如果有增加，说明sql用到索引。
			Handler_read_next 		代表读取索引的下列，一般发生range scan。
			Handler_read_prev 		代表读取索引的上列，一般发生在order by … desc。
			Handler_read_rnd 		代表在固定位置读取行，如果这个值很高，说明对大量结果集进行了排序、进行了全表扫描、关联查询没有用到合适的KEY。
			Handler_read_rnd_next 	代表进行了很多表扫描，查询性能低下。


	··索引命名规范：
		···主键索引名为 pk_字段名；
		···唯一索引名为 uk_字段名；
		···普通索引名则为 idx_字段名。 
			说明：pk_ 即primary key；uk_ 即unique key；idx_ 即index的简称。
