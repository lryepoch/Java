
·NoSQL：基于内存的数据库，并且提供一定的持久化功能；


·Redis技术：
	··它的性能十分优越，可以支持每秒十几万此的读/写操作，其性能远超数据库；
	··支持集群、分布式、主从同步等配置，原则上可以无限扩展，让更多的数据存储在内存中；
	··还支持一定的事务能力，这保证了高并发的场景下数据的安全和一致性。


·使用场景：
	··存储缓存用的数据；限于成本的原因，一般我们只是使用Redis存储一些常用和主要的数据，比如用户登录的信息等。
	··需要高速读/写的场合，使用它快速读/写；

	··数据缓存；
	··session共享；





·使用Redis进行存储的时候，我们需要从以下几个方面来考虑：
	··业务数据常用吗？命中率如何？如果命中率很低，就没有必要写入缓存；
	··该业务数据是读操作多，还是写操作多？如果写操作多，频繁需要写入数据库，也没有必要使用缓存；
	··业务数据大小如何？如果要存储几百兆字节的文件，会给缓存带来很大的压力，这样也没有必要；


·Redis来应对这样的高并发需求的场合，阐述这个过程：
	··当一个请求到达服务器时，只是把业务数据在 Redis 上进行读写，而没有对数据库进行任何的操作，这样就能大大提高读写的速度，从而满足高速响应的需求；
	··但是这些缓存的数据仍然需要持久化，也就是存入数据库之中，所以在一个请求操作完Redis的读/写之后，会去判断该高速读/写的业务是否结束，这个判断通常会在秒杀商品为0，红包金额为0时成立，如果不成立，则不会操作数据库；如果成立，则触发事件将Redis缓存的数据以批量的形式一次性写入数据库，从而完成持久化的工作。


·redis与Java的配合：
	··在常见命令中，使用各种Redis自带客户端的命令行方式访问Redis服务。而在实际工作中却需要用到Java代码才能访问，	使用第三方jar包：Jedis，就能方便地访问Redis的各种服务了。

	··在Java中我们却通常以类对象为主，所以在需要Redis存储的五中数据类型与Java对象之间进行转换，如果自己编写一些工具类，比如一个角色对象的转换，还是比较容易的，但是涉及到许多对象的时候，这其中无论工作量还是工作难度都是很大的，Redis无法操作对象的问题，无法在那些基础类型和Java对象之间方便的转换；

	··但是在Spring中，这些问题都可以通过使用RedisTemplate得到解决！除了Jedis包以外还需要在 Spring 引入spring-data-redis包；

	··配置RedisTemplate时，普通的连接根本没有办法直接将对象直接存入Redis内存中，我们需要替代的方案：将对象序列化（可以简单的理解为继承Serializable接口）。我们可以把对象序列化之后存入Redis缓存中，然后在取出的时候又通过转换器，将序列化之后的对象反序列化回对象，这样就完成了我们的要求：


·spring与redis集成：
	··redis配置文件；
	··spring配置文件中配置redis，如使用spring配置JedisPoolConfig（连接池）对象，之后为连接池配置工厂模型，第三配置RedisTemplate；


·springboot与redis集成：
	··springboot配置文件中配置redis；
	··自定义redis缓存器【redisTemplate】；
	··使用注解；
		---------------
		@Cacheable：支持缓存，当被调用后将返回值缓存起来，保证下次利用同样参数执行该方法时可以直接从缓存中获取结果，而不需要再次执行该方法；
		参数： value缓存名、 key缓存键值、 condition满足缓存条件、unless否决缓存条件 
	
		value属性是必须指定的，其表示当前方法的返回值是会被缓存在哪个Cache上的，对应Cache的名称。其可以是一个Cache也可以是多个Cache，当需要指定多个Cache时其是一个数组。

		key属性是用来指定Spring缓存方法的返回结果时对应的key的。该属性支持SpringEL表达式。当我们没有指定该属性时，Spring将使用默认策略生成key。可以直接使用“#参数名”或者“#p参数index”。

		condition属性默认为空，表示将缓存所有的调用情形。当为true时表示进行缓存处理；当为false时表示不进行缓存处理，即每次调用该方法时该方法都会执行一次。


		----------------
		@CachePut：支持缓存，执行前不会检查是否存在之前执行过的结果，而是每次都会执行该方法，并将执行结果以键值对的形式存入指定的缓存中； 主要用于数据新增和修改方法。

		----------------
		@CacheEvict：触发缓存的清除操作；方法执行成功后会从缓存中移除相应数据。
		参数： value缓存名、 key缓存键值、 condition满足缓存条件、 unless否决缓存条件、 allEntries是否移除所有数据（设置为true时会移除所有缓存） 、beforeInvocation（指定该属性值为true时，Spring会在调用该方法之前清除缓存中的指定元素）


		------------------
		@CacheConfig是一个类级别的注解，允许共享缓存的名称、KeyGenerator、CacheManager 和CacheResolver。 

		Spring Redis默认使用JDK进行序列化和反序列化，因此被缓存对象需要实现java.io.Serializable接口，否则缓存出错。
		当被缓存对象发生改变时，可以选择更新缓存或者失效缓存，但一般而言，后者优于前者，因为执行速度更快。



-------------------------
·Redis有不同的数据类型，有不同的命令方式；
	··数据库键总是一个字符串对象SDS；
	··数据库键的值可以是5种数据类型：字符串SDS、列表、哈希表、集合、有序集合；
	
	字符串：
		·简单动态字符串【SDS】：底层是一个结构体，属性包含len[字符串长度，不计算空字符‘\0’的值]，free[未使用字节的数量]，buf[][字节数组，保存字符串，深一点说是保存二进制数据]；
		·C字符串只会作为字符串字面量，用于无须对字符串进行值修改的地方，如日志。SDS不仅是一个字符串字面量，还是一个可以被修改的字符串值。字符串值底层都是SDS实现的。
		·C字符串和SDS区别：
			··常数复杂度获取字符串长度。SDS为O(1)；字符串为O(n)，因为需要遍历计算;
			··杜绝缓冲区溢出。SDS可以动态扩容，C字符串不行；
			··减少修改字符串时带来的内存重分配次数。SDS包括空间预分配和惰性空间释放，修改n次最多执行n次内存分配；C字符串修改n次必须执行n次内存分配；
				空间预分配时，如果len的值小于1MB，那么分配和len属性同样大小的未使用空间(free);如果大于等于1MB,则分配1MB未使用的空间；
			··二进制安全。C字符串只能保存文本数据，因为字符串中不能包含空字符；SDS API都会以二进制的方式处理数组中的数据，可以保存文本和一系列二进制数据；
			··兼容部分C字符串的函数。SDS遵循C字符串也以空字符结尾，以便重用一部分<string.h>库定义的函数，避免不必要的代码重复；
		·SDS有很多API可供使用；

	链表：
		·链表底层：双端、无环、带表头指针和表尾指针、链表长度计算器、多态；
		·列表键底层实现之一就是链表；条件：包含数量较多的元素，或者列表中包含的元素是比较长的字符串时； 
		·链表用于列表键、发布和订阅、慢查询、监视器；
		·每个节点都有一个前置指针和后置指针，所以链表的实现是双端链表；
		·表头的前置节点和表位的后置节点都指向null，所以Redis的链表实现是无环链表；
		·链表可以保存不同类型的值；

	字典：
		·用于保存键值对，数据库和哈希键的底层都是字典；
		·字典底层则使用哈希表实现，一个哈希表有多个哈希表节点，每个哈希表节点保存了字典中一个键值对；
		·每个字典都有两个哈希表，一个平时使用，另一个仅在进行rehash时使用；

	跳跃表：
		·一种有序数据结构，在每个节点中维持多个指向其他节点的指针，从而达到快速访问节点；
		·跳跃表用于有序集合键和集群节点中用作内部数据结构；


	整数集合：
		·整数集合是集合键的底层实现之一，当集合只包含整数值元素，这个集合元素数量不多时，就会使用它；
		·整数集合的底层实现为数组，以有序、无重复的方式保存集合元素，在有需要时，程序会根据新添加元素的类型，改变这个数组的类型；


	压缩列表：
		·一种为节约内存而开发的顺序型数据结构；
		·用作列表键和哈希键的底层实现之一；




	对象：
		·基于以上的数据结构，Redis创建了一个对象系统；5种类型的对象至少都有两种或者2种以上的编码方式，不同的编码在不同的场景上优化对象的使用效率；
		·使用OBJECT ENCODING 可以查看一个数据库键的值对象的编码；

		·服务器执行某些命令时，先检查给定键的类型能否执行指定的命令，而检查一个键的类型就是检查键的值对象的类型；
		·操作键的命令分为2种，一种可以对任何类型的键执行；一种只能对特定类型的键执行；
		·Redis的对象系统带有引用计数实现的内存回收机制，当一个对象不再被使用时，该对象所占用的内存就会被自动释放；
		·Redis会共享值为0-9999的字符串对象；
		·对象会记录自己的最后一次被访问的时间，这个时间可以用于计算对象的空转时间；



·Redis单机数据库：
	··数据库：
		···Redis默认创建16个数据库；
		···默认下，Redis客户端的目标数据库为0号数据库，可通过SELECT指令来切换目标数据库；
		···键空间和用户所见的数据库是直接对应的，键空间是一个字典；
		···设置键的生存时间：EXPIRE 键值 生存时间		->服务器自动删除生存时间为0的键；

	··RDB持久化：


	··AOF持久化：


·Redis多机数据库：




·独立功能的实现：
	··事务：
		···MULTI：进入事务；
			EXEC：提交事务；
			WATCH：一个乐观锁。在EXEC命令执行之前，监视任意数量的数据库键，并在EXEC命令执行时，检查被监视的键是否至少有一个已经被修改过了，如果是的话，服务器将拒绝执行事务，并向客户端返回代表事务执行失败的空回复。
		···当一个客户端处于非事务状态时，这个客户端发送的命令会立即被服务器执行；而当客户端处于事务状态后，服务器根据客户端发来的不同命令执行不同操作：
			=======当发送命令为EXEC/DISCARD/WATCH/MULTI四个命令的其中一个，服务器立刻执行这个命令；
			=======当非以上命令时，则不会立即执行，而是将命令放入一个事务队列里面，然后向客户端返回QUEUED回复；
		···提供了一种将多个命令打包，然后一次性、有序地执行的机制；
		···多个命令会被放入到事务队列中，然后按照先进先出的顺序执行；
		···事务在执行过程中不会被中断，当事务队列中所有命令都被执行完毕后，事务才会结束；
		···Redis的事务总是具有ACID中的原子性、一致性、隔离性；当服务器运行在AOF持久化模式下，并且appendfsync选项的值为always时，事务也具有持久性；






	